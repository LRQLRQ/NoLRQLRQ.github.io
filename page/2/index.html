<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>欢迎来到，瑞卿的窝。</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习的小小笔记，记在这里。">
<meta property="og:type" content="website">
<meta property="og:title" content="欢迎来到，瑞卿的窝。">
<meta property="og:url" content="https://lrqlrq.github.io/page/2/index.html">
<meta property="og:site_name" content="欢迎来到，瑞卿的窝。">
<meta property="og:description" content="学习的小小笔记，记在这里。">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="欢迎来到，瑞卿的窝。">
<meta name="twitter:description" content="学习的小小笔记，记在这里。">
  
    <link rel="alternate" href="/atom.xml" title="欢迎来到，瑞卿的窝。" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
  <link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">欢迎来到，瑞卿的窝。</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">诗与远方在哪里？</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://lrqlrq.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-学习VUE" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/学习VUE/" class="article-date">
  <time datetime="2018-11-03T07:03:09.818Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/学习VUE/">学习VUE</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>2018.10.15  开始学习vue</p>
<p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p>
<p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p>
<p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p>
<p>第一段vue代码示例</p>
<pre><code>&lt;div id=&quot;vue_det&quot;&gt;
    &lt;h1&gt;site : {{site}}&lt;/h1&gt;
    &lt;h1&gt;url : {{url}}&lt;/h1&gt;
    &lt;h1&gt;{{details()}}&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
    var vm = new Vue({
        el: &#39;#vue_det&#39;,
        data: {
            site: &quot;菜鸟教程&quot;,
            url: &quot;www.runoob.com&quot;,
            alexa: &quot;10000&quot;
        },
        methods: {
            details: function() {
                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;
            }
        }
    })
&lt;/script&gt;
</code></pre><p>可以看到在 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。在上面实例中 id 为 vue_det，在 div 元素中：</p>
<pre><code>&lt;div id = &quot;vue_det&quot;&gt;&lt;/div&gt;
</code></pre><h4 id="这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。"><a href="#这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。" class="headerlink" title="这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。"></a><b>这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。</b></h4><p>接下来我们看看如何定义数据对象。</p>
<p>data 用于定义属性，实例中有三个属性分别为：site、url、alexa。</p>
<p>methods 用于定义的函数，可以通过 return 来返回函数值。</p>
<p>用于输出对象属性和函数返回值。</p>
<h4 id="当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化"><a href="#当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化" class="headerlink" title="当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化"></a><b>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化</b></h4><pre><code>&lt;div id=&quot;vue_det&quot;&gt;
    &lt;h1&gt;site : {{site}}&lt;/h1&gt;
    &lt;h1&gt;url : {{url}}&lt;/h1&gt;
    &lt;h1&gt;Alexa : {{alexa}}&lt;/h1&gt;
&lt;/div&gt;
&lt;script type=&quot;text/javascript&quot;&gt;
// 我们的数据对象
var data = { site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000}
var vm = new Vue({
    el: &#39;#vue_det&#39;,
    data: data
})
// 它们引用相同的对象！
document.write(vm.site === data.site) // true
document.write(&quot;&lt;br&gt;&quot;)
// 设置属性也会影响到原始数据
vm.site = &quot;Runoob&quot;
document.write(data.site + &quot;&lt;br&gt;&quot;) // Runoob

// ……反之亦然
data.alexa = 1234
document.write(vm.alexa) // 1234
&lt;/script&gt;

</code></pre><h2 id="Vue-js-模板语法"><a href="#Vue-js-模板语法" class="headerlink" title="Vue.js 模板语法"></a>Vue.js 模板语法</h2><p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p>
<p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。</p>
<p>结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p>
<ol>
<li>插值<br><b>文本</b><br>数据绑定最常见的形式就是使用<pre><code>{{...}}（双大括号）
</code></pre>的文本插值：</li>
</ol>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  &lt;p&gt;{{ message }}&lt;/p&gt;
&lt;/div&gt;
</code></pre><p><b>Html</b><br>使用 v-html 指令用于输出 html 代码：</p>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><b>指令</b></h4><p>指令是带有 v- 前缀的特殊属性。</p>
<p>指令用于在表达式的值改变时，将某些行为应用到 DOM 上。</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    seen: true
  }
})
&lt;/script&gt;
</code></pre><p>新建一个vue对象，用el名绑定div中的id，那么在这个id为xxx的div块中，就可以使用其元素相应的数据。</p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;pre&gt;&lt;a v-bind:href=&quot;url&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    url: &#39;http://www.runoob.com&#39;
  }
})
&lt;/script&gt;
</code></pre><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;p&gt;{{ message }}&lt;/p&gt;
    &lt;input v-model=&quot;message&quot;&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    message: &#39;Runoob!&#39;
  }
})
&lt;/script&gt;
</code></pre><p>v-model 指令用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。</p>
<p>按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。</p>
<p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”指示, 格式如下：</p>
<pre><code>&lt;!-- 在两个大括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 v-bind 指令中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
&lt;!-- 在两个大括号中 --&gt;
{{ message | capitalize }}

&lt;!-- 在 v-bind 指令中 --&gt;
&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;
</code></pre><p>过滤器函数接受表达式的值作为第一个参数。</p>
<p>以下实例对输入的字符串第一个字母转为大写：</p>
<pre><code>&lt;div id=&quot;app&quot;&gt;
  {{ message | capitalize }}
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    message: &#39;runoob&#39;
  },
  filters: {
    capitalize: function (value) {
      if (!value) return &#39;&#39;
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
})
&lt;/script&gt;
</code></pre><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;
&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;
&lt;!-- 缩写 --&gt;
&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;
</code></pre><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p>
<h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;
&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;
&lt;!-- 缩写 --&gt;
&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;
</code></pre><h3 id="Vue-js-条件与循环"><a href="#Vue-js-条件与循环" class="headerlink" title="Vue.js 条件与循环"></a>Vue.js 条件与循环</h3><pre><code>&lt;div id=&quot;app&quot;&gt;
    &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;
      A
    &lt;/div&gt;
    &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;
      B
    &lt;/div&gt;
    &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;
      C
    &lt;/div&gt;
    &lt;div v-else&gt;
      Not A/B/C
    &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    type: &#39;C&#39;
  }
})
&lt;/script&gt;
</code></pre><h4 id="v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后"><a href="#v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后" class="headerlink" title="v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后"></a>v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后</h4><h4 id="我们也可以使用-v-show-指令来根据条件展示元素："><a href="#我们也可以使用-v-show-指令来根据条件展示元素：" class="headerlink" title="我们也可以使用 v-show 指令来根据条件展示元素："></a>我们也可以使用 v-show 指令来根据条件展示元素：</h4><pre><code>&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
    &lt;meta charset=&quot;utf-8&quot;&gt;
    &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt;
    &lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;div id=&quot;app&quot;&gt;
    &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;
&lt;/div&gt;

&lt;script&gt;
new Vue({
  el: &#39;#app&#39;,
  data: {
    ok: true
  }
})
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre><h4 id="vue中的watch用法"><a href="#vue中的watch用法" class="headerlink" title="vue中的watch用法"></a>vue中的watch用法</h4><p>watch用来监听data中数据的变化，如果发生了变化，则进行操作。</p>
<pre><code>handler(newName,oldName){
    this.fullName = newName + &#39;&#39; + this.lastName;
},
immediate: true
</code></pre><p>以上代码，可以在一开始改变firstName的时候，就进行监听</p>
<p>此外，watch还有一个deep属性，默认值是<code>false</code>，代表是否深度监听。比如<code>data</code>里面有别的属性，则当属性改变时候，一般情况是监听不到的。只有加了<code>deep:true</code>，才会监听到属性值的改变。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/学习VUE/" data-id="cjp7yjwsr000pm07qi0qkrqz4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/vue/">vue</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-学习JavaScript" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/学习JavaScript/" class="article-date">
  <time datetime="2018-11-03T06:46:56.976Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/学习JavaScript/">学习JavaScript</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="1-这是我第一天学习JavaScript"><a href="#1-这是我第一天学习JavaScript" class="headerlink" title="1.这是我第一天学习JavaScript"></a>1.这是我第一天学习JavaScript</h1><p><em>斜体</em><br><strong>粗体</strong><br><del>好吗？</del></p>
<blockquote>
<p>这是引用<br>sss</p>
</blockquote>
<pre><code>print(&quot;hello!&quot;);
return 0;
</code></pre><hr>
<p>##1.为什么学习 JavaScript?##<br>JavaScript web 开发人员必须学习的 3 门语言中的一门：</p>
<p>HTML 定义了网页的内容<br>CSS 描述了网页的布局<br>JavaScript 网页的行为</p>
<p>##2.学习中的要点##</p>
<p>alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</p>
<p>您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。<br>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p>
<p>###JavaScript 用法###<br>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。<br>脚本可被放置在 HTML 页面的 <body> 和 <head><meta name="generator" content="Hexo 3.8.0"> 部分中。<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></body></p>
<p>那些老旧的实例可能会在 script 标签中使用 type=”text/javascript”。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言</p>
<h3 id="在-head-或者-body-的JavaScript"><a href="#在-head-或者-body-的JavaScript" class="headerlink" title="在 head 或者 body 的JavaScript"></a>在 head 或者 body 的JavaScript</h3><p>您可以在 HTML 文档中放入不限数量的脚本。<br>脚本可位于 HTML 的 body 或 head 部分中，或者同时存在于两个部分中。</p>
<p>通常的做法是把函数放入 head 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
<p>###外部的 JavaScript###<br>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在 script 标签的 “src” 属性中设置该 .js 文件：</p>
<p>##JavaScript 输出##</p>
<p>###JavaScript 没有任何打印或者输出的函数。###</p>
<p>JavaScript 可以通过不同的方式来输出数据：</p>
<ol>
<li>使用 window.alert() 弹出警告框。</li>
<li>使用 document.write() 方法将内容写到 HTML 文档中。</li>
<li>使用 innerHTML 写入到 HTML 元素。</li>
<li>使用 console.log() 写入到浏览器的控制台。</li>
</ol>
<p>2中的操作 HTML 元素<br>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。</p>
<p>请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：</p>
<p>请使用 document.write() 仅仅向文档输出写内容。<br>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖</p>
<p>###JavaScript 注释###<br>不是所有的 JavaScript 语句都是”命令”。双斜杠 // 后的内容将会被浏览器忽略：</p>
<p>###JavaScript 语句###<br>JavaScript 语句是发给浏览器的命令。</p>
<p>这些命令的作用是告诉浏览器要做的事情。</p>
<p>###重新声明 JavaScript 变量###<br>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p>
<p>在以下两条语句执行后，变量 carname 的值依然是 “Volvo”<br>var carname=”Volvo”;<br>var carname;</p>
<p>#JavaScript变量学习图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709822216279.gif" alt="avatar"></p>
<p>###JavaScript 对象###<br>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p>
<pre><code>var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};
</code></pre><p> 等价于</p>
<pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> person<span class="token operator">=</span><span class="token punctuation">{</span>
    firstname <span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>
    lastname  <span class="token punctuation">:</span> <span class="token string">"Doe"</span><span class="token punctuation">,</span>
    id        <span class="token punctuation">:</span>  <span class="token number">5566</span>
 <span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>对象属性有两种寻址方式：</p>
<ol>
<li>name=person.lastname;</li>
<li>name=person[“lastname”];</li>
</ol>
<p>###提示：JavaScript具有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。###</p>
<p>#JavaScript数据类型学习脑图：#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710140220491.gif" alt="avatar"></p>
<p>#JavaScript函数学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709911288582.gif" alt="avatar"></p>
<p>##JavaScript 全局变量##</p>
<p>变量在函数外定义，即为全局变量。<br>全局变量有 全局作用域: 网页中所有脚本和函数均可使用。</p>
<p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。<br>以下实例中 carName 在函数内，但是为全局变量。<br>// 此处可调用 carName 变量 </p>
<p>function myFunction() {<br>    carName = “Volvo”;<br>    // 此处可调用 carName 变量<br>}</p>
<p>##HTML 事件##<br>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<p>HTML 网页中的每个元素都可以产生某些可以触发 JavaScript 函数的事件。</p>
<p>以下是 HTML 事件的实例：</p>
<ol>
<li>HTML 页面完成加载</li>
<li>HTML input 字段改变时</li>
<li>HTML 按钮被点击<br>通常，当事件发生时，你可以做些事情。</li>
</ol>
<p>在事件触发时 JavaScript 可以执行一些代码。</p>
<p>常见的HTML事件<br>下面是一些常见的HTML事件的列表:</p>
<p>事件—————-描述<br>onchange———HTML 元素改变<br>onclick    ————用户点击 HTML 元素<br>onmouseover—–用户在一个HTML元素上移动鼠标<br>onmouseout——用户从一个HTML元素上移开鼠标<br>onkeydown——-用户按下键盘按键<br>onload————浏览器已完成页面的加载</p>
<p>#JavaScript运算符学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20170921/1505989160659350.gif" alt="avatar"></p>
<p>#JavaScript流程语句学习脑图#</p>
<p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710031660821.gif" alt="avatar"></p>
<p>##Throw 语句##<br>throw 语句允许我们创建自定义错误。</p>
<p>正确的技术术语是：创建或抛出异常（exception）。<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。</p>
<pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span> 
        <span class="token keyword">var</span> x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token string">"值为空"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"不是数字"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token string">"太大"</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token string">"太小"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> y<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        y<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"错误："</span> <span class="token operator">+</span> err <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>##JavaScript 调试工具##<br>在程序代码中寻找错误叫做代码调试。</p>
<p>调试很难，但幸运的是，很多浏览器都内置了调试工具。</p>
<p>内置的调试工具可以开始或关闭，严重的错误信息会发送给用户。</p>
<p>有了调试工具，我们就可以设置断点 (代码停止执行的位置), 且可以在代码执行时检测变量。</p>
<p>浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<ol>
<li>console.log() 方法</li>
<li>设置断点<br>在调试窗口中，你可以设置 JavaScript 代码的断点。<br>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。<br>在检查完毕后，可以重新执行代码（如播放按钮）。</li>
<li>debugger 关键字<br>debugger 关键字用于停止执行 JavaScript，并调用调试函数。<br>这个关键字与在调试工具中设置断点的效果是一样的。<br>如果没有调试可用，debugger 语句将无法工作。<br>开启 debugger ，代码在第三行前停止执行。</li>
</ol>
<p>##JavaScript 表单验证##</p>
<p>###JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证###</p>
<p>###表单数据经常需要使用 JavaScript 来验证其正确性：###</p>
<ol>
<li>验证表单数据是否为空？</li>
<li>验证输入是否是一个正确的email地址？</li>
<li>验证日期是否输入正确？</li>
<li>验证表单输入内容是否为数字型？</li>
</ol>
<p>##JavaScript JSON##<br>JSON 是用于存储和传输数据的格式。</p>
<p>JSON 通常用于服务端向网页传递数据 。</p>
<p>###什么是 JSON?###</p>
<ol>
<li>JSON 英文全称 JavaScript Object Notation</li>
<li>JSON 是一种轻量级的数据交换格式。</li>
<li>JSON是独立的语言 </li>
<li>JSON 易于理解。</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/学习JavaScript/" data-id="cjp7yjwsx000rm07q7psxo1mk" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/javascript/">javascript</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RPC框架--远程过程调用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/RPC框架--远程过程调用/" class="article-date">
  <time datetime="2018-11-03T06:46:46.247Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/RPC框架--远程过程调用/">RPC框架--远程过程调用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p>
<p>比如说，一个方法可能是这样定义的：<br>Employee getEmployeeByName(String fullName)那么：<br><ul><li>首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li><li>第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。<br></li><li>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送ss给B服务器。</li><li>第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li><li>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用</li></ul></p>
<hr>
<p>为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用.</p>
<hr>
<p>##经典回答##<br>本地过程调用</p>
<p>RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:</p>
<pre><code>1 int Multiply(int l, int r) {
2    int y = l * r;
3    return y;
4 }
5 
6 int lvalue = 10;
7 int rvalue = 20;
8 int l_times_r = Multiply(lvalue, rvalue);

</code></pre><p>那么在第8行时，我们实际上执行了以下操作：</p>
<ol>
<li>将 lvalue 和 rvalue 的值压栈</li>
<li>进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r</li>
<li>执行第2行代码，计算 l * r ，并将结果存在 y</li>
<li>将 y 的值压栈，然后从Multiply返回</li>
<li>第8行，从栈中取出返回值 200 ，并赋值给 l_times_r<br>以上5步就是执行本地调用的过程。</li>
</ol>
<p>##<strong>远程过程调用带来的新问题</strong>##</p>
<p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p>
<ol>
<li><p><strong>Call ID映射。</strong>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</--></p>
</li>
<li><p><strong>序列化和反序列化。</strong>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p>
</li>
<li><p><strong>网络传输。</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</p>
</li>
</ol>
<p><strong>所以，要实现一个RPC框架，其实只需要把以上三点实现了就基本完成了。Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</strong></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/RPC框架--远程过程调用/" data-id="cjp7yjwpq000cm07q7e9dlhv4" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rpc-netty/">rpc netty</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Git的简单使用" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/Git的简单使用/" class="article-date">
  <time datetime="2018-11-03T06:46:14.450Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/Git的简单使用/">Git的简单使用</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>提交版本：<br>git add xxx<br>git commit -m “注释”</p>
<p>查看修改了什么东西：git diff xxx</p>
<p>查看历史记录：git log    精简版:git log –pretty=oneline<br>版本回退到上一个版本：git reset –hard HEAD^<br>版本回退到上100个版本：git reset –hard HEAD~100</p>
<p>恢复之前的版本：<br>1.获得之前的版本号git reflog<br>2.git reset –hard 版本号       来恢复<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014061202.jpg" alt="avatar"></p>
<p>修改了文件之后，还未git add的情况下，想回复之前的状态，可以输入:git checkout – 文件名 </p>
<p>文件修改后，还没有add放到暂存区，使用撤销修改就回到和版本库一模一样的状态。<br>另外一种是文件已经add放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</p>
<p>删除了文件之后，还未commit提交的情况下，想回复仓库之前的状态，可以输入 git checkout – 文件名<br>经常输入git status 来查看文件的状态</p>
<p>把本地的仓库上传到github上：<br>1.在github新建一个仓库<br>2.输入git remote add origin 地址</p>
<p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程<br>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了</p>
<p>从现在起，只要本地作了提交，就可以通过如下命令：<br>git push origin master</p>
<p>克隆远程库：<br>假如远程库有新的内容了，我想克隆到本地来，如何克隆呢<br>使用命令git clone克隆一个本地库<br>git clone -b 分支名 地址</p>
<p>##创建与分支合并##</p>
<p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p>
<p>git branch dev  //创建分支</p>
<p>git checkout dev    //切换分支</p>
<p>##总结创建与合并分支命令如下：##</p>
<p>   查看分支：git branch</p>
<p>   创建分支：git branch name</p>
<p>   切换分支：git checkout name</p>
<p>创建+切换分支：git checkout –b name</p>
<p>合并某分支到当前分支：git merge name</p>
<p>删除分支：git branch –d name</p>
<p>##如何解决冲突？##<br>在merge时，主干和分支不同的情况下，会产生冲突<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容</p>
<p>如果我想查看分支合并的情况的话，需要使用命令 git log</p>
<p>##分支策略##</p>
<p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<p>##BUG分支##<br>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/Git的简单使用/" data-id="cjp7yjwph0004m07q55tlj5ak" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git/">git</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Java学习笔记" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/Java学习笔记/" class="article-date">
  <time datetime="2018-11-03T06:44:49.021Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/Java学习笔记/">学习Java</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##关于，面向对象<br>类用于客观世界里某一类对象的共同特征，而对象则是类的具体存在，Java程序使用类的构造器来创建该类的对象</p>
<p>构造器用于对类实例进行初始化操作，构造器支持重载。</p>
<hr>
<p>##对于一个类定义而言，可以包含三种最常见的成员：构造器、成员变量和方法。</p>
<hr>
<p>static修饰的成员不能访问没有static修饰的成员</p>
<hr>
<p>成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。</p>
<hr>
<p>##命名<br>成员变量应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写。方法名的命名规则与成员变量的命名规则基本相同。</p>
<hr>
<p>static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。因为通常把static修饰的成员变量和方法也称为类变量、类方法。不使用static修饰的普通方法、成员变量则属于该类的单个实例，而不属于该类。通常把不使用static修饰的成员变量和方法也成为实例变量、实例方法。</p>
<hr>
<p>构造器是一个特殊的方法，<strong>构造器名必须和类名相同</strong>。<br>构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但是java会把这个所谓的构造器当成方法来处理—它就不是构造器。</p>
<p>##<strong>实际构造器是有返回值的，当使用new关键字来调用构造器时，构造器返回该类的实例。</strong>##<br>创建对象的根本途径是构造器</p>
<hr>
<pre class=" language-java"><code class="language-java">Person p<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//使用person类定义一个person类型的变量</span>
p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通过new关键字调用Person类的构造器，返回一个Person的实例，将Person</span>

或者
Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义p变量的同时为p变量赋值</span>
</code></pre>
<p>Person p = new Person();<br>这行代码创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量。<br>在这行代码实际产生了两个东西，一个是p变量，一个是Person对象。<br>程序中定义的Person类型的变量实际上是一个引用，它存放在栈内存中，指向实际的Person对象。而真正的Person对象则存放在堆（heap）内存中。</p>
<hr>
<p>栈内存里的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度看，引用变量与C语言里的指针很像，他们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针。<br>p引用变量本事只存储了一个地址值，并未包含任何实际数据。但它指向实际的Person对象，当访问p引用变量的成员变量和方法时，实际上是访问p所引用对象的成员变量和方法。</p>
<hr>
<p>如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。<br>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可。也就是把这些引用变量赋值为null。</p>
<hr>
<p>this关键字总是指向调用该方法的对象<br>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p>
<p>##<strong>没有使用static修饰的成员变量和方法都必须使用对象调用。</strong>##</p>
<p>this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的：它所代表的只能是当前类的实例，只有当这个方法被调用时，它所代表的对象才被确定下来：谁在调用这个方法，this就代表谁。</p>
<p>java允许对象的一个成员直接调用另一个成员，可以省略this前缀。</p>
<p>##<strong>static修饰的方法属于类，而不属于对象。</strong>##<br>Java编程时不要使用对象去调用static修饰的成员变量、方法，而是应该使用类去调用static修饰的成员变量、方法。</p>
<hr>
<p>##方法##<br>在结构化编程语言里，函数是一等公民，整个软件由一个个的函数组成；在面向对象编程语言里，类才是一等公民。整个系统由一个个的类组成。因此在Java语言里，方法不能独立村子，方法必须属于类或对象。</p>
<p>Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的，永远都不会改变。</p>
<p>同一个类的一个方法调用另外一个方法时，如果被调用方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者，表面上看起来某些方法可以被独立执行，但实际上还是使用this或者类作为调用者。</p>
<p>##方法重载##<br>Java程序中确定一个方法需要三个要素：<br>调用者，也就是方法的所属者，既可以是类，也可以是对象。<br>方法名，方法的标识<br>形参列表，当调用方法时，系统将会根据传入的实参列表匹配。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/Java学习笔记/" data-id="cjp7yjwpk0006m07qhdki258y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java/">java</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/11/03/hello-world/" class="article-date">
  <time datetime="2018-11-03T05:00:18.088Z" itemprop="datePublished">2018-11-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/11/03/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span>
</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server
</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate
</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy
</code></pre>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://lrqlrq.github.io/2018/11/03/hello-world/" data-id="cjp7yjwpj0005m07q0tvgyk0t" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; 上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Git/">Git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HTML/">HTML</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/ajx/">ajx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/algorithm/">algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/java/">java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascript/">javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/npm-前端/">npm 前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rpc-netty/">rpc netty</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vpn/">vpn</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/">vue</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Git/" style="font-size: 10px;">Git</a> <a href="/tags/HTML/" style="font-size: 10px;">HTML</a> <a href="/tags/ajx/" style="font-size: 10px;">ajx</a> <a href="/tags/algorithm/" style="font-size: 10px;">algorithm</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/java/" style="font-size: 10px;">java</a> <a href="/tags/javascript/" style="font-size: 10px;">javascript</a> <a href="/tags/npm-前端/" style="font-size: 10px;">npm 前端</a> <a href="/tags/rpc-netty/" style="font-size: 10px;">rpc netty</a> <a href="/tags/vpn/" style="font-size: 10px;">vpn</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">十二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">十一月 2018</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/09/npm是什么/">npm是干什么的</a>
          </li>
        
          <li>
            <a href="/2018/12/03/Git建立分支/">Git的远程建立分支</a>
          </li>
        
          <li>
            <a href="/2018/11/23/刷LeetCode笔记/">刷LeetCode的笔记</a>
          </li>
        
          <li>
            <a href="/2018/11/19/校园网无限流量总结/">校园网的无限流量</a>
          </li>
        
          <li>
            <a href="/2018/11/12/Ajax学习/">学习Ajax</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 刘瑞<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>