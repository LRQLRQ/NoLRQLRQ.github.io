---
title: 你不知道的JavaScript (中卷)2
tag: javascript
---

## 异步和性能

如何表达和控制持续一段时间的程序行为。是指程序的一部分**现在运行**，而另一部分在**将来运行**——现在和将来之间有间隙，在这段间隙中，程序没有活跃。
所有重要的程序(特别是 JavaScript 程序)都需要通过这样或那样的方法来管理这段时间间隙，这时可能是在等待用户输入、从数据库或文件系统中请求数据、通过网络发送数据并等待响应。在诸如此类的场景中，程序都需要管理这段时间间隙的状态。
**程序中现在运行的部分和将来运行的部分之间的关系，就是异步编程的核心**

### 事件循环

JavaScript 引擎并不是独立运行的，它运行在**宿主环境**中，对多数开发者来说通常就是 Web 浏览器。最近几年 JavaScript 已经超出了浏览器的范围，进入了其他环境。比如通过像 node.js 这样的工具进入服务器领域。但是这些所有环境都有一个共同的“点”，即他们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎。这种机制被称为**事件循环**。
换句话说，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”(JavaScript 代码执行)调度总是由包含它的环境进行。

`setTimeOut(..)`并没有把你的回调函数挂在事件循环队列中，他所做的是设定一个定时器。当定时器到时，环境会把你的回调函数放在事件循环中，这样在未来某个时刻的 tick 会摘下并执行这个回调。假如此时事件循环中已经有 100 个项目了怎么办？它就得排在其他项目之后。这也解释了为什么`setTimeOut(..)`定时器的精度可能不高。只能保证你的回调函数不会在指定的时间间隔之前运行，可能在那个时刻，也可能在那个时刻之后运行。

### 并行线程

术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。异步是**现在**和**将来**的时间间隙。而并行是关于能够同时发生的事情。

并行计算最常见的工具就是**进程**和**线程**。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。

并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。

```js
var a = 20;
function foo() {
  a = a + 1;
}
function bar() {
  a = a * 2;
}

ajax("http://some.url.1", foo);
ajax("http://some.ur2.1", bar);
```

**完整运行**
JavaScript 单线程运行特性，所以 foo()和 bar()中的代码具有原子性。也就是说，一旦 foo()开始运行，它的所有代码都会在 bar()中的任意代码运行之前完成。或者 bar()比 foo()运行的完整。这称为：**完整运行** 特性。

但是，同一段代码有两个可能输出意味着还是存在不确定性！！~但是，这种不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别(或者说，表达式运算顺序级别)。换句话说，这一确定性要高于多线程情况。
在 JavaScript 特性中，这种函数顺序的不确定性，就是通常所说的**竞态条件**，foo()和 bar()相互竞争，看谁先运行。具体的说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。

单线程事件循环是==并发==的一种形式。

**不交互**
两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。**如果进程间没有相互影响的话，不确定性是完全可以接受的**。

**交互**
并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。

**协作**
一种并发合作方式，称为“并发协作”。
如下情况:

```js
var res = [];

function response(data) {
  res = res.concat(
    //创建一个新的变换数组并把所有data值加倍
    data.map(function(val) {
      return val * 2;
    })
  );
}

ajax("http://some.url.1", response); //异步的ajax请求
```

当 ajax 请求返回结果之后，整个列表会映射到 res 中，如果记录只有几千条，就没什么关系，如果有 1000w 条记录的话，就可能需要运行很长时间了。这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 response 调用或 UI 刷新，甚至像滚动、输入、按钮点击这样的用户事件。

所以要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。如下：

```js
var res = [];

function response(data) {
    var chunk = data.splice( 0, 1000 );     //分块，将数据一次运算1000个

    res = res.concat(
        chunk.map( function(val) {
            return val * 2;
        });
    );

    if(data.length > 0) {       //如果还有数据，就接着调用
        setTimeout( function() {
            response( data );
        }, 0);
    }
}
ajax("http://some.url.1", response);    //异步的ajax请求
```

把数据集合放在最多包含 1000 条项目的块中。这样，就确保了“进程”运行时间很短，即使这意味着需要更多后续“进程”，因为事件循环的交替运行会提高站点/APP 的响应(性能)。这里使用 setTimeout(..,0),进行异步调度，意思就是“把这个函数插入到当前事件循环队列的结尾处”。

**任务**：
对于任务队列最好的理解方式：它是挂在事件循环队列的每个 tick 之后的一个队列。在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目。(一个任务)。提一下，promise 的异步特性是基于任务的。

**小结**
实际上，JavaScript 程序总是至少分为两块：第一块**现在**执行，下一块**将来**运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的。
一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。
任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。
并发是指两个或多个事件链随事件发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。
通常需要对这些并发执行的“进程”(和操作系统中的进程不同)进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小块，以便于其他“进程”插入进来。

**回调地狱**：
我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。

**Node 风格**：
有一种常见的回调模式叫做“error-first 风格”，有时也叫 Node 风格，因为几乎所有的 Node.js API 都会采用这种风格。其中回调的第一个参数保留用作错误对象(如果有的话)，如果成功的话，这个参数就会被清空/置假(后续的参数就是成功数据)。不过，如果产生了错误结果，那么第一个参数就会被置起/置真(通常就不会再传递其他结果)：

```js
function response(err, data) {
  if (err) {
    //出错？
    console.error(err);
  } else {
    //否则认为成功
    console.log(data);
  }
}
ajax("http://some.url.1", response);
```

下面展示一个工具：验证概念版本

```js
function timeoutify(fn, delay) {
  //这个setTimeout会隔一段delay的时间
  //再把这个function放到任务队列里面
  //到了时间，就抛出timeout错误
  var intv = setTimeout(function() {
    intv = null;
    fn(new Error("Timeout!"));
  }, delay);

  //return的这个函数算是闭包了
  //里面有intv这个东西，会提升到全局变量吧
  return function() {
    //返回的函数判断一下intv是否存在
    //如果超时了delay就会置为null
    //没超时的话就把定时器清除掉
    if (intv) {
      clearTimeout(intv);
      fn.apply(this, arguments);
    }
  };
}

//使用方式
function foo(err, data) {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
}

ajax("http://someurl.1", timeoutify(foo, 500));
```

ajax 异步调用请求需要耗费时间，如果响应很快，500ms 以内就能响应，那就调用了`timeoutify`返回的那个函数，在函数里面执行相应的逻辑：500ms 还没到， 定时器的任务还没执行，intv 还是真值，判断后清除这个定时器，然后让 foo 函数在 ajax 回调的环境中执行。猜测，ajax 必定至少返回两个参数，一个是 err 的位置，返回的必然是 null，另一个是 data 的位置，应该返回相应的请求数据。

**小结**
回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越熟，对于异步编程领域的发展，回调已经不够用了。

1. 大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的，非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致 bug。
2. 更重要的一点是，回调会受到控制翻转的影响！因为回调会把控制权交给第三方(通常是不受控制的第三方工具！)来调用代码中的`continuation`。这种控制转移导致一系列麻烦的信任问题，比如回调的次数是否会超出预期。

可以发明一些特定的逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码。并且缺少足够的保护，其中的损害要直到受到 bug 的影响才会被发现。

### promise

一但我需要的值准备好了，我就用我的承诺值换取这个值本身。

从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒接，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成(组合)，而不用关心时序或底层的结果。

一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值，可以根据需求多次查看。Promise 决议后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意地修改。特别是对于多方查看同一个 Promise 决议的情况，尤其如此。
Promise 是一种封装和组合未来值的易于复用的机制。

#### 具有 then 方法的鸭子类型

如何判断某个值是不是 promise？既然 promise 是通过 new promise(..)语法创建的你可能认为使用 `p instanceof Promise`来判断，但是这种方式不足以作为检查方法。最重要的原因是，Promise 值可能是从其他浏览器窗口(iframe 等)接收到的，这个浏览器窗口自己的 Promise 可能和当前窗口/frame 的不同，因此这样的检查无法识别 Promise 实例。此外，库和框架可能会选择实现自己的 Promise，而不是使用原生 ES6 Promise 实现。实际上，很可能使用的是早期根本没有 Promise 实现的浏览器中使用由库提供的 Promise。

根据一个值的形态(具有哪些属性)对这个值的类型作出一些假定。这种类型检查一般用术语**鸭子类型**来表示——(如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是鸭子)，于是检测大概就是这样：

```
if(
    p !== null &&
    (
        typeof p === "object" ||
        typeof p == "function"
    ) &&
    typeof p.then === "function"
) {
    //假定这就是一个thenable
}
else {
    //不是一个thenable
}
```

假如在原型中加入了 then 函数，那么生成的对象就会被认定为 thenable 的。

```
Object.prototype.then = function() {};
Array.prototype.then = function() {};
var v1 = { hello: "world" };
var v2 = [ "hello", "world"];
```

v1 和 v2 都会被认作是 thenable。如果有任何代码无意或恶意地给 Object.prototype、Array.prototype 或任何原生原型添加 then(..)，如果有 Promise 决议到这样的值，就会永远挂住。

#### Promise 的信任问题

把一个回调传入工具 foo(..)时，可能会出现如下问题：

- 调用回调过早
- 调用回调过晚(或不被调用)
- 调用回调次数过少或过多
- 未能传递所需的环境和参数
- 吞掉可能出现的错误和异常
  Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。

**调用过早**
根据定义，promise 就不必担心这种问题，因为即使是立即完成的 Promise,如下：

```
new Promise( function(resolve) {
    resolve(32);
})
```

也无法被同步观察到。也就是说，对一个 Promise 调用 then(...)的时候，即使这个 Promise 已经决议，提供给 then(..)的回调的总会被异步调用。

**调用过晚**
Promise 创建对象调用 resolve(..)或 reject(..)时，这个 promise 的 then(..)注册的观察回调就会被自动调度。一个 promise 决议后，这个 promise 上所有的通过 then(..)注册的回调都会在下一个异步时机点上依次被立即调用。这些回调中的任意一个都无法影响或延误对其他回调的调用。

**回调未调用**
没有任何东西(甚至是 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它决议了的话)。如果对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise 在决议时总是会调用其中的一个。

**调用次数过多或过少**
根据定义，回调被调用的正确次数应该是 1.“过少”的调用次数就是 0 次，和前面解释的唯美调用是一个道理。“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次，如果出于某种原因，Promise 创建的代码试图调用 resolve(..)或 reject(..)多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。由于 Promise 只能被决议一次，所以任何通过 then(..)注册的(每个)回调就只会被调用一次。

**未能传递参数/环境值**
Promise 最多只能有一个决议值(完成或拒绝)。
如果没有用任何值显式决议，那么这个值就是`undefined`,这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，他都会被传给所有注册的(且适当的完成或拒绝)回调。
此外，如果使用多个参数调用 resolve(..)或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。如果要传递多个值，就必须要把它们封装在单个值中传递，比如通过一个数组或对象。

**吞掉错误或异常**
如果拒绝一个 promise 并给出一个理由(也就是一个出错信息)，这个值就会被传给拒绝回调。如果在 promise 的创建过程中或在查看决议过程中的任意时间点，出现了一个 JavaScript 异常错误，比如一个 TypeError 或 ReferenceError，那这个异常就会被捕捉，并且会使这个 promise 被拒绝。
