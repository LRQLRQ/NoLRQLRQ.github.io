---
title: 前端笔记(三)
tags: 前端
---

### 由一个小问题分析JS的赋值问题
**问题**
```
var a = {n: 1};
var b = a;
a.x = a = {n:2};	
console.log(a.x);	//输出是undefined
console.log(b.x);	//输出是{n: 2}

```
**重点**
* JS引擎对**赋值表达式**的处理过程
* 赋值运算的**右结合性**

JS引擎怎么计算赋值表达式呢 比如A = B
1. 计算表达式A，得到一个引用refA
2. 计算表达式B，得到一个值valueB
3. 将valueB赋给refA指向的名称绑定
4. 返回valueB

右结合性
所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的
赋值表达式是右结合的,也就是说： 
A1 = A2 = A3 = A4
等价于
A1 = (A2 = (A3 = A4))

所以，表达式是从左往右找到引用，从右往左进行赋值
当JS引擎运行到a.x = a = {n:2};时，从左往右求引用，a.x的引用是在{n:1,x:undefined}的x,a的引用是对象{n:1}。从右往左求值，a指向{n:2},b.x指向{n:2},b的地址还是原先a对象处的地址


#### 闭包的变量并不是保存在栈内存中，而是保存在堆内存中
闭包的简单定义：函数A返回了一个函数B，并且函数B中引用了函数A的变量。函数B就称为闭包。

**typeof(null)是object，可以将引用变量赋值为null。typeof(undefined)为undefined。**

### 垃圾回收算法
1. 引用计数法：看一个对象是否有指向它的引用。  弊端：循环引用导致内存泄露。
2. 标记清除法：从根部(JS中为全局对象)出发，定时扫描内存中的对象，能从根部到达的对象，都是还需要使用的。无法从根部到达的对象，标记为不再使用，稍后进行回收。

* 经验法则：连续五次垃圾回收之后，内存占用一次比一次大，就存在内存泄露。  
