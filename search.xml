<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>开发小程序！</title>
      <link href="/2019/01/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91/"/>
      <url>/2019/01/13/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>JSON文件在小程序代码中扮演者静态配置的作用，在小程序运行之前就决定了小程序的一些表现。需要注意的是小程序是无法再运行过程中去动态更新JSON配置文件而发生对应变化的。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>学习HTTP协议</title>
      <link href="/2019/01/13/%E5%AD%A6%E4%B9%A0HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/01/13/%E5%AD%A6%E4%B9%A0HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>Web使用一种名为HTTP的协议作为规范，完成从客户端到服务器等一些列运作流程。而协议是指规则的约定。Web是建立在HTTP协议上通信的。</li><li>通常实用的网络（包括互联网）实在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。</li><li>TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层、数据链路层。各个层次的作用：<br>应用层：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务，比如FTP,DNS服务就是两类。<br>传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两种性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）<br>网络层：网络层用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。<br>链路层：用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，等等。硬件上的范畴均在链路层的作用范围之内。<br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部消息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种数据信息包装起来的做法成为封装。</li><li>TCP位于传输层，提供可靠的字节流服务。TCP协议为了更容易传输大数据，把数据进行分割。TCP协议能够确认数据最终是否送达到对方。</li><li>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端是服务器端。有时候，按照实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确的区分哪端是客户端，哪端是服务器端。</li><li>HTTP是不保存状态的协议，即无状态（stateless）的协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。<br><img src="https://github.com/LRQLRQ/picture/blob/master/stateless.png?raw=true" alt="avatar"><br>HTTP协议自身不具备保存之前发送过的请求或响应的功能。HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。</li><li>GET–获取资源。。。POST–传输实体主体。。。HEAD–获得报文首部，HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。。。OPTION–询问支持的方法<br><img src="https://github.com/LRQLRQ/picture/blob/master/option.png?raw=true" alt="avatar"><br>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止传输。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。<br><img src="https://github.com/LRQLRQ/picture/blob/master/trace.png?raw=true" alt="avatar"></li><li>使用方法下达命令。。向请求URI指定的资源发送请求报文时，采用成为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种作用。<br><img src="https://github.com/LRQLRQ/picture/blob/master/sumup.png?raw=true" alt="avatar"></li><li>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。当年的文本传输都是容量很小的文本传输。可是随着HTTP的普及，文档中包含大量图片。HTTP/1.1和1.0想出了持久连接的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。持久连接旨在建立1次TCP连接后进行多次请求和响应的交互。</li><li>管线化—持久连接使得多数请求以管线化方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。即，不用等待，直接发送下一个请求。</li><li>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</li><li>Cookoe技术通过在请求和响应报文中写入Cookie信息来控制客户端状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。服务器端发现客户端发送的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li><li>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。<br><img src="https://github.com/LRQLRQ/picture/blob/master/struct.png?raw=true" alt="avatar"><br>请求报文和响应报文的首部由三部分组成：<br><img src="https://github.com/LRQLRQ/picture/blob/master/struct2.png?raw=true" alt="avatar"><br><strong>请求行–包含用于请求的方法，请求URL和HTTP版本。</strong><br><strong>状态行–包含表明响应结果的状态码，原因短语和HTTP版本</strong><br><strong>首部字段–包含表示请求和响应的各种条件和属性的各类首部</strong><br>一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li><li>HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输调率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU资源。<strong>编码提升速率体现在两点：</strong>1. 压缩传输的内容编码。2. 分割发送的分块传输编码</li><li>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了状态，还是出现了错误。<br>状态码如 200 OK ，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下五种：<br><img src="https://github.com/LRQLRQ/picture/blob/master/status.png?raw=true" alt="avatar"></li><li>一台Web服务器可以搭建多个独立域名的Web网站，也可以作为通信路径上的中转服务器以提升传输效率。  –在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。由此观之，当请求发送到服务器时，已经是以IP地址形式访问了。 –在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完成指定主机名或域名的URI。</li><li>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。<br><strong>代理</strong>，是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。<br>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制。。。<br><img src="https://github.com/LRQLRQ/picture/blob/master/proxy.png?raw=true" alt="avatar"><br><strong>网关</strong>，是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。。网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务。<br><img src="https://github.com/LRQLRQ/picture/blob/master/gateway.png?raw=true" alt="avatar"><br><strong>隧道</strong>，是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序。。隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</li><li>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。缓存服务器是代理服务器的一种，并归类在缓存类型汇总。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。。缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>写的贪吃蛇</title>
      <link href="/2018/12/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2018/12/22/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起"><a href="#前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起" class="headerlink" title="前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起~"></a>前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起~</h2><p>首先介绍一下整体的思路，整个地图是一个canvas元素，这个canvas就相当于是画布。在画布上画蛇就是在canvas内的规定好的位置画矩形，边写边想，想到哪里写到哪里。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr><h4 id="canvas介绍"><a href="#canvas介绍" class="headerlink" title="canvas介绍"></a>canvas介绍</h4><p>首先get到页面中的canvas元素，<code>var canvas = documents.getElementById(&#39;canvas&#39;)</code>,此时canvas在js中就相当于是画布，然后再得到画笔，<code>var content = canvas.getContext(&#39;2d&#39;)</code>，之后再操作<code>content</code>的方法，就可以得到相应的图形。这里就用到了rect方法，画矩形。</p><hr><h4 id="蛇的思路"><a href="#蛇的思路" class="headerlink" title="蛇的思路"></a>蛇的思路</h4><p>在这个代码中，学到了真正的面向对象的写代码方式。<br>创建一个数组，数组中放rect()对象。蛇头的那个rect对象在数组的第一位。<br>这里介绍一下蛇移动的思路吧。</p><ol><li>蛇每移动一次，就使用splice方法，在数组中第二个位置中插入一个和头部一模一样的rect</li><li>然后判断是不是吃到了食物，如果吃到了食物，则生成新的食物，蛇头向当前的方向移动一个单位</li><li>如果没有吃到食物，就把蛇尾的元素pop掉，然后蛇头向当前方向移动一个单位。</li><li>以上是蛇的数组的操作方式，然后将蛇在画布中展示出来。使用canvas对象的draw方法，用一个for循环，将方块画出来。</li></ol><h4 id="学到的一些小东西"><a href="#学到的一些小东西" class="headerlink" title="学到的一些小东西"></a>学到的一些小东西</h4><hr><p>在js中，有一个东西叫做定时器，和单片机里面的定时器几乎是同样的东西。相当于定一个时间间隔，每过多少时间，就执行一次函数里面的代码。<br>比如：</p><pre><code>var timer = setInterval(function(){    context.clearRect(0, 0, canvas.width, canvas.height);  //清除已经画的蛇    food.draw();    //画出食物矩形    snake.move();    //蛇身进行移动，相当于在脑海中想象蛇应该在的位置    snake.draw();    //调用draw函数，把蛇的矩形画到画布上},100)</code></pre><hr><h2 id="在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。"><a href="#在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。" class="headerlink" title="在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。"></a>在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。</h2><p>判断蛇移动方向，需要设置按键监听事件。这个也是类似定时器一样，在后台自动就监听，感觉类似于外部中断。<br>具体代码如下：</p><pre><code>document.onkeydown = function(e){    var ev = e || window.event;   //防止事件冲突    switch(ev.keyCode){        //判断按键的键值是什么        case 37:    //按键为左            do()...;            break;        case 38:    //上            do()...;            break;        case 39:    //右            do()...;            break;        case 40:    //下            do()...;                break;        default:            break;    }}</code></pre><hr><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这次小项目只是一个单机版的贪吃蛇，锻炼了js的能力，学习到了js的很多基础知识，已经发布到github上了，还加了背景音乐，配了图，有机会可以去玩一玩。嘿嘿~~<br><a href="https://lrqwriting.top/snakeGame" target="_blank" rel="noopener">https://lrqwriting.top/snakeGame</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>npm是干什么的</title>
      <link href="/2018/12/09/npm%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2018/12/09/npm%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="npm-一个和pip一样的东西"><a href="#npm-一个和pip一样的东西" class="headerlink" title="npm,一个和pip一样的东西"></a>npm,一个和pip一样的东西</h2><p>一直在别人的博客里看到npm，今天查了一下，终于知道这是什么了,npm全名是Node Package Manager，是一个包管理器。因为前端js的文件每天都有无数个贡献者贡献代码，如果没有这么一个npm，包管理工具的话，那我们想要找到需要的代码，那得费一百牛二百虎之力。在社区中，大家把自己开发好的前端模块发给npm的作者，然后npm的作者把接收到的代码放到服务器上。当我们下好的npm之后，只需要输入命令，就可以方便快捷的下载好需要的代码，下载到node_modules目录中。</p><p>在这里抄一下npm的实现思路：</p><ol><li>买一个服务器当做代码仓库，把所有需要共享的代码放到服务器里。</li><li>发邮件给jQuery，Bootstrap作者，使用npm publish把代码提交到registry上，分别取名jquery、bootstrap。</li><li>社区里的其他人如果想使用这些代码，就吧jquery、bootstrap写到package.json里，然后运行npm install，npm就会帮他们自动下载</li><li>下载完之后的代码就在node_modules里面，可以使用了。</li></ol><h3 id="这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。"><a href="#这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。" class="headerlink" title="这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。"></a>这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。</h3><p>都是从这里学习的↓↓↓↓↓<br>原文地址：<br><a href="https://blog.csdn.net/qq_37696120/article/details/80507178" target="_blank" rel="noopener">https://blog.csdn.net/qq_37696120/article/details/80507178</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git的远程建立分支</title>
      <link href="/2018/12/03/Git%E5%BB%BA%E7%AB%8B%E5%88%86%E6%94%AF/"/>
      <url>/2018/12/03/Git%E5%BB%BA%E7%AB%8B%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<p>2018-12-03<br>项目需要给邮政那边一个版本，所以需要给他们进行定制。因此就需要在现在的git仓库上新建一个分支，在此列出需要的几个命令。</p><p><code>git branch</code> :列出本地的分支，当前分支会标有<code>*</code>号<br><code>git branch -r</code> :列出远程的分支<br><code>git branch -a</code> :列出所有本地和远程的分支</p><h2 id="首先新建一个本地分支："><a href="#首先新建一个本地分支：" class="headerlink" title="首先新建一个本地分支："></a>首先新建一个本地分支：</h2><p><code>git checkout -b lrqTest</code><br>上面这行代码代表新建一个分支并切换到分支内，等同于下<br><code>git branch lrqTest</code><br><code>git checkout lrqTest</code></p><h2 id="第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起"><a href="#第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起" class="headerlink" title="第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起"></a>第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起</h2><p><code>git push origin lrqTest:remoteTest</code><br>其中<code>lrqTest</code>是本地的分支名,<code>remoteTest</code>是远程服务器的分支名，可以随便起名</p><p>到此，就建立了远程分支。</p><hr><h2 id="如果想要删除远程分支"><a href="#如果想要删除远程分支" class="headerlink" title="如果想要删除远程分支"></a>如果想要删除远程分支</h2><p><code>git push origin  :lrqTest</code><br>意思是将一个空的分支push到远程名为lrqTest的分支，就是相当于删除.<br>也可以使用此命令：<br><code>git pust origin --delete lrqTest</code></p><hr><h2 id="如果某个用户想要拉取远程的分支"><a href="#如果某个用户想要拉取远程的分支" class="headerlink" title="如果某个用户想要拉取远程的分支"></a>如果某个用户想要拉取远程的分支</h2><ol><li>直接使用<code>git checkout -b 本地分支名 origin/远程分支名</code><br>这种方式会直接在本地新建分支，并且切换到该分支。<br>并且，这种方式会将新建立的本地分支和远程分支建立<strong>映射关系</strong></li><li>使用<code>git fetch origin 远程分支名:本地分支名</code><br>这种方式建立的分支不会切换到新建的分支，需要自己手动进行checkout<br>而且，这种方式建立的本地分支<strong>不会和远程分支建立映射关系</strong></li></ol><hr><p>##建立本地分支和远程分支之间的映射关系<br>建立了映射关系之后，就不需要在每次<code>git pull</code> 和 <code>git push</code>的时候指定从远程的哪个分支拉取合并和推送到哪个分支。</p><p>使用<code>git branch -vv</code>查看本地分支和远程分支的映射关系<br>如果没有映射关系，就需要自己<strong>手动建立</strong>：<br><code>git branch -u origin/分支名</code><br>或者<br><code>git branch --set-upstream-to origin/分支名</code><br>origin为git地址的标志，可以建立当前分支与远程分支的映射关系</p><p><strong>撤销本地分支与远程分支的映射关系</strong><br><code>git branch -unset-upstream</code> 就撤销掉了与远程分支的映射关系</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷LeetCode的笔记</title>
      <link href="/2018/11/23/%E5%88%B7LeetCode%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/23/%E5%88%B7LeetCode%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>刷LeetCode心得体会</strong></p><p>11.23日，第一次刷LeetCode，有一个题我写了28行，看了讨论区别人只写了4行，看了他写的代码，是用了javascript的一些方法，我不知道这些方法，还是像C语言一样实现了一下。<br>总结一下javascript的一些方法</p><p>有个题目是返回输入的数字的倒序<br>代码如下</p><pre><code>var reverse = function(x){    result = parseInt(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    if(result &gt; Math.pow(2,31)-1 || -result &lt; Math.pow(-2,31)-1) return 0;    return x &gt; 0 ? result : -result;}</code></pre><p><code>x.toString</code> 是把输入的数字转化为字符串<br><code>x.split(&#39;&#39;)</code>是把生成的字符串根据’’切割，转化为数组<br><code>x.reverse()</code> 是把数组进行倒序<br><code>x.join(&#39;&#39;)</code> 是将数组组合成字符串</p><hr><p>11.27 Roman to Integer<br>        今天做了一道将罗马数字转化为数字的题，罗马数字中I为1，V为5，X为10，L为50，C为100，D为500，M为1000.但是表示4的时候不是表示IIII，而是IV，I在V左边表示5-1=4，像这样的都有 IV=4  IX=9  XL=40  XC=90  CD=400 CM=900.<br>然后根据罗马数字的输入来得到整数的输出，我的代码是这样：</p><pre><code>/** * @param {string} s * @return {number} */var romanToInt = function(s) {    var num_IV = s.split(&#39;IV&#39;).length-1;    //-1    var num_IX = s.split(&#39;IX&#39;).length-1;    //-1        var num_XL = s.split(&#39;XL&#39;).length-1;    //-10    var num_XC = s.split(&#39;XC&#39;).length-1;    //-10    var num_CD = s.split(&#39;CD&#39;).length-1;    //-100    var num_CM = s.split(&#39;CM&#39;).length-1;    //-100    var num_I = s.split(&#39;I&#39;).length-1;    var num_V = s.split(&#39;V&#39;).length-1;    var num_X = s.split(&#39;X&#39;).length-1;    var num_L = s.split(&#39;L&#39;).length-1;    var num_C = s.split(&#39;C&#39;).length-1;    var num_D = s.split(&#39;D&#39;).length-1;    var num_M = s.split(&#39;M&#39;).length-1;    var result = 0;    result = num_I + num_V*5 + num_X*10 + num_L*50 + num_C*100 + num_D*500 + num_M*1000     - num_IV*2 - num_IX*2 - num_XL*20 - num_XC*20 - num_CD*200 - num_CM*200;    return result;};</code></pre><p>这样写代码很冗杂，才超过了百分之30多的人。。。也算是初步会用了js的一些方法吧。<br>如果想求某个字符串temp，在字符串s中出现的次数，可以用s.split(‘temp’).length-1，来获得。s.split(‘temp’)后得到一个数组，再求出这个数组的长度，再-1，因为split操作后，数组中会出现’’元素。</p><p>看了看discussion，发现另一种用slice实现的方法，虽然也有点暴力，没有为之一振的感觉，但是初学者，能吸收一点是一点，放在这里刚好可以对比着学习split和slice这两个方法了</p><pre><code>var romanToInt = function(s) {    var roman = {        //定义存储的数组        &#39;I&#39;: 1,        &#39;V&#39;: 5,        &#39;X&#39;: 10,        &#39;L&#39;: 50,        &#39;C&#39;: 100,        &#39;D&#39;: 500,        &#39;M&#39;: 1000,        &#39;IV&#39;: 4,        &#39;IX&#39;: 9,        &#39;XL&#39;: 40,        &#39;XC&#39;: 90,        &#39;CD&#39;: 400,        &#39;CM&#39;: 900,    };    var ret = 0;    for (var i = 0; i &lt; s.length; ) {        var j = i + 1;    //每次j只比i大1，是当前元素的下一个元素        if (j === s.length) {    //如果j为字符串的长度，就说明到了最后，进行最后一次运算            ret += roman[s.slice(i, j)];            return ret;        }        if (s.slice(i, j + 1) in roman) {        //如果连着2个字符出现在之前存储的数组中，即出现了IV、IX这些            ret += roman[s.slice(i, j + 1)];            i = j + 1;        } else {            ret += roman[s.slice(i, j)];            i = j;        }    }    return ret;};</code></pre><p><code>if (s.slice(i, j + 1) in roman)</code> 我觉得这个知识点有点东西，得记一下。<br>依据键来取声明式对象中的值</p><p>此外，slice方法，是输入两个index，返回的是该字符串中，两个index之间的字符串。<br>而split方法，是把字符串进行切分，分割成若干个数组。</p><hr><p>11.28 求一个数组中，前面相同的部分<br>如输入 strs = [‘flower’,’flow’,’fly’]  就输出’fl’</p><p>做这道题我自己的方法是<br>1.最多循环数组中第一个元素的长度<br>2.以第一个元素为基准，以此和数组中别的元素的相同位置的字符进行比较<br>3.如果相同，则将该字符添加到ret后面</p><p>做这道题，掌握到的<strong>新知识点</strong>：<br>1.对于一些乱七八糟的输入，比如空数组[] ,比如[‘’]，可以这样来判断输入值是否合法<br><code>if(!strs || strs.length)</code>,如果是undefined的话，加一个取反，逻辑就为true。如果是长度为0，也会返回true。<br>2.对于输入的strs，可以用这种方式来取值<code>strs[i][j]</code><br>即对于string类型的数据，可以直接通过[]的方式取值<br>3.string类型的一个新方法，截取字符串 <code>string.substring(i,j)</code>，则返回字符串string中的i到j坐标中的字符串</p><hr><p>11.29 判定一个括号是不是成对出现，符合规则<code>{[()]}</code>,比如说是这样</p><p>我的思路：<br>1.重复将输入的字符串根据<code>() [] {}</code> 进行split拆分成数组，再合并起来，一直到最后结果变为 <code>&#39;&#39;</code>,这就说明成功了。具体代码如下：</p><pre><code>var temp = s;while(1){    temp = s.split(&quot;()&quot;).join(&quot;&quot;).split(&quot;[]&quot;).join(&quot;&quot;).split(&quot;{}&quot;).join(&quot;&quot;);    if(temp==&quot;&quot;)        return true;    if(temp==s){        return false;    }    s = temp;}</code></pre><p>但是这样运行效率太差劲了，只超过了10%的人，菜的要死。<br>然后在dission看到了超过100%的人。。学习一下<br>思路：<br>1.将括号的左边，和括号的右边存在两个Set对象中，将成对的括号制成map表，以左边括号为key，以右边括号为value<br>2.用一个栈，随时储存和进行操作<br>3.对传入的字符串进行遍历，如果是一个左括号的类型的值，则push到栈顶。如果是一个右括号类型的值，就pop弹出栈顶的值，此时栈顶是左括号的最后一个的值，弹出之后就变成了前一个。拿弹出的值对应的map和此时的右括号的某个值进行比较，看相不相等。相等就继续判断下一个，不等就直接输出false</p><p>优点：<br>1.遍历的过程一次只判断一个字母，速度快一点。<br>2.提前制好了表，即两个set对象和一个map，查找更快。<br>3.用到了栈，巧妙的用后进先出的特点，解决了括号要按同种类型嵌套的问题<br>代码如下：</p><pre><code>var isValid = function(s) {    let stack = [];    let openSet = new Set([&#39;(&#39;, &#39;{&#39;, &#39;[&#39;]);    let closeSet = new Set([&#39;}&#39;, &#39;]&#39;, &#39;)&#39;]);    let bracketMap = new Map([[&#39;(&#39;, &#39;)&#39;], [&#39;[&#39;, &#39;]&#39;], [&#39;{&#39;, &#39;}&#39;]]);     for (let c of s) {        if (openSet.has(c))  {            stack.push(c);           }        else if (closeSet.has(c)) {            let temp = stack.pop();            if (temp === undefined || c !== bracketMap.get(temp)) return false;        }     }    return stack.length === 0;};</code></pre><p>新学的知识点：<br>1.Set对象，和map类似，是一组key的集合，但是不存储value，因为key不能重复，所以在Set中没有重复的元素。<br>2.map,是一组键值对的结构，具有极快的查找速度，通过传入的数组的数组建立。通过set(key,value)方法添加元素，通过get(key)来取值。<br>3.栈的push和pop，栈是一种后进先出的数据结构，栈中项的推入和弹出都发生在栈顶。javascript中为数组提供了push()和pop()方法，push()可以接受任意数量的参数，逐个添加到数组的末尾，并返回修改后数组的长度。pop()方法则从数组的末尾弹出最后一项，减少数组的length值，返回弹出的项</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>校园网的无限流量</title>
      <link href="/2018/11/19/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2018/11/19/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="无限流量归纳"><a href="#无限流量归纳" class="headerlink" title="无限流量归纳"></a>无限流量归纳</h1><p>最近学校的无限流量套餐试验结束了，原先的1分钱100M带宽无线流量套餐，现在涨到50块了，前天晚上听到室友找到了一种校园网无线流量的方法，昨天就试了试，虽然还没成功，但是稍微了解了一下原理，还有一些引申。勒石以记，待有缘之时再返以续之。</p><hr><h2 id="1-UDP的53、67、68端口转发，绕过校园网认证，来免流量。"><a href="#1-UDP的53、67、68端口转发，绕过校园网认证，来免流量。" class="headerlink" title="1. UDP的53、67、68端口转发，绕过校园网认证，来免流量。"></a>1. UDP的53、67、68端口转发，绕过校园网认证，来免流量。</h2><p>准备材料：一台公网的服务器<br>步骤：</p><ol><li>在服务器上搭建SoftEther VPN Server</li><li>在windows上下载SE-VPN Server Manager，连接到搭建好的服务器。</li><li>通过Mananger这个软件来添加用户，并启用SecureNAT功能。</li><li>改变OpenVPN监听的端口，默认是1193，改为53或67或68（不是都可以用，我测试53和67可用）。</li><li>在Manager软件里生成OpenVpn Client的配置文件。</li><li>在windows下载OpenVpn，把第5步生成的配置文件放到安装目录的config里面，并使用第3步添加的用户登录，来连接到服务器上。</li></ol><hr><p>原理介绍：<br>在连接到某个需要Web认证的热点之前，我们已经有了一个内网IP，此时，如果我们访问某个HTTP网站，网关会对这个HTTP响应报文劫持并篡改，302重定向到让我们认证的页面（就是登录让你输入账号密码的网页）。</p><p>网关（交换机）都默认放行DHCP和DNS的报文，也就是UDP53和UDP67，所以把数据通过53端口传到服务器上，服务器将返回的网页内容再通过53端口传给客户端，实际上都在费流量，只是没有计费。</p><p>参考的博客：</p><p>UDP 53/67/68 端口转发 绕过校园网认证、免流<br><code>https://blog.csdn.net/sinat_38245860/article/details/78669584</code></p><p>UDP 53免费上网、DNS隧道经验谈<code>https://blog.csdn.net/qq_42433224/article/details/82632711</code></p><p>交换机 配置WEB认证的功能原理是什么</p><p><code>http://www.ruijie.com.cn/fw/wt/36503/</code></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Ajax</title>
      <link href="/2018/11/12/Ajax%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/11/12/Ajax%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>####Ajax应用的工作流程如下：</p><ol><li>JavaScript脚本使用 XMLHttpRequest 对象向服务器发送请求。发送请求时，既可以发送GET请求，也可以发送POST请求。</li><li>JavaScript脚本使用 XMLHTTPRequest 对象解析服务器响应数据</li><li>JavaScript 脚本通过 DOM 动态更新 HTML 页面。也可以为服务器响应数据增加 CSS 样式表，在当前网页的某个部分加以显示。</li></ol><p>####JavaScript 脚本是Ajax 技术中另一个重要的部分。JavaScript 主要完成如下部分；</p><ol><li>创建 XMLHTTPRequest 对象</li><li>通过XMLHTTPRequest 向服务器发送请求</li><li>创建回调函数，监视服务器响应状态，在服务器响应完成之后，回调函数启动</li><li>回调函数通过 DOM 更新HTML页面</li></ol><p>JSON是一种跨平台，跨语言的轻量级数据交换格式，以JSON作为数据交换格式不仅简单，而且网络传输的数据量更小，因此， JSON 取代了 Ajax 技术中 XML 的地位。</p><hr><p>Ajax在于给用户连续的体验<br>对于Ajax应用，浏览器不仅可以包含简单逻辑，甚至可以保存用户会话转状态。<br><strong>Ajax技术有以下优势：</strong></p><ol><li>减轻了客户端的内存消耗。Ajax的根本理念是“按需取数据”</li><li>无刷新更新页面。通过异步发送请求，避免了频繁刷新页面，从而减少了用户的等待时间，给于用户一种连续的体验</li><li>Ajax技术可以将传统的服务器工作转嫁到客户端，从而减轻服务器和带宽的负担，节约空间和带宽租用成本。</li></ol><hr><p>Ajax采用异步的方式发送请求，页面的更新由JavaScript操作DOM完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ajx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端杂笔记</title>
      <link href="/2018/11/08/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/08/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.<br>&lt;meta&gt;元素，提供有关页面的元信息<br>&lt;meta&gt;标签永远位于head元素内部<br>元数据总是以名称/值的形式被成对传递的<br>如：&lt;meta charset=’utf-8’ &gt; 告知浏览器此页面是属于什么字符编码格式。<br>&lt; meta http-equiv=”charset” content=”iso-8859-1” &gt;  使用带有 http-equiv属性的&lt;meta&gt;标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。</p><hr><h4 id="CSS、JS的放置位置与前端性能的关系？"><a href="#CSS、JS的放置位置与前端性能的关系？" class="headerlink" title="CSS、JS的放置位置与前端性能的关系？"></a>CSS、JS的放置位置与前端性能的关系？</h4><h4 id="前备知识：浏览器的解析方式"><a href="#前备知识：浏览器的解析方式" class="headerlink" title="前备知识：浏览器的解析方式"></a>前备知识：浏览器的解析方式</h4><p>浏览器解析html页面首先浏览器先下载html，然后再内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析CSS和Images，当文档下载遇到JS时，JS独立下载。</p><p>Q:为什么将引用的外部JS放在下面，外部CSS放在上面？（浏览器会有自己的解析顺序）<br>A1:<br>JS是阻塞加载，会影响页面加载的速度，如果JS文件比较大，算法也比较复杂的话，影响更大。<br>CSS放在前端是页面渲染时，首先是根据DOM结构生成一个DOM树，然后加上CSS生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑，直到CSS加载完成。<br>A2:<br>一般来说CSS放在头部，JS放在底部来确保用户至少能早一点看到界面，让网站看起来至少反应快一点，不过如果CSS稍微有点多了，会让屏幕白屏时间更长，所以并不是说把CSS都放顶部是一个完美的方法，而且有些JS必须在页面加载前执行掉。<br>所以应该是，把必须的js和css放在顶部，把不那么重要的css和js放在底部。</p><hr><p><strong>如何在图片上设置多个跳转</strong><br>今天完成了项目首页的搭建，在一张图片上设置多个跳转。查了很久资料，发现是用HTML中的map和area标签定位使用。主要用到了 <strong>shape</strong> <strong>coords</strong> <strong>href</strong> 这三个标签，shape来表明在图片上的什么形状，如矩形、圆形、多边形。coords来标出图片上的位置，以坐标的形式表示出来。href则表示跳转的链接。<br>图片和热点区域元素关联是使用图片的usemap属性，其值对应&lt;map&gt;的id或者name值。</p><pre class=" language-html"><code class="language-html">&lt;map name="Map" id = "CribMap">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>32,205,193,247<span class="token punctuation">"</span></span>  <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./architecture.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,207,475,247<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--被测系统管理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,294,475,336<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>newfunpoint<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--新建功能点--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,378,475,421<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>architecture<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--配置元素库--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,463,475,505<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>architecture<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--生成基础脚本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>570,204,686,246<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./testplan-execute.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--批量执行--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>561,294,696,336<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./scene.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--场景管理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>545,379,713,420<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./datatable.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--测试资源配置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>545,460,713,508<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./caseManagement.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--新增用例--></span>                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>803,204,914,247<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./execution.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!--执行记录查询--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>786,379,932,421<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./testProject.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!--新增测试项目--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span></code></pre><p>####PS</p><pre><code>#main-content {    display: flex;    flex-flow: column;    min-height: 100vh;}#main-content .wrapper {    flex: 1;}#main-content .fixedwh {    width: 1100px;    height: 650px;}</code></pre><p>在途中遇到了一点CSS的问题，最后一段代码是我加上的，强制图片的像素为宽1100像素，高650像素，实际上图片有自己的强制缩放比，图片的最后比例是1100x700多。</p><pre><code>&lt;section class=&quot;wrapper fixedwh&quot; &gt;</code></pre><p>通过在代码里面给框柱图片上的那部分加上这个css的类，来限制图片的大小。因为mian-content.wrapper这个属性是一个模板，在每个页面都会被使用，所以这样加一个多的属性，来与一下。</p><p>可以通过PhotoShop来，先将图片的大小设置为css中限定的大小，然后找到croods的坐标。</p><p><strong>vue中的Vac对象和sessionstorge可以在页面之间传递数据</strong></p><hr><p><strong>关于作用域的问题</strong><br>在Vue中，若声明在data里面的数据temp，如果想要在Vue的method里面对temp进行操作，就必须在方法内部写</p><pre><code>var _this = this;_this.temp = 123;</code></pre><p>这样才能调用data里面的数据</p><p>此外，如果想要在Vue体外写Javascript的function，在函数内部想引用的Vue内部的数据的话，先看声明的Vue对象名字是什么，然后进行引用，如</p><pre><code>var app=new Vue({el:&#39;#something&#39;data:{temp:‘’,}})app.temp=1</code></pre><hr><p><strong>在页面之间传递值-sessionStorage</strong><br>sessionStorage属性允许在浏览器中存储key/value对的数据，在页面进行跳转的时候可以将某些数据进行传递。</p><pre><code>sessionStorage.setItem(&#39;name&#39;,&#39;liuruiqing&#39;);    //在a页面存储变量name的值为lrq//当跳转到另一页面时，可以对sessionStorage进行操作，读出name的值var temp = sessionStorage.getItem(&#39;name&#39;);</code></pre><p>需要注意的地方是，如果要判断一个变量是否存在应这样判断:</p><pre><code>var temp = session.getItem(name);if (temp==null){    ...} else{    ...}</code></pre><p>应该判断该值是不是为null，而不是判断</p><pre><code>if(temp==&#39;&#39;)</code></pre><p>因为如果数值并没有传递的话，该值是undefined，是null，而不是为’’，具体的情况可以在浏览器进行调试。</p><hr><p><strong>button、input、a标签的区别</strong><br>button、input和a标签都可以加上一定的样式后成为外观上没有很大差别的按钮，但是这三个标签应用的场景不尽相同。</p><ol><li>button,通过onclick来绑定javascript事件。</li><li>&amp;It input type=”submit” value=”提交” /&amp;gt  将表单内用户设置或者选择的所有数据一并<strong>提交到后台</strong>。</li><li>&amp;It a class=”btn” href=’#’ &amp;gt 提交 &amp;It/a&amp;gt<br>通过添加链接访问到页面中的某一个位置或者另一个页面，不向后台提供数据</li></ol><hr><p>对于输入框，可以在input内加一个placeholder，来显示默认提示信息。</p><hr><p>今天遇到一个bug，在写一个日历组件的时候，将代码从demo中扒过来之后，发现不能用。以后要先检查一下，看下console报的什么错误。然后看source里面的文件，都用了哪里的地方，然后一起扒过来。<br>在抄过来的时候，报了错误，$(…).datetimepicker is not a function，是因为我在html中先引用了这个函数，后引用了库函数，顺序反了，所以没有找到这个函数。顺序改好了就好了。</p><hr><p>12.1日<br>昨天新增了一个日历的插件，在查询的时候，后端给的接口需要输入时间戳的格式的时间。现在的时间格式是2018-12-01,但是时间戳的格式是  1543593600000  ，首先解释一下时间戳的意思，<strong>是从1970年1月1日开始，到此时此刻所经过的秒数。</strong>在这里帖上把时间转换为时间戳的代码：</p><pre><code>var startTime = &#39;2018-12-1 21:57:00:000&#39;var date = new Date(startTime.replace(/-/g,&#39;/&#39;));var time1 = date.getTime();    //这种会精确到毫秒var time2 = date.valueOf();    //同上，会精确到毫秒var Date.parse(date);        //只会精确到秒</code></pre><p>第二行使用了正则表达式，两个<code>/</code>之间的是表达式，<code>g</code>是所有的意思，这行代码的意思是将所有的<code>-</code>都变为<code>&#39;/&#39;</code></p><hr><p><strong>vue中的bind和model的比较</strong></p><ol><li>select控件使用model时，不应该将model写到 option里面，应该写到select中，绑定selece的value值</li><li>model是双向绑定。将html比作前面展示出来的东西，将js比作后面处理的动作。使用model之后，比如对于input控件，当用户进行输入，改变值之后，后面的js中的绑定的变量也会改变。同理js进行改变之后，前面的html页面也会进行修改。</li><li>bind是单向绑定。前改后不改，后改了前改。js中变量的改变会引起HTML中值的变化，显示就改变。而前面发生改变的话，js的变量是不会发生改变的。</li></ol><hr><p>2018-12-10</p><h4 id="廖雪峰网站中学到的js基础知识"><a href="#廖雪峰网站中学到的js基础知识" class="headerlink" title="廖雪峰网站中学到的js基础知识"></a>廖雪峰网站中学到的js基础知识</h4><p><strong>对于相等比较符，<code>==</code>和<code>===</code></strong>，JavaScript在设计时，有两种运算符：<br>第一种是<code>==</code>,它会自动转换数据类型再比较，很多时候会得出很诡异的结果。。<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再进行比较。<br>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>进行比较。</p><p><strong>NaN这个特殊的number与其他所有的值都不相等，包括他自己</strong><br><code>NaN===NaN  //false</code><br>唯一能判断NaN的方式是使用<code>isNaN()</code>函数：<br>isNaN(NaN);  //true</p><p><strong>JavaScript是一门动态语言</strong>，变量本身类型不固定的语言称为动态语言，与之对应的是静态语言。静态语言在定义变量的时候就必须指定变量类型，如果赋值的时候类型不匹配，就会报错。<br>比如在C语言中:</p><pre><code>int a = 123; //a是整形变量，类型用int声明a = &#39;LRQ&#39;;   //错误，不能把字符串变量赋值给整形变量</code></pre><p><strong>字符串是不可变的，如果对某个字符串的索引赋值，不会有错误，但也没有任何效果</strong><br>要获取字符串某个指定位置的字符，可以使用类似Array的下标操作，索引号从0开始：</p><pre><code>var str = &#39;lrqiswriting&#39;;a = str[0];   //a = &#39;l&#39;b = str[3];   //b = &#39;i&#39;str[2] = &#39;z&#39;; //不会出错，但也不会有任何效果</code></pre><p><strong>如果要在Array数组的头部添加若干元素，可以使用unshift()方法，shift()方法则把Array数组的第一个元素删掉</strong></p><pre><code>var str=[1,2];str.unshift(&#39;A&#39;,&#39;B&#39;);   //此时str为[&#39;A&#39;,&#39;B&#39;,1,2]arr.shift();        //去掉头部元素，则str为[&#39;B&#39;,1,2]</code></pre><p>空数组连续shift()不会报错，而是会返回undefined</p><p><strong>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array</strong></p><pre><code>var arr = [1,2,3];var added = arr.cncat([4,5,6]);//此时added为[1,2,3,4,5,6]</code></pre><p>concat()方法并没有修改当前的Array(),而是返回了一个新的Array</p><p><strong>for…in…是for循环的一个变体，他可以把一个对象的所有属性依次循环出来</strong></p><pre><code>var object = {    name: &#39;lrq&#39;,    age: 22,    city: &#39;BeiJing&#39;}for(key in object){    console.log(key);//&#39;name&#39;,&#39;age&#39;,&#39;city&#39;    console.log(object[key]);  //使用索引取出值}</code></pre><hr><h3 id="2018-12-12"><a href="#2018-12-12" class="headerlink" title="2018-12-12"></a>2018-12-12</h3><h4 id="arguments关键字"><a href="#arguments关键字" class="headerlink" title="arguments关键字"></a>arguments关键字</h4><p>JavaScript有一个免费赠送的关键字，<strong>arguments</strong>,在函数体内使用这个关键字可以得到当前函数的调用者传入的所有参数。<code>arguments</code>类似于一个<code>Array</code>而又不是一个<code>Array</code>.<br>实际上<strong>arguments</strong>这个参数一般用于判断传入参数的个数。</p><pre><code>function foo(x){    console.log(&#39;x = &#39; + x);    for(var i=0;i&lt;arguments.length;i++){        console.log(&#39;arg&#39; + i + &#39; = &#39; + arguments[i]);    }}`foo(10,20,30,40,50);`输入以上函数可以获得以下结果**x = 10arg0 = 10arg1 = 20arg2 = 30arg3 = 40arg4 = 50**</code></pre><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6引入了rest参数</p><pre><code>function foo(a,b,...rest){    console.log(&#39;a = &#39; + a);    console.log(&#39;b = &#39; + b);    console.log(rest);}</code></pre><p>输入函数<code>foo(1,2,3,4,5,6,7,8,9);</code><br>输出如下:<br><strong>a = 1<br>b = 2<br>[3,4,5,6,7,8,9]</strong></p><p><strong>注意：rest参数只能写在最后面，前面用<code>...</code>来进行标识，传入的参数先绑定a和b，其余的再放入rest数组内。如果传入的参数连正常的都没有填满，rest参数会接收一个空数组。而不是<code>undefined</code></strong></p><p><strong>JavaScript有一个在行末自动加分号的机制。</strong></p><p><strong>变量提升</strong><br>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。</p><pre><code>&#39;use strict&#39;function foo(){    var x = &#39;hello&#39;+y;    console.log(x);    var y = &#39;Lrq&#39;;}foo();</code></pre><p>当运行以上函数时，返回的结果是helloundefined.如果没有定义y变量的话，则会显示referenceError.<br>实际上JavaScript引擎看到的代码如下：</p><pre><code>function foo(){    var y;    var x = &#39;hello&#39;+y;    console.log(x);    var y = &#39;Lrq&#39;;}</code></pre><p>在给y赋值之前已经声明，但是还没有值。所以可以运行，只不过结果是undefined.但是如果连定义也没有的话，运行都会出错，会提示ReferenceError。</p><hr><h4 id="函数的一种写法"><a href="#函数的一种写法" class="headerlink" title="函数的一种写法"></a>函数的一种写法</h4><p>发现师兄写的一个函数的写法，感觉很高级使用。带参数可以使用，不带参数也可以使用。代码如下：</p><pre><code>var page = {    totalCount = 1;    currentPage = 1;    totalPage = 1;    pageSize = 20;}getRecord(page){    var pageSize = page?page.pageSize:this.page.pageSize,    currentPage = page?page.currentPage:this.page.currentPage;}</code></pre><p>这么写的好处，可以直接调用<code>getRecord()</code>来使用函数，这样的话就是传入的page参数是null，然后在函数内部使用表达式判断进行赋初值。<br><code>page?page.pageSize:this.page.pageSize</code>这句话的意思是，判断page是不是存在，如果存在的话就给<code>pageSize</code>赋值为传入对象的储值，如果不存在的话，就赋值为全局变量中的初值。这么写省了很多逻辑。</p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习VUE</title>
      <link href="/2018/11/03/%E5%AD%A6%E4%B9%A0VUE/"/>
      <url>/2018/11/03/%E5%AD%A6%E4%B9%A0VUE/</url>
      
        <content type="html"><![CDATA[<p>2018.10.15  开始学习vue</p><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p><p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p><p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p><p>第一段vue代码示例</p><pre><code>&lt;div id=&quot;vue_det&quot;&gt;    &lt;h1&gt;site : {{site}}&lt;/h1&gt;    &lt;h1&gt;url : {{url}}&lt;/h1&gt;    &lt;h1&gt;{{details()}}&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue({        el: &#39;#vue_det&#39;,        data: {            site: &quot;菜鸟教程&quot;,            url: &quot;www.runoob.com&quot;,            alexa: &quot;10000&quot;        },        methods: {            details: function() {                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;            }        }    })&lt;/script&gt;</code></pre><p>可以看到在 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。在上面实例中 id 为 vue_det，在 div 元素中：</p><pre><code>&lt;div id = &quot;vue_det&quot;&gt;&lt;/div&gt;</code></pre><h4 id="这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。"><a href="#这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。" class="headerlink" title="这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。"></a><b>这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。</b></h4><p>接下来我们看看如何定义数据对象。</p><p>data 用于定义属性，实例中有三个属性分别为：site、url、alexa。</p><p>methods 用于定义的函数，可以通过 return 来返回函数值。</p><p>用于输出对象属性和函数返回值。</p><h4 id="当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化"><a href="#当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化" class="headerlink" title="当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化"></a><b>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化</b></h4><pre><code>&lt;div id=&quot;vue_det&quot;&gt;    &lt;h1&gt;site : {{site}}&lt;/h1&gt;    &lt;h1&gt;url : {{url}}&lt;/h1&gt;    &lt;h1&gt;Alexa : {{alexa}}&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 我们的数据对象var data = { site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000}var vm = new Vue({    el: &#39;#vue_det&#39;,    data: data})// 它们引用相同的对象！document.write(vm.site === data.site) // truedocument.write(&quot;&lt;br&gt;&quot;)// 设置属性也会影响到原始数据vm.site = &quot;Runoob&quot;document.write(data.site + &quot;&lt;br&gt;&quot;) // Runoob// ……反之亦然data.alexa = 1234document.write(vm.alexa) // 1234&lt;/script&gt;</code></pre><h2 id="Vue-js-模板语法"><a href="#Vue-js-模板语法" class="headerlink" title="Vue.js 模板语法"></a>Vue.js 模板语法</h2><p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。</p><p>结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p><ol><li>插值<br><b>文本</b><br>数据绑定最常见的形式就是使用<pre><code>{{...}}（双大括号）</code></pre>的文本插值：</li></ol><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt;</code></pre><p><b>Html</b><br>使用 v-html 指令用于输出 html 代码：</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><b>指令</b></h4><p>指令是带有 v- 前缀的特殊属性。</p><p>指令用于在表达式的值改变时，将某些行为应用到 DOM 上。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    seen: true  }})&lt;/script&gt;</code></pre><p>新建一个vue对象，用el名绑定div中的id，那么在这个id为xxx的div块中，就可以使用其元素相应的数据。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;pre&gt;&lt;a v-bind:href=&quot;url&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    url: &#39;http://www.runoob.com&#39;  }})&lt;/script&gt;</code></pre><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{ message }}&lt;/p&gt;    &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    message: &#39;Runoob!&#39;  }})&lt;/script&gt;</code></pre><p>v-model 指令用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。</p><p>按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。</p><p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”指示, 格式如下：</p><pre><code>&lt;!-- 在两个大括号中 --&gt;{{ message | capitalize }}&lt;!-- 在 v-bind 指令中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;&lt;!-- 在两个大括号中 --&gt;{{ message | capitalize }}&lt;!-- 在 v-bind 指令中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</code></pre><p>过滤器函数接受表达式的值作为第一个参数。</p><p>以下实例对输入的字符串第一个字母转为大写：</p><pre><code>&lt;div id=&quot;app&quot;&gt;  {{ message | capitalize }}&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    message: &#39;runoob&#39;  },  filters: {    capitalize: function (value) {      if (!value) return &#39;&#39;      value = value.toString()      return value.charAt(0).toUpperCase() + value.slice(1)    }  }})&lt;/script&gt;</code></pre><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</code></pre><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</code></pre><h3 id="Vue-js-条件与循环"><a href="#Vue-js-条件与循环" class="headerlink" title="Vue.js 条件与循环"></a>Vue.js 条件与循环</h3><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;      A    &lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;      B    &lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;      C    &lt;/div&gt;    &lt;div v-else&gt;      Not A/B/C    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    type: &#39;C&#39;  }})&lt;/script&gt;</code></pre><h4 id="v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后"><a href="#v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后" class="headerlink" title="v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后"></a>v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后</h4><h4 id="我们也可以使用-v-show-指令来根据条件展示元素："><a href="#我们也可以使用-v-show-指令来根据条件展示元素：" class="headerlink" title="我们也可以使用 v-show 指令来根据条件展示元素："></a>我们也可以使用 v-show 指令来根据条件展示元素：</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt;    &lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    ok: true  }})&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="vue中的watch用法"><a href="#vue中的watch用法" class="headerlink" title="vue中的watch用法"></a>vue中的watch用法</h4><p>watch用来监听data中数据的变化，如果发生了变化，则进行操作。</p><pre><code>handler(newName,oldName){    this.fullName = newName + &#39;&#39; + this.lastName;},immediate: true</code></pre><p>以上代码，可以在一开始改变firstName的时候，就进行监听</p><p>此外，watch还有一个deep属性，默认值是<code>false</code>，代表是否深度监听。比如<code>data</code>里面有别的属性，则当属性改变时候，一般情况是监听不到的。只有加了<code>deep:true</code>，才会监听到属性值的改变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习JavaScript</title>
      <link href="/2018/11/03/%E5%AD%A6%E4%B9%A0JavaScript/"/>
      <url>/2018/11/03/%E5%AD%A6%E4%B9%A0JavaScript/</url>
      
        <content type="html"><![CDATA[<h1 id="1-这是我第一天学习JavaScript"><a href="#1-这是我第一天学习JavaScript" class="headerlink" title="1.这是我第一天学习JavaScript"></a>1.这是我第一天学习JavaScript</h1><p><em>斜体</em><br><strong>粗体</strong><br><del>好吗？</del></p><blockquote><p>这是引用<br>sss</p></blockquote><pre><code>print(&quot;hello!&quot;);return 0;</code></pre><hr><p>##1.为什么学习 JavaScript?##<br>JavaScript web 开发人员必须学习的 3 门语言中的一门：</p><p>HTML 定义了网页的内容<br>CSS 描述了网页的布局<br>JavaScript 网页的行为</p><p>##2.学习中的要点##</p><p>alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</p><p>您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。<br>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p><p>###JavaScript 用法###<br>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。<br>脚本可被放置在 HTML 页面的 <body> 和 <head><meta name="generator" content="Hexo 3.8.0"> 部分中。<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></body></p><p>那些老旧的实例可能会在 script 标签中使用 type=”text/javascript”。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言</p><h3 id="在-head-或者-body-的JavaScript"><a href="#在-head-或者-body-的JavaScript" class="headerlink" title="在 head 或者 body 的JavaScript"></a>在 head 或者 body 的JavaScript</h3><p>您可以在 HTML 文档中放入不限数量的脚本。<br>脚本可位于 HTML 的 body 或 head 部分中，或者同时存在于两个部分中。</p><p>通常的做法是把函数放入 head 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p><p>###外部的 JavaScript###<br>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p><p>外部 JavaScript 文件的文件扩展名是 .js。</p><p>如需使用外部文件，请在 script 标签的 “src” 属性中设置该 .js 文件：</p><p>##JavaScript 输出##</p><p>###JavaScript 没有任何打印或者输出的函数。###</p><p>JavaScript 可以通过不同的方式来输出数据：</p><ol><li>使用 window.alert() 弹出警告框。</li><li>使用 document.write() 方法将内容写到 HTML 文档中。</li><li>使用 innerHTML 写入到 HTML 元素。</li><li>使用 console.log() 写入到浏览器的控制台。</li></ol><p>2中的操作 HTML 元素<br>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。</p><p>请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：</p><p>请使用 document.write() 仅仅向文档输出写内容。<br>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖</p><p>###JavaScript 注释###<br>不是所有的 JavaScript 语句都是”命令”。双斜杠 // 后的内容将会被浏览器忽略：</p><p>###JavaScript 语句###<br>JavaScript 语句是发给浏览器的命令。</p><p>这些命令的作用是告诉浏览器要做的事情。</p><p>###重新声明 JavaScript 变量###<br>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p><p>在以下两条语句执行后，变量 carname 的值依然是 “Volvo”<br>var carname=”Volvo”;<br>var carname;</p><p>#JavaScript变量学习图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709822216279.gif" alt="avatar"></p><p>###JavaScript 对象###<br>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><pre><code>var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};</code></pre><p> 等价于</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> person<span class="token operator">=</span><span class="token punctuation">{</span>    firstname <span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>    lastname  <span class="token punctuation">:</span> <span class="token string">"Doe"</span><span class="token punctuation">,</span>    id        <span class="token punctuation">:</span>  <span class="token number">5566</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对象属性有两种寻址方式：</p><ol><li>name=person.lastname;</li><li>name=person[“lastname”];</li></ol><p>###提示：JavaScript具有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。###</p><p>#JavaScript数据类型学习脑图：#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710140220491.gif" alt="avatar"></p><p>#JavaScript函数学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709911288582.gif" alt="avatar"></p><p>##JavaScript 全局变量##</p><p>变量在函数外定义，即为全局变量。<br>全局变量有 全局作用域: 网页中所有脚本和函数均可使用。</p><p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。<br>以下实例中 carName 在函数内，但是为全局变量。<br>// 此处可调用 carName 变量 </p><p>function myFunction() {<br>    carName = “Volvo”;<br>    // 此处可调用 carName 变量<br>}</p><p>##HTML 事件##<br>HTML 事件可以是浏览器行为，也可以是用户行为。</p><p>HTML 网页中的每个元素都可以产生某些可以触发 JavaScript 函数的事件。</p><p>以下是 HTML 事件的实例：</p><ol><li>HTML 页面完成加载</li><li>HTML input 字段改变时</li><li>HTML 按钮被点击<br>通常，当事件发生时，你可以做些事情。</li></ol><p>在事件触发时 JavaScript 可以执行一些代码。</p><p>常见的HTML事件<br>下面是一些常见的HTML事件的列表:</p><p>事件—————-描述<br>onchange———HTML 元素改变<br>onclick    ————用户点击 HTML 元素<br>onmouseover—–用户在一个HTML元素上移动鼠标<br>onmouseout——用户从一个HTML元素上移开鼠标<br>onkeydown——-用户按下键盘按键<br>onload————浏览器已完成页面的加载</p><p>#JavaScript运算符学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20170921/1505989160659350.gif" alt="avatar"></p><p>#JavaScript流程语句学习脑图#</p><p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710031660821.gif" alt="avatar"></p><p>##Throw 语句##<br>throw 语句允许我们创建自定义错误。</p><p>正确的技术术语是：创建或抛出异常（exception）。<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>         <span class="token keyword">var</span> x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token string">"值为空"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"不是数字"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token string">"太大"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token string">"太小"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> y<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        y<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"错误："</span> <span class="token operator">+</span> err <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>##JavaScript 调试工具##<br>在程序代码中寻找错误叫做代码调试。</p><p>调试很难，但幸运的是，很多浏览器都内置了调试工具。</p><p>内置的调试工具可以开始或关闭，严重的错误信息会发送给用户。</p><p>有了调试工具，我们就可以设置断点 (代码停止执行的位置), 且可以在代码执行时检测变量。</p><p>浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p><ol><li>console.log() 方法</li><li>设置断点<br>在调试窗口中，你可以设置 JavaScript 代码的断点。<br>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。<br>在检查完毕后，可以重新执行代码（如播放按钮）。</li><li>debugger 关键字<br>debugger 关键字用于停止执行 JavaScript，并调用调试函数。<br>这个关键字与在调试工具中设置断点的效果是一样的。<br>如果没有调试可用，debugger 语句将无法工作。<br>开启 debugger ，代码在第三行前停止执行。</li></ol><p>##JavaScript 表单验证##</p><p>###JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证###</p><p>###表单数据经常需要使用 JavaScript 来验证其正确性：###</p><ol><li>验证表单数据是否为空？</li><li>验证输入是否是一个正确的email地址？</li><li>验证日期是否输入正确？</li><li>验证表单输入内容是否为数字型？</li></ol><p>##JavaScript JSON##<br>JSON 是用于存储和传输数据的格式。</p><p>JSON 通常用于服务端向网页传递数据 。</p><p>###什么是 JSON?###</p><ol><li>JSON 英文全称 JavaScript Object Notation</li><li>JSON 是一种轻量级的数据交换格式。</li><li>JSON是独立的语言 </li><li>JSON 易于理解。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RPC框架--远程过程调用</title>
      <link href="/2018/11/03/RPC%E6%A1%86%E6%9E%B6--%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2018/11/03/RPC%E6%A1%86%E6%9E%B6--%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>比如说，一个方法可能是这样定义的：<br>Employee getEmployeeByName(String fullName)那么：<br><ul><li>首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li><li>第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。<br></li><li>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送ss给B服务器。</li><li>第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li><li>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用</li></ul></p><hr><p>为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用.</p><hr><p>##经典回答##<br>本地过程调用</p><p>RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:</p><pre><code>1 int Multiply(int l, int r) {2    int y = l * r;3    return y;4 }5 6 int lvalue = 10;7 int rvalue = 20;8 int l_times_r = Multiply(lvalue, rvalue);</code></pre><p>那么在第8行时，我们实际上执行了以下操作：</p><ol><li>将 lvalue 和 rvalue 的值压栈</li><li>进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r</li><li>执行第2行代码，计算 l * r ，并将结果存在 y</li><li>将 y 的值压栈，然后从Multiply返回</li><li>第8行，从栈中取出返回值 200 ，并赋值给 l_times_r<br>以上5步就是执行本地调用的过程。</li></ol><p>##<strong>远程过程调用带来的新问题</strong>##</p><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p><ol><li><p><strong>Call ID映射。</strong>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</--></p></li><li><p><strong>序列化和反序列化。</strong>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p></li><li><p><strong>网络传输。</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</p></li></ol><p><strong>所以，要实现一个RPC框架，其实只需要把以上三点实现了就基本完成了。Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> rpc netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git的简单使用</title>
      <link href="/2018/11/03/Git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/11/03/Git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>提交版本：<br>git add xxx<br>git commit -m “注释”</p><p>查看修改了什么东西：git diff xxx</p><p>查看历史记录：git log    精简版:git log –pretty=oneline<br>版本回退到上一个版本：git reset –hard HEAD^<br>版本回退到上100个版本：git reset –hard HEAD~100</p><p>恢复之前的版本：<br>1.获得之前的版本号git reflog<br>2.git reset –hard 版本号       来恢复<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014061202.jpg" alt="avatar"></p><p>修改了文件之后，还未git add的情况下，想回复之前的状态，可以输入:git checkout – 文件名 </p><p>文件修改后，还没有add放到暂存区，使用撤销修改就回到和版本库一模一样的状态。<br>另外一种是文件已经add放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</p><p>删除了文件之后，还未commit提交的情况下，想回复仓库之前的状态，可以输入 git checkout – 文件名<br>经常输入git status 来查看文件的状态</p><p>把本地的仓库上传到github上：<br>1.在github新建一个仓库<br>2.输入git remote add origin 地址</p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程<br>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了</p><p>从现在起，只要本地作了提交，就可以通过如下命令：<br>git push origin master</p><p>克隆远程库：<br>假如远程库有新的内容了，我想克隆到本地来，如何克隆呢<br>使用命令git clone克隆一个本地库<br>git clone -b 分支名 地址</p><p>##创建与分支合并##</p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev  //创建分支</p><p>git checkout dev    //切换分支</p><p>##总结创建与合并分支命令如下：##</p><p>   查看分支：git branch</p><p>   创建分支：git branch name</p><p>   切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p>##如何解决冲突？##<br>在merge时，主干和分支不同的情况下，会产生冲突<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容</p><p>如果我想查看分支合并的情况的话，需要使用命令 git log</p><p>##分支策略##</p><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>##BUG分支##<br>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Java</title>
      <link href="/2018/11/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2018/11/03/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>##关于，面向对象<br>类用于客观世界里某一类对象的共同特征，而对象则是类的具体存在，Java程序使用类的构造器来创建该类的对象</p><p>构造器用于对类实例进行初始化操作，构造器支持重载。</p><hr><p>##对于一个类定义而言，可以包含三种最常见的成员：构造器、成员变量和方法。</p><hr><p>static修饰的成员不能访问没有static修饰的成员</p><hr><p>成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。</p><hr><p>##命名<br>成员变量应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写。方法名的命名规则与成员变量的命名规则基本相同。</p><hr><p>static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。因为通常把static修饰的成员变量和方法也称为类变量、类方法。不使用static修饰的普通方法、成员变量则属于该类的单个实例，而不属于该类。通常把不使用static修饰的成员变量和方法也成为实例变量、实例方法。</p><hr><p>构造器是一个特殊的方法，<strong>构造器名必须和类名相同</strong>。<br>构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但是java会把这个所谓的构造器当成方法来处理—它就不是构造器。</p><p>##<strong>实际构造器是有返回值的，当使用new关键字来调用构造器时，构造器返回该类的实例。</strong>##<br>创建对象的根本途径是构造器</p><hr><pre class=" language-java"><code class="language-java">Person p<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//使用person类定义一个person类型的变量</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通过new关键字调用Person类的构造器，返回一个Person的实例，将Person</span>或者Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义p变量的同时为p变量赋值</span></code></pre><p>Person p = new Person();<br>这行代码创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量。<br>在这行代码实际产生了两个东西，一个是p变量，一个是Person对象。<br>程序中定义的Person类型的变量实际上是一个引用，它存放在栈内存中，指向实际的Person对象。而真正的Person对象则存放在堆（heap）内存中。</p><hr><p>栈内存里的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度看，引用变量与C语言里的指针很像，他们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针。<br>p引用变量本事只存储了一个地址值，并未包含任何实际数据。但它指向实际的Person对象，当访问p引用变量的成员变量和方法时，实际上是访问p所引用对象的成员变量和方法。</p><hr><p>如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。<br>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可。也就是把这些引用变量赋值为null。</p><hr><p>this关键字总是指向调用该方法的对象<br>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p><p>##<strong>没有使用static修饰的成员变量和方法都必须使用对象调用。</strong>##</p><p>this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的：它所代表的只能是当前类的实例，只有当这个方法被调用时，它所代表的对象才被确定下来：谁在调用这个方法，this就代表谁。</p><p>java允许对象的一个成员直接调用另一个成员，可以省略this前缀。</p><p>##<strong>static修饰的方法属于类，而不属于对象。</strong>##<br>Java编程时不要使用对象去调用static修饰的成员变量、方法，而是应该使用类去调用static修饰的成员变量、方法。</p><hr><p>##方法##<br>在结构化编程语言里，函数是一等公民，整个软件由一个个的函数组成；在面向对象编程语言里，类才是一等公民。整个系统由一个个的类组成。因此在Java语言里，方法不能独立村子，方法必须属于类或对象。</p><p>Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的，永远都不会改变。</p><p>同一个类的一个方法调用另外一个方法时，如果被调用方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者，表面上看起来某些方法可以被独立执行，但实际上还是使用this或者类作为调用者。</p><p>##方法重载##<br>Java程序中确定一个方法需要三个要素：<br>调用者，也就是方法的所属者，既可以是类，也可以是对象。<br>方法名，方法的标识<br>形参列表，当调用方法时，系统将会根据传入的实参列表匹配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/11/03/hello-world/"/>
      <url>/2018/11/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
