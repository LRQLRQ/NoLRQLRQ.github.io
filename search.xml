<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>45初探贪心</title>
      <link href="/2020/06/19/45%E8%B4%AA%E5%BF%83/"/>
      <url>/2020/06/19/45%E8%B4%AA%E5%BF%83/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>贪心算法</strong></p><p>第45题</p><p>给一个数组，从头跳到尾，数组内的值代表当前能跳的步数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> jump <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> maxPosition <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 未到边界前，下一步能到的最远位置</span>  <span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当前能跳的边界    </span>  <span class="token keyword">let</span> steps <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    maxPosition <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxPosition<span class="token punctuation">,</span> i<span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">===</span>end<span class="token punctuation">)</span> <span class="token punctuation">{</span>                end <span class="token operator">=</span> maxPosition<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 到边界后，更新下一步的边界为能跳到的最远位置</span>      steps <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> steps<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>每次都跳能跳的最远位置，贪心算法，一直到最后。</p><p>这里有一处巧妙的地方，for循环中的判断条件，是小于<code>nums.length-1</code>的,也就是说<code>i</code>是永远到不了数组中最后那个位置的，而最后一次的<code>end</code>必然会大于等于数组最后的位置，所以<code>step</code>就少一次增加。因为在太初之时，盘古开天辟地的时候，我们给<code>end</code>赋值为0，也就是说第一次刚进入程序执行的时候<code>step</code>就已经加一了，这里需要注意一哈。</p><hr><p>2020.6.19<br>written by Rain.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>最长有效括号（动态规划，栈，巧妙解）</title>
      <link href="/2020/05/04/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%A0%88%EF%BC%8C%E5%B7%A7%E5%A6%99%E8%A7%A3%EF%BC%89/"/>
      <url>/2020/05/04/%E6%9C%80%E9%95%BF%E6%9C%89%E6%95%88%E6%8B%AC%E5%8F%B7%EF%BC%88%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%8C%E6%A0%88%EF%BC%8C%E5%B7%A7%E5%A6%99%E8%A7%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>做了一道拖了很久的题，总结一下。</p><h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>题目: leetcode32</p><p>描述: 给一个字符串，找出最长有效的括号</p><p>输入: ‘(()’   输出: 2</p><p>输入: ‘)()())’ 输出: 4</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><h4 id="1-dp-动态规划"><a href="#1-dp-动态规划" class="headerlink" title="1. dp 动态规划"></a>1. dp 动态规划</h4><p>建立一个dp数组，dp数组的意义是当前index为止，最大的有效括号长度是多少。</p><p>主要是写出状态转移方程，当遇到第i位是 ‘)’时，触发条件，此时又分为两种：</p><ul><li><p>a. i-1位置是 ‘(‘,此种情况很简单， dp[i] = dp[i-2] + 2</p></li><li><p>b. i-1位置是 ‘)’,此种情况就比较复杂，要再往前追溯一下，看 s[i - dp[i-1] - 1],这个位置是不是 ‘(‘</p></li></ul><p><strong>用语言描述就是，从当前开始向前数，当前有效括号长度走过之后再走一步，那个位置是不是 ‘(‘,和当前的’)’匹配</strong> 假如匹配上的话，动态方程  <code>dp[i] = dp[i-1] + dp[i - dp[i-1] - 2] + 2</code>,  前一个位置的最大值是 <code>dp[i-1]</code>,  <code>dp[i-dp[i-1]-2]</code> 这个值代表与当前的’)’ 匹配的 ‘(‘再前一个位置的最大有效长度，是可以累积起来的，最后再加上2，即这次累积的长度。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> longestValidParentheses <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>  dp<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">')'</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>​      <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'('</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>​        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>i<span class="token number">-2</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">?</span> dp<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">;</span>​      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">[</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">===</span><span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">>=</span><span class="token number">0</span><span class="token operator">?</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>​      <span class="token punctuation">}</span>​    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>dp<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​    max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><h4 id="2-栈的方法"><a href="#2-栈的方法" class="headerlink" title="2. 栈的方法"></a>2. 栈的方法</h4><p>定义一个栈，初始只有一个值，-1 ,（为第一个遇到的’)’ 做准备）,</p><ol><li>遇到 ‘(‘就入栈, 要注意入栈的值是当前’(‘在字符串中的位置坐标index</li><li>遇到 ‘)’就pop出一个值，相当于对对碰抵消掉一对儿，然后接着走</li><li>假如栈中没有 ‘(‘的index了，就放 当前’)’的位置信息吧，反正下一轮也会直接把这个 ‘)’直接pop出去，刚刚入栈的 ‘)’就相当于是一个垃圾信息，因为之前已经没有 ‘(‘可以和它配对儿了</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> longestValidParentheses2 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//把index放进去</span>​    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>​      stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>​        stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>​      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>​        max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> i <span class="token operator">-</span> stack<span class="token punctuation">[</span>stack<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​      <span class="token punctuation">}</span>​    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="3-好巧妙的一个方法"><a href="#3-好巧妙的一个方法" class="headerlink" title="3. 好巧妙的一个方法"></a>3. 好巧妙的一个方法</h4><ol><li>从左向右走一遍，当 ‘(‘ 的个数和 ‘)’ 的个数相等时， 且中间没有过 ‘)’的个数大于 ‘(‘的情况时此时就是一个有效长度，累积比较最大的值</li><li>但是对这种情况 ‘((())’ 得到的结果是0， 找不到最大的值</li><li>可以再从右向左走一遍，就能得到最大值了</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> longestValidParentheses3 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​      left<span class="token operator">++</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>​      right<span class="token operator">++</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>​      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> left<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>right <span class="token operator">></span> left<span class="token punctuation">)</span> <span class="token punctuation">{</span>​      left <span class="token operator">=</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  left <span class="token operator">=</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span>s<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'('</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>​      left<span class="token operator">++</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>​      right<span class="token operator">++</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">===</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>​      max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> left<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>​    <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>​      left <span class="token operator">=</span> right <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>​    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> max<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><hr><p>2020.5.4<br>written by Rain</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git多用户</title>
      <link href="/2020/03/02/git%E5%A4%9A%E7%94%A8%E6%88%B7/"/>
      <url>/2020/03/02/git%E5%A4%9A%E7%94%A8%E6%88%B7/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h3><p>基本上每个人用一个git账号就够了，但如果在github上用一个账号，在某个gitlab上又需要一个账号，在不同的工作场景怎么切换呢？</p><h3 id="切换用户和邮箱"><a href="#切换用户和邮箱" class="headerlink" title="切换用户和邮箱"></a>切换用户和邮箱</h3><p>使用如下命令可查看当前的用户名和邮箱</p><pre><code>git config user.name   //查看用户名git config user.email  //查看邮箱</code></pre><p>如果是使用https方式clone文件的话，可以直接需改邮箱即可。</p><pre><code>git config --global user.email &quot;youremail@111.com&quot;</code></pre><h3 id="增加秘钥"><a href="#增加秘钥" class="headerlink" title="增加秘钥"></a>增加秘钥</h3><p>修改邮箱的话，每次都要修改，可以添加配置文件，增加一个秘钥，同时需要在github或者相应的gitlab上添加相应的公钥。</p><ol><li>在<code>~/.ssh/</code>目录下，新建config文件</li><li>生成相应的秘钥<pre><code>ssh-keygen -t rsa -C &quot;rain@163.com&quot;   //这里要填你github相应的邮箱</code></pre></li><li>在文件内填写Host和IdentityFile配置如下</li></ol><pre><code>HostName git-githubHost github.com www.github.comUser LRQIdentityFile ~/.ssh/id_rsaHost gongsi.comIdentityFile ~/.ssh/gongsi_id_rsa</code></pre><p>Host是仓库网站的别名，随意取<br>HostName是仓库网站的域名<br>User是仓库网站上的用户名<br>IdentityFile是私钥的绝对路径  </p><h3 id="文件夹递归处理问题"><a href="#文件夹递归处理问题" class="headerlink" title="文件夹递归处理问题"></a>文件夹递归处理问题</h3><p>至此就结束了。<br>今天还遇到一个问题，干脆也写出来。在使用npm安装包的时候，有时候会出现没有access访问权限，是因为默认的新建的文件夹都是没有写权限的，给文件夹加上写权限即可</p><pre><code>chmod -R 755 /folder</code></pre><p>-R就是目录下的所有文件</p><hr><p>2020.2.14<br>written by Rain</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git的一些回顾,及git flow思想</title>
      <link href="/2020/01/04/git%E5%9B%9E%E9%A1%BE%E5%8F%8Agit%20flow%E6%80%9D%E6%83%B3/"/>
      <url>/2020/01/04/git%E5%9B%9E%E9%A1%BE%E5%8F%8Agit%20flow%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>研一进了项目组就开始用git，用了很久也只是用一些基本的 <code>git pull</code>、 <code>git add .</code> 、 <code>git commit -m &quot;&quot;</code> 、 <code>git push</code>，感觉这些命令就够日常开发工作了。最近重新整理了git，看了一下git pro这本书，懂了一些git的底层原理。在这里记录一下重新对git的一些认识。此外，这篇文章还会简单介绍一种<code>git flow</code>的开发理念。</p><h3 id="每一次commit-提交-，就是一个版本"><a href="#每一次commit-提交-，就是一个版本" class="headerlink" title="每一次commit(提交)，就是一个版本"></a>每一次commit(提交)，就是一个版本</h3><p>在git仓库中，有三个区域，这是我自己的理解哈，可能用语不是那么专业。——工作区、暂存区、和仓库区。  </p><p><img src="https://git-scm.com/book/en/v2/images/areas.png" alt="git area"><br>工作区就是你的当前项目工作空间。当开发者进行了一些修改，执行<code>git add file</code>之后，修改后的文件就会进入暂存区。</p><p>开发到一定程度，某个功能开发完毕后，执行<code>git commit</code>后，就会从暂存区移动到仓库区。实际上每次commit就是提交一个版本，git会对所有修改过的文件进行<code>SHA-1</code>算法，压缩成一个40个字符的字符串，每次提交完成后控制台会返回一串字符，实际上就是这个字符串的前七位。然后将文件的快照存储起来。  </p><p>每个分支实际上就是一个指针，指向某个版本，也就是某次提交的指针。理论上只要知道某次提交后返回的那串字符，就可以找到那个版本。(只要你本地没删底层的东西)  </p><h3 id="git的merge-合并-与rebase-变基"><a href="#git的merge-合并-与rebase-变基" class="headerlink" title="git的merge(合并)与rebase(变基)"></a>git的merge(合并)与rebase(变基)</h3><p>使用git最核心的还是版本控制，vcs。允许开发者设置不同的分支来进行开发。每个分支可能是有不同的功能。当功能开发完毕后，需要合并到主干上，就需要用到这两个命令——merge和rebase。  </p><ol><li>merge<br>比如当前开发者在master上执行下列命令  </li></ol><pre class=" language-shell"><code class="language-shell">git checkout -b devecho "this is my test in dev" >> READMEgit add .git commit -m 'change README in dev branch'git checkout mastertouch main.jsgit add .git commit -m 'add new file main.js'git merge dev</code></pre><p>以上操作会先建立一个dev分支，在其上修改之后，完成了新功能，想要在master分支上添加新功能。就可以使用merge，将在dev分支添加的功能融合到master中。<br>注意<strong>merge是三方的融合，不只是dev和master的融合</strong>。git会先找到dev的祖先，也就是从master中新建的那个版本A，然后融合修改后的dev分支、A版本、修改后的master版本。最后生成一个新版本B，并让HEAD指针指向B。（HEAD指针总是指向当前的分支）<br><img src="https://git-scm.com/book/en/v2/images/basic-merging-2.png" alt="git merge"></p><ol start="2"><li>rebase<br>rebase的功能叫做变基，顾名思义，是要改变其基石，也就是之前的指针。功能上是融合A和B两个分支，实际上是丢弃（比如说）B版本上进行的一些提交，把这些提交当做补丁，在A版本上重新提交一次。但是这是两批不同的提交，所以说是会丢弃。<br>代码如下</li></ol><pre class=" language-shell"><code class="language-shell">git checkout -b testRebaseecho "this is rebase magic" >> READMEgit add .git commit -m 'add sth in README'git rebase msatergit checkout mastergit merge testRebase</code></pre><p><img src="https://git-scm.com/book/en/v2/images/basic-rebase-3.png" alt="git rebae"></p><p>如果使用rebase，必须在远程仓库没有的版本（commit后的提交）进行，否则使用了rebase之后会将这些版本，比如A版本丢弃，其他协同开发者的项目可能就是基于A版本的。某人使用rebase后，A版本的内容变基到了别的分支上，内容是一模一样的，但是版本却不同了。其余的开发者就会造成巨大的混乱。<br>这里引用一下git pro的原文：<em>不要对在你的仓库外有副本的分支执行变基。如果你遵循这条金科玉律，就不会出差错。 否则，人民群众会仇恨你，你的朋友和家人也会嘲笑你，唾弃你。</em> 哈哈，虽然搞笑，但是也能看出来乱用rebase的混乱。  </p><h3 id="git-flow思想"><a href="#git-flow思想" class="headerlink" title="git flow思想"></a>git flow思想</h3><p>git flow刚开始我以为是一个软件，也确实下载到了。后来才意识到这是一种思想。使用了git flow之后，越来越觉得以前在项目组开发的时候使用git是多随意，完全就是在master，或者某个特定的分支上进行开发，然后pull、push。实际上这样很不利于项目的维护。下面介绍一下git flow思想。  </p><p>git flow中，项目存在两个长期分支：master和develop。任何时候在master中拿到的都是稳定的版本。正常的开发都是在develop版本上开发，所以develop分支普遍会超前master很多。<br>其次，项目会分为几种短期版本：功能版本(feature branch)、补丁版本(hotfix branch)、预发版本(release branch)，一旦开发完成，他们就会合并到master或者develop中，然后被删除。  </p><p><img src="https://gitbook.tw/images/tw/gitflow/why-need-git-flow/flow.png" alt="git flow"></p><p>2020.01.04 晴<br>written by Rain</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>采集天气每日一句发送邮件</title>
      <link href="/2019/12/23/%E9%87%87%E9%9B%86%E5%A4%A9%E6%B0%94%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/"/>
      <url>/2019/12/23/%E9%87%87%E9%9B%86%E5%A4%A9%E6%B0%94%E6%AF%8F%E6%97%A5%E4%B8%80%E5%8F%A5%E5%8F%91%E9%80%81%E9%82%AE%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>爬取墨迹天气、一个、有道词典的每日一句，通过server酱发送给相应的微信，发送邮件给相应的用户。<br>微信效果图如下：<br><img src="https://github.com/LRQLRQ/picture/blob/master/wechatRobotPic.png?raw=true" alt="微信效果图"><br>邮件效果图如下：<br><img src="https://github.com/LRQLRQ/picture/blob/master/emailRobotPic.png?raw=true" alt="邮件效果图">  </p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年刚开始接触node，在网上找到一个每天定时给女朋友发消息的代码，开始用了一段时间，也没好好看代码。当时只是觉得能写出这种功能应该很NB。最近看了很多基础的知识，对前端有了更多的认识，js也了解的更深入了，就自己动手做了一个。花了一天半吧，还是很有激情的，哈哈。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><code>git clone</code>这份代码，或者下载到本地。</li><li>进入根目录，然后<code>npm install</code></li><li>修改<code>config.js</code>,设置收件人的相关信息（收件人的邮箱，server酱的码，以及额外要说的话）。</li><li>修改<code>sendEmail.js</code>,修改发件人的邮箱，授权码，修改发送邮件的主题等。</li><li>设置相应的server酱的码。（只需要中间的那串）详细访问<a href="http://sc.ftqq.com/3.version" target="_blank" rel="noopener">server酱官网</a>。</li></ol><h3 id="开发过程"><a href="#开发过程" class="headerlink" title="开发过程"></a>开发过程</h3><p>整体上还是比较顺利的，这次有意识的将代码块分隔开，尽量把每一个功能都单独分隔成一个模块。  </p><hr><p>爬网站用的是<code>cheerio</code>这个库，和jquery的用法差不多。主要用css选择器选择相应的dom元素，在这里暴露出我css比较薄弱的弱点，获得相应的内容可能比较粗暴。以后对css选择器用多了应该会有更优雅的读取方式。  </p><hr><p>发送请求使用的<code>axios</code>这个库，以前只会用<code>jquery</code>的<code>ajax</code>，想要达到同步的效果只会在<code>success</code>的回调内嵌套<code>ajax</code>请求。这次将每个功能分隔开，每个函数返回了一个<code>promise</code>，使用<code>Promise.all[]</code>之后，在then里面写相应的逻辑，避免了回调嵌套。</p><hr><p>发送邮件使用的<code>nodeemail</code>这个包，找了一份demo就能用，暂时还没深入的研究。这个异步用的是<code>async</code>和<code>await</code>,以后要研究一下。<br>输入：发件人邮箱、授权码、发件人邮箱、主题、内容（html格式）<br>就可以发送  </p><hr><p>读取的内容是markdown格式，需要将markdown转化为html格式，使用了<code>showdown</code>这个包。</p><hr><p>使用了定时任务的功能，引入了<code>node-schedule</code>这个包。在这里还出了一个小bug。<br>操作：定时给女朋友和我发送邮件，爬取不同地区的墨迹天气的信息，分别发送不同的邮箱。<br>bug内容：我收到的天气内容是女朋友所在地的。<br>原因分析：发送邮件是一个异步任务，而定时时间到了之后，爬取的数据放到了同一个全局变量里面。感觉就类似多线程对公共资源的非法访问。我的地区的天气信息被女朋友的覆盖了。<br>解决方案：将words变为每个函数的私有变量。  </p><hr><h3 id="有待优化"><a href="#有待优化" class="headerlink" title="有待优化"></a>有待优化</h3><ol><li>各个模块分成不同的文件，<code>index.js</code>内容变少一些</li><li>请求one和有道词典每日一句的接口只需要一次就可以，有空了再改改逻辑优化。</li></ol><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>果然还是在开发过程中学东西比较快，做出有意思的东西也比较有成就感，想到什么就查什么，面向github编程。但是这样还是有点浅，<s>待有空时</s>（不如现在就花20分钟看一下）再深入了解一下原理。<br>偶然间看到了有道词典的每日一句，觉得加上这个逼格很高，但是网页版的有道词典没有这个功能，只有APP才有，还专门下载了charles，连接手机和Mac，用手机打开有道词典，抓取手机的包，才找到那个接口。一波三折也是很快乐。  </p><p>2019.12.23  晴<br>written by Rain  </p>]]></content>
      
      
      
        <tags>
            
            <tag> node </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>关于抢票——自己动手，丰衣足食</title>
      <link href="/2019/12/19/30%E5%88%86%E9%92%9F%E9%83%A8%E7%BD%B2%E6%8A%A2%E7%A5%A8%E4%BB%BB%E5%8A%A1/"/>
      <url>/2019/12/19/30%E5%88%86%E9%92%9F%E9%83%A8%E7%BD%B2%E6%8A%A2%E7%A5%A8%E4%BB%BB%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>因为放假回家前打算去玩一趟，去玩的票已经买好了，回家的票16号刚放出来，就没得了。因为不是首末站，中间站比较难买，所以得一直操心着。用那些抢票软件太烦了，总是让人邀好友助力，上次想去秦皇岛玩，我看有80%的成功率，就没怎么找人助力，一直到最后都没买到票，真是服了。记起来以前github上有大佬写过抢票的脚本，还是自己动手，丰衣足食吧。<br>话不多说，进入正文——  </p><h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><ol><li><p>服务器一台<br>服务器可以使用阿里云或者腾讯云，学生的话10块钱一个月，挺好用的，我的就是阿里云（ubuntu 18）的。  </p></li><li><p>自己的电脑连接服务器<br>然后用自己的电脑ssh连接到服务器，windows可以用xshell，输入root和密码，端口号22就行。mac用户可以使用iterm，写个脚本连接到服务器，具体自行百度。  </p></li><li>github搜索12306，下载点赞数最多的那个仓库<br>在github下载这个仓库<code>https://github.com/testerSunshine/12306</code>，建议直接使用自己的电脑下载代码，然后上传到服务器。（Windows建议使用Fileize，mac建议使用Cyberduck）</li></ol><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>其实大佬项目的README已经写的很清楚了，我只是把我踩过的坑整理一下。  </p><ol><li>进入到项目，下载相关的依赖。  </li><li>修改相应的配置文件。</li><li>筛选cdn，启动服务</li></ol><p>在修改配置文件的时候，要设置提醒邮箱。当抢到票后会通过邮箱通知。  </p><pre class=" language-js"><code class="language-js">EMAIL_CONF <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token string">"IS_MAIL"</span><span class="token punctuation">:</span> True<span class="token punctuation">,</span>    <span class="token string">"email"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//自己的A邮箱，用于发送邮件</span>    <span class="token string">"notice_email_list"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//自己的B邮箱，用于接受邮件</span>    <span class="token string">"username"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//A邮箱如果是QQ邮箱，这里填QQ号</span>    <span class="token string">"password"</span><span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//填授权码，具体操作百度</span>    <span class="token string">"host"</span><span class="token punctuation">:</span> <span class="token string">"smtp.qq.com"</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//QQ邮箱就是这个，如果是163邮箱就是smtp.163.com</span><span class="token punctuation">}</span></code></pre><p>依赖安装好后运行如下命令即可：  </p><pre class=" language-python"><code class="language-python">python3 run<span class="token punctuation">.</span>py c  <span class="token comment" spellcheck="true"># 筛选cdn</span>python3 run<span class="token punctuation">.</span>py r  <span class="token comment" spellcheck="true"># 启动任务</span></code></pre><h4 id="ubuntu18遇到的错误"><a href="#ubuntu18遇到的错误" class="headerlink" title="ubuntu18遇到的错误"></a>ubuntu18遇到的错误</h4><p>可能是有一些cv的库没装好，运行脚本启动任务的时候报错了，查了github的issue有个答案很work。<br>ubuntu 18.04 在执行run的时候有个报错，报错信息如下<br><code>ImportError: libSM.so.6: cannot open shared object file:</code><br>需要安装python-qt4<br>apt install python-qt4  </p><p>确实很管用。运行之后等一会就好了，刚开始会先记录一些验证码。  </p><p><img src="https://github.com/LRQLRQ/picture/blob/master/train_tickets.png?raw=true" alt="avatar">  </p><p>这是室友抢到候补的图片:<br><img src="https://github.com/LRQLRQ/picture/blob/master/jjTicket.png?raw=true" alt="成功的图片"></p><p>2019.12.19<br>written by LRQ<br>(这次的博客有点没有营养，但是用了大佬的轮子很开心哈哈)</p>]]></content>
      
      
      
        <tags>
            
            <tag> stuff </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JS的六种继承模式</title>
      <link href="/2019/12/16/JS%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/16/JS%E7%9A%84%E5%85%AD%E7%A7%8D%E7%BB%A7%E6%89%BF%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JS中的六种模式，基本的东西应该掌握。  </p><h3 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1.原型链继承"></a>1.原型链继承</h3><p>操作：将子类的原型赋值为父类的一个实例。<br>优点：子类的实例可以继承父类的原型链<br>缺点：所有子类的实例共享一份数据，不能向父类传参。  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"rain"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"reading"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">subType</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//将子类的原型赋值为父类的一个实例</span>subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sub1<span class="token punctuation">.</span>name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//rain</span>sub1<span class="token punctuation">.</span>hobbies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"playing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["reading", "running", "playing"]</span>sub2<span class="token punctuation">.</span>name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//rain</span>sub2<span class="token punctuation">.</span>hobbies<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["reading", "running", "playing"]</span></code></pre><h3 id="2-构造函数继承"><a href="#2-构造函数继承" class="headerlink" title="2.构造函数继承"></a>2.构造函数继承</h3><p>操作：在子类的函数中使用call来调用父类的构造函数<br>特点：子类中每个实例都有一份父类构造函数中数据<br>缺点：</p><ol><li>只能继承构造函数内的数据，无法继承原型链中的数据</li><li>无法实现构造函数的复用</li><li>每个新实例都有父类构造函数的副本</li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"rain"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"reading"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My name is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">subType</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>  superType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将父类的构造函数在子类中调用</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> sub1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">subType</span><span class="token punctuation">(</span><span class="token number">19</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sub1<span class="token punctuation">.</span>hobbies<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">"playing"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sub1<span class="token punctuation">.</span>hobbies<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["reading", "running", "playing"]</span>sub2<span class="token punctuation">.</span>hobbies<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//["reading", "running"]</span>sub1<span class="token punctuation">.</span><span class="token function">showName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//报错，因为没有继承父类的原型链</span></code></pre><h3 id="3-组合式继承"><a href="#3-组合式继承" class="headerlink" title="3.组合式继承"></a>3.组合式继承</h3><p>操作：将子类的原型赋值为父类的一个实例，在子类的构造函数中使用call调用父类的构造函数<br>特点：每个子类都有一份独立的数据，也可以继承父类的原型链。<br>缺点：要调用两次父类的构造函数，子类原型中，即那个父类的实例中的数据是多余的。因为子类的实例中有相同的属性，会将原型中的同名属性屏蔽。  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"rain"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"reading"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My name is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">subType</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>  superType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将父类的构造函数在子类中调用</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span>subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>subType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span></code></pre><h3 id="4-原型式继承"><a href="#4-原型式继承" class="headerlink" title="4.原型式继承"></a>4.原型式继承</h3><p>操作：构建一个空函数，令空函数的原型为目标对象，返回空函数的实例。object.create()就是这个原理。<br>特点：类似于复制一个对象，用函数来包装。<br>缺点： </p><ol><li>所有实例都会继承原型上的属性</li><li>无法实现复用。  </li></ol><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  f<span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> sup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">object</span><span class="token punctuation">(</span>sup<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="5-寄生式继承"><a href="#5-寄生式继承" class="headerlink" title="5.寄生式继承"></a>5.寄生式继承</h3><p>操作：寄生式继承模式，是在原型式继承的基础上，添加别的属性或方法。添加的属性在实例中。<br>优点：没有创建自定义类型，因为只是套了个壳子返回对象。这个函数就成了新的对象。<br>缺点：做不到函数复用。每次使用寄生函数新增实例时，都会为实例赋予一个新的函数。  </p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//父类</span><span class="token keyword">function</span> <span class="token function">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"rain"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"reading"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//父类原型添加的方法</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My name is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原型式继承工具函数</span><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  f<span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//寄生式继承增强方法</span><span class="token keyword">function</span> <span class="token function">paraObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> sup <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>sup<span class="token punctuation">)</span><span class="token punctuation">;</span>  sub<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">18</span><span class="token punctuation">;</span>  sub<span class="token punctuation">.</span>showAge <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"my age is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> sub<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">paraObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>age<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//18</span>a<span class="token punctuation">.</span><span class="token function">showAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//my age is 18</span></code></pre><h3 id="6-寄生组合式继承"><a href="#6-寄生组合式继承" class="headerlink" title="6.寄生组合式继承"></a>6.寄生组合式继承</h3><p>其实就是组合式继承的改良版。组合式继承是子类是构造函数的原型是父类的一个实例。而寄生式则是：先使用类似Object.create()的方法获得继承了父类原型的一个实例，构造函数指向父类的构造函数，再将其作为子类构造函数的原型。  </p><p>这样就解决了组合式继承的问题：子类构造函数的原型是父类的一个实例，原型中的数据会被子类实例中同名数据屏蔽。  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">superType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"rain"</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>hobbies <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"reading"</span><span class="token punctuation">,</span> <span class="token string">"running"</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>showName <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"My name is "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">subType</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>  superType<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将父类的构造函数在子类中调用</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原型式继承工具函数</span><span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  f<span class="token punctuation">.</span>prototype <span class="token operator">=</span> obj<span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">inheritPrototype</span><span class="token punctuation">(</span>subType<span class="token punctuation">,</span> superType<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> prototype <span class="token operator">=</span> <span class="token function">object</span><span class="token punctuation">(</span>superType<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//获得一个干净的父类原型</span>  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subType<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将原型的构造函数设置为子类</span>  subType<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//子类的原型设置为父类的原型</span><span class="token punctuation">}</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>开发中比较常用的是组合式继承和寄生组合式继承。最好的继承方式是寄生组合式继承。<br>因为js的原型链特性，对于所谓的”继承“，其实就是需要考虑函数的复用，组合。前面几种的继承模式有不同的缺陷，添加某些操作修复缺陷后，就变为了一种新的继承方式。  </p><p>2019.12.16  大雪<br>written by LRQ  </p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js数组使用reduce实现数组扁平化、map、filter、去重</title>
      <link href="/2019/12/15/js%E4%B8%ADreduce%E7%9A%84%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/12/15/js%E4%B8%ADreduce%E7%9A%84%E5%A4%9A%E7%A7%8D%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="本来是要实现一个数组扁平化的，结果搜到一篇博客有reduce实现的方法，也使用reduce实现了map、filter、数组去重这些方法，在这里复现一下。"><a href="#本来是要实现一个数组扁平化的，结果搜到一篇博客有reduce实现的方法，也使用reduce实现了map、filter、数组去重这些方法，在这里复现一下。" class="headerlink" title="本来是要实现一个数组扁平化的，结果搜到一篇博客有reduce实现的方法，也使用reduce实现了map、filter、数组去重这些方法，在这里复现一下。"></a>本来是要实现一个数组扁平化的，结果搜到一篇博客有reduce实现的方法，也使用reduce实现了map、filter、数组去重这些方法，在这里复现一下。</h4><hr><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><p>给出如下数组:<br><code>var arr = [1,[2,[3,[4]]]]</code>, 输入的数组可能是数组中嵌套数组，经过扁平化之后希望得到一维数组。<code>[1,2,3,4]</code>.</p><h4 id="使用递归来实现"><a href="#使用递归来实现" class="headerlink" title="使用递归来实现"></a>使用递归来实现</h4><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result <span class="token operator">=</span> result<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">flatten</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="使用reduce来实现"><a href="#使用reduce来实现" class="headerlink" title="使用reduce来实现"></a>使用reduce来实现</h4><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>flatten <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>pre<span class="token punctuation">,</span> item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> pre<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">?</span> item<span class="token punctuation">.</span><span class="token function">flatten</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">flatten</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//[1,2,3,4,5]</span></code></pre><p>reduce是Array原型中的一个内置函数。需要两个参数：函数和初始值。reduce函数可以做一个累加器，对数组中的数据逐个进行操作，最后累积的操作在传入的对象中。  </p><hr><h3 id="使用reduce实现map方法"><a href="#使用reduce实现map方法" class="headerlink" title="使用reduce实现map方法"></a>使用reduce实现map方法</h3><p>map方法是Array的原型的内置方法，此方法需要传入一个函数，map会对数组内的所以元素执行该函数。  </p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_map <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>pre<span class="token punctuation">,</span> item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      pre<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"callback is not a function"</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">_map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span>num<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// [2,3,4,5]</span></code></pre><p><strong>切记！使用reduce时，函数必须有return，作为下一次迭代的pre</strong><br>因为map方法的迭代的函数传入的三个参数依次是 当前项内容、索引、数组。与reduce的后三个一样，所以可以使用reduce来实现。  </p><hr><h3 id="使用reduce实现filter方法"><a href="#使用reduce实现filter方法" class="headerlink" title="使用reduce实现filter方法"></a>使用reduce实现filter方法</h3><p>实现filter方法与map类似，filter也是需要传入一个函数，遍历数组的元素，函数的返回值类型是布尔值，为true则留下当前项，为false则舍弃当前项。起到一个筛选的作用。  </p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>_filter <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> callback <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>pre<span class="token punctuation">,</span> item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token function">callback</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> index<span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token operator">?</span> pre<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> pre<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'callback is not a function'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">_filter</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> num<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// [3,4]</span></code></pre><hr><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>数组去重也可以使用reduce来实现。因为有累积的效果，遍历的时候进行处理，如果已经存在就不放进去。  </p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>unique <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>pre<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    pre<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token keyword">null</span><span class="token punctuation">:</span> pre<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> pre<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">unique</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[1,2,3,4]</span></code></pre><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是reduce的一些用法，核心就是可以在使用相应的函数迭代数组中的元素时，可以记录（是在不知道怎么用词了，累积？）对象，将对象保存起来。函数中return的值就是下一次迭代的pre的值。<br>另外一点需要注意，这些方法全都不是在原来的数组中操作，都是返回了一个新的数组对象。(实际上就是reduce方法的第二个参数传入的那个对象,[])</p><p>2019.12.15<br>written by LRQ<br>对了，我有英文名了: Rain</p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>发布订阅模式</title>
      <link href="/2019/12/05/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/05/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>很久前想深入理解Vue的底层原理，看了很多博客，只知道是“数据劫持+发布订阅模式”，之前写了一篇博客，懂了数据劫持，最近看到很多源码分析mvvm框架，说了很多次“发布订阅模式”，花了一下午加一晚上终于算是弄懂了！（前期的很多积累很重要，没有基础的支撑，感觉花再多时间啃某个知识点也是浪费时间，因为可能一个点不懂，一连串都会断掉，体会不到设计的巧妙）</p><h2 id="正题"><a href="#正题" class="headerlink" title="正题"></a>正题</h2><p>本文将从以下四个方面介绍</p><ol><li>发布订阅模式的作用是什么</li><li>发布订阅模式详解</li><li>实现发布订阅模式</li><li>发布订阅模式与观察者模式的区别</li></ol><h3 id="1-发布订阅模式的作用是什么"><a href="#1-发布订阅模式的作用是什么" class="headerlink" title="1. 发布订阅模式的作用是什么"></a>1. 发布订阅模式的作用是什么</h3><p>两个字——<strong>解耦</strong>。<br>换一个比较高大上的说法：定义了一个一对多的依赖关系，当有关状态发生变更时，则执行相应的更新。<br>实际上，设计模式是为了更好的维护代码。在实现功能方面，把代码全都写在一起是完全没问题的，但是这样的代码一般称之为“屎山”。每更新一个需求，可能就在原来某个判断条件内写一大堆逻辑。极其不利于后期的维护。而发布订阅的作用，就是为了优雅的解决这种需求的，一种设计模式。  </p><h3 id="2-发布订阅模式详解"><a href="#2-发布订阅模式详解" class="headerlink" title="2. 发布订阅模式详解"></a>2. 发布订阅模式详解</h3><p><strong>发布订阅模式需要哪几个步骤？</strong>  </p><ol><li>添加订阅</li><li>取消订阅</li><li>发布订阅</li></ol><p>对于订阅，需要两个参数：一个是订阅的主题，一个是订阅内容发布后需要进行处理的操作。  </p><p>设想这么一个场景：我要用洗衣机洗衣服，有白色的衣服和黑色的衣服，和一个盆。首先，把盆里白色的衣服放到洗衣机里，白色的衣服有外套，衬衫，将白衣服一件一件的放到洗衣机里，然后打开洗衣机。以此类推处理黑色的衣服。  </p><p>对上述场景分析，带入到发布订阅模式中：  </p><ul><li>主题： 白色衣服、黑色衣服  </li><li>操作： 洗衣服</li><li>添加订阅： 将某个颜色的某件衣服放到盆里</li><li>取消订阅： 将某个颜色的<strong>所有</strong>衣服从盆里取出来</li><li>发布订阅： 将盆里的某种颜色的所有衣服，放到洗衣机里洗</li></ul><h3 id="3-实现发布订阅模式"><a href="#3-实现发布订阅模式" class="headerlink" title="3. 实现发布订阅模式"></a>3. 实现发布订阅模式</h3><p>话不多说，第二步的分析，直接上代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">subPub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>list <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//这就是那个盆</span><span class="token punctuation">}</span>subPub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>  constructor<span class="token punctuation">:</span> subPub<span class="token punctuation">,</span>  <span class="token function">subscribe</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//订阅</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//如果之前没有这个类别，新增一个</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将事件触发后需要进行的操作放进去</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">unsubscribe</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//取消订阅</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//删除这个属性，即取消所有内容，将白色衣服全都取出来</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">publish</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">//发布某个主题的订阅内容</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将传入的参数取下来</span>    <span class="token keyword">var</span> fns <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>list<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将某个主题的全部内容取出</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>fns<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//this还是用当前调度中心的this，不然参数都传不过去</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是白衬衫，我被洗了，啊啊啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是白裤子，我被洗了，啊啊啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">fn3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"我是黑黑黑衬衫，我被洗了，啊啊啊"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">subPub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//新建发布订阅对象</span>sub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"wash_white"</span><span class="token punctuation">,</span> fn1<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将白衬衫放到盆里</span>sub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"wash_white"</span><span class="token punctuation">,</span> fn2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将白裤子放到盆里</span>sub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"wash_black"</span><span class="token punctuation">,</span> fn3<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//将黑衬衫放到盆里</span>sub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"wash_white"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//发布订阅的内容，执行相应的操作。  打开洗衣机洗所有的白衣服</span><span class="token comment" spellcheck="true">//我是白衬衫，我被洗了，啊啊啊</span><span class="token comment" spellcheck="true">//我是白裤子，我被洗了，啊啊啊</span>sub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"wash_black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//洗所有的黑衣服</span><span class="token comment" spellcheck="true">//我是黑黑黑衬衫，我被洗了，啊啊啊</span><span class="token comment" spellcheck="true">//也可以取消订阅</span>sub<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token string">"wash_white"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//白衬衫今天约会还要穿，先不洗了吧</span>sub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"wash_white"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//洗所有的白衣服   什么都不会发生</span>sub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"wash_black"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//黑衣服没事</span><span class="token comment" spellcheck="true">//我是黑黑黑衬衫，我被洗了，啊啊啊</span><span class="token comment" spellcheck="true">//也可以在发布主题的时候传参</span><span class="token keyword">function</span> <span class="token function">fn4</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"这个参数是发布的时候传送过来的:--->"</span><span class="token operator">+</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>sub<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token string">"test_args"</span><span class="token punctuation">,</span> fn4<span class="token punctuation">)</span><span class="token punctuation">;</span>sub<span class="token punctuation">.</span><span class="token function">publish</span><span class="token punctuation">(</span><span class="token string">"test_args"</span><span class="token punctuation">,</span> <span class="token string">"我是从发布订阅内部传过来的参数！！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这个参数是发布的时候传送过来的:--->我是从发布订阅内部传过来的参数！！</span></code></pre><p>以上代码，在Chrome控制台亲测有效。</p><h3 id="4-发布订阅模式与观察者模式的区别"><a href="#4-发布订阅模式与观察者模式的区别" class="headerlink" title="4. 发布订阅模式与观察者模式的区别"></a>4. 发布订阅模式与观察者模式的区别</h3><p>看了很多说观察者模式和发布订阅模式是一样的，我觉得，其设计思想是一样的，实际上还是有些许差别。</p><p>先上观察者模式代码:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//所观察的主题</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>observers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//这里只是一个数组，只能有一个主题</span><span class="token punctuation">}</span>Subject<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>  constructor<span class="token punctuation">:</span> Subject<span class="token punctuation">,</span>  <span class="token function">add</span><span class="token punctuation">(</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//添加观察者对象</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>ob<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">remove</span><span class="token punctuation">(</span>ob<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//删除观察者对象</span>    <span class="token keyword">var</span> obs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>obs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>ob<span class="token operator">===</span>obs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//发布消息</span>    <span class="token comment" spellcheck="true">// var args = Array.prototype.slice.call(arguments);</span>    <span class="token keyword">var</span> obs <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>obs<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      obs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">Observer</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//观察者对象</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span>Observer<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>  constructor<span class="token punctuation">:</span> Observer<span class="token punctuation">,</span>  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//接受到notify后，更新的函数</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> sub <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Subject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//新建主题</span><span class="token keyword">var</span> ob1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token string">"lrq"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//新建观察者</span><span class="token keyword">var</span> ob2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token string">"lrq2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> ob3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span><span class="token string">"lrq3"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sub<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ob1<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//主题添加观察者</span>sub<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ob2<span class="token punctuation">)</span><span class="token punctuation">;</span>sub<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ob3<span class="token punctuation">)</span><span class="token punctuation">;</span>sub<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//发送消息</span><span class="token comment" spellcheck="true">// lrq</span><span class="token comment" spellcheck="true">// lrq2</span><span class="token comment" spellcheck="true">// lrq3</span><span class="token comment" spellcheck="true">//也可以取消监听</span><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  sub<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>ob2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第二个观察者不看了</span>  sub<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//lrq</span><span class="token comment" spellcheck="true">//lrq3</span></code></pre><p>以上就是观察者模式的代码，说一下我对两种模式的理解：  </p><ol><li>发布订阅比观察者更灵活一点，发布订阅可以定义多个主题，而观察者就相当于只有一个主题</li><li>发布订阅的执行函数是自己随便写的，观察者模式的执行函数是要定义一个Observer类，在里面封装相应的update方法，创建每个实例时传入不同的参数。</li></ol><hr><p>等到写的bug更多的时候，看问题可能会更透彻吧，现在只是基本会用了这个设计模式。  </p><p>以上。<br>written by LRQ<br>2019.12.5</p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>js中bind详解</title>
      <link href="/2019/12/05/js%E4%B8%AD%E7%9A%84bind%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/12/05/js%E4%B8%AD%E7%9A%84bind%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这两天被问到了call和apply的区别，都回答上来了，然后被问到bind，脑海里是有这个东西，但是一时搜索不出来。今天整理一下具体内容。</p><h2 id="1-js中bind和call和apply"><a href="#1-js中bind和call和apply" class="headerlink" title="1.js中bind和call和apply"></a>1.js中bind和call和apply</h2><p>首先，为什么会有这三个东西?在什么应用场景下会用到呢？举一个在很多博客中见到的例子：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> write <span class="token operator">=</span> document<span class="token punctuation">.</span>write<span class="token punctuation">;</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>代码这样写的意图，是想将document中的write方法抽离出来，在别的地方也可以调用。但问题是</p><ol><li><code>document.write(&quot;aa&quot;)</code>这样写是调用document这个对象中的write方法</li><li><code>write(&quot;hello write&quot;)</code>这样写是调用window中的方法</li><li>window中没有这个方法，就会报错</li><li>归根结底是this没有绑定到相应的对象</li></ol><p>而bind、apply、call的出现，就是解决这个问题的。调用方式都是<code>function.bind(obj)</code>，这种形式，函数内的this即绑定到obj的this。</p><hr><h3 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a>call和apply的区别</h3><p>两者实现的效果是相同的，只是传入的参数不一样。两者都是立即执行。<br>对于call来说，所期望的输入参数应该是<code>function.call(obj,&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)</code><br>对于apply来说，所期望输入的参数应该是<code>function.apply(obj, [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])</code>  </p><hr><h3 id="bind和call、apply的区别"><a href="#bind和call、apply的区别" class="headerlink" title="bind和call、apply的区别"></a>bind和call、apply的区别</h3><p>call和apply，都是立即执行，返回结果的。而bind执行之后，会返回一个函数，留待开发者等待合适的时机自行决定什么时候调用。</p><hr><h3 id="bind的实现"><a href="#bind的实现" class="headerlink" title="bind的实现"></a>bind的实现</h3><p>如何实现一个bind呢？代码如下：</p><pre class=" language-js"><code class="language-js">Function<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>my_bind <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一个参数是绑定的对象，剩下的参数是输入的参数</span>    <span class="token keyword">var</span> self <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//保存调用函数的this</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//返回的是一个函数</span>        <span class="token keyword">var</span> innerArgs <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//第二次传入的参数</span>        <span class="token keyword">var</span> finalArgs <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>innerArgs<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//所有的参数</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> finalArgs<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//使用apply，绑定对象，返回结果</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上。<br>written by LRQ<br>2019.12.4</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>浅拷贝与深拷贝</title>
      <link href="/2019/11/28/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
      <url>/2019/11/28/%E6%B5%85%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B7%B1%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在JS中，复制一个对象有浅拷贝和深拷贝之说。那么浅拷贝和深拷贝有哪些区别呢？在哪些方面会体现呢？</p><hr><h3 id="待复制对象的属性"><a href="#待复制对象的属性" class="headerlink" title="待复制对象的属性"></a>待复制对象的属性</h3><p>JS中的有6种数据类型：字符串，数字，布尔，null，undefined，object。如果一个对象的属性是前5种，那么就没有浅拷贝和深拷贝之分。但是如果待复制的对象中某个属性是对象的话，就会出现浅拷贝和深拷贝的区别了。</p><hr><h3 id="浅拷贝和深拷贝区别"><a href="#浅拷贝和深拷贝区别" class="headerlink" title="浅拷贝和深拷贝区别"></a>浅拷贝和深拷贝区别</h3><p>对象，由引用和对象的内容组成，引用是在内存中的栈内，真正的对象的内容，在内存中是在堆内。  </p><p>而对于对象的复制，如果只是复制了引用，那这就是浅拷贝。假如源对象中有属性为对象的话，源对象A和复制后的对象B，使用同一个引用指向相同的对象C。通过A改变C的内容，B中C的内容也会被修改。反之亦然。  </p><p>如果是深拷贝的话，源对象的属性中有对象的话，目标对象中会生成一个新的对象，而不会共用同一个引用。目标对象会生成一个新的对象，引用和对象的内容，栈和堆中都会分别生成一个新的内容。  </p><hr><h3 id="浅拷贝的方法"><a href="#浅拷贝的方法" class="headerlink" title="浅拷贝的方法"></a>浅拷贝的方法</h3><ol><li>使用Object.assign()，会通过浅拷贝生成一个新的对象。<pre><code>var obj = Object.assign({}, src);</code></pre></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>     obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><hr><h3 id="深拷贝的方法"><a href="#深拷贝的方法" class="headerlink" title="深拷贝的方法"></a>深拷贝的方法</h3><ol><li><p>将对象转换为json字符串，再反解析回来。但是对于对象中的function对象、正则表达式对象无法复制。而且会丢失对象的原型链，新生成的对象的constructor都会变为object。  </p><pre><code>var src = { name: &quot;lrq&quot;, age: 18, hobbies: {     sing: &quot;songs&quot;,     play: &quot;football&quot; }}var obj = JSON.parse(JSON.stringify(src))</code></pre></li><li><p>递归操作,可以将源对象中的对象和数组进行复制</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">var</span> obj <span class="token operator">=</span> src<span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> src<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>src<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">typeof</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">.</span>constructor<span class="token operator">===</span>Array<span class="token operator">?</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>           obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> src<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ol><hr><h2 id="重大更新"><a href="#重大更新" class="headerlink" title="重大更新"></a>重大更新</h2><p>找到一种新的便捷方法来应对obj是数组或者对象，同时也对正则和日期对象有了处理。<br>如下：  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> map<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>obj<span class="token operator">===</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//是正则对象则直接new一个正则对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//是Date对象则直接new一个Date对象</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//基本类型值则直接返回</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//如果map里面有，则直接返回，防止自身引用无限调用</span>    <span class="token keyword">let</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//管你是数组还是对象，直接上构造函数</span>    map<span class="token punctuation">.</span><span class="token keyword">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> ret<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">//放入map中</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ret<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> map<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//对每个属性都进行深拷贝</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> ret<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>二叉树的各种遍历</title>
      <link href="/2019/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86/"/>
      <url>/2019/10/22/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%90%84%E7%A7%8D%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近在刷牛客网的题，刷到一个二叉树的题。记得有一次别人问我让我写一个简单的二叉树遍历，广度优先，深度优先的。。我说不太会，对方就说leetcode上基本一半的题都是这种BFS和DFS的。。当时根本没有涉及过这一块，觉得自己太菜。今天既然刷到这道题，就把这一块都好好总结一下。  </p><hr><p>这是基本的树结构，先定义这么一个类。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">TreeNode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="https://github.com/LRQLRQ/picture/blob/master/二叉树.png?raw=true" alt="avatar"></p><p>前序排列: 1 2 4 5 7 8 3 6<br>中序排列: 4 2 7 5 8 1 3 6<br>后序排列: 4 7 8 5 2 6 3 1  </p><h3 id="前序排列"><a href="#前序排列" class="headerlink" title="前序排列"></a>前序排列</h3><p>前序排列是按照 根节点-&gt;左节点-&gt;右节点的顺序，来遍历整个二叉树。</p><p>先使用递归的方法来写前序遍历,每到一个非空的节点，就对当前节点的值进行操作，然后找左节点的值，当左节点走到尽头时，该函数就结束，接着找右节点。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//递归的方法写前序遍历，根节点->左节点->右节点</span><span class="token keyword">var</span> preOrderTraverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//直接在这里对值进行操作</span>        <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">preOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>用栈的方式写前序排列，需要维护一个栈，将每个可能分叉的树节点都push到栈里，然后一直遍历左侧子节点。当走不下去的时候，就返回上一步，找到上一个节点的右节点，把值取出来，但下一步还是找这个新的节点的左节点，直到走到尽头。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//用栈来写前序遍历</span><span class="token keyword">var</span> preOrderTraverse1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> pNode <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pNode<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pNode<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">let</span> temp <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> temp<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>中序遍历和前序遍历不一样的地方是顺序，左节点-&gt;根节点-&gt;右节点。<br>在写递归的时候，可以发现与前序遍历唯一不一样的地方就是调用值的顺序不同。是在最左侧的树到了尽头之后，再对值进行操作。所以这是一个典型的深度优先搜索。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//递归的方法写中序遍历，左节点->根节点->右节点</span><span class="token keyword">var</span> inOrderTraverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">inOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">inOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//用栈的方法写中序排序，左节点->根节点->右节点</span><span class="token keyword">var</span> inOrderTraverse1 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> pNode <span class="token operator">=</span> root<span class="token punctuation">;</span>    <span class="token keyword">let</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>pNode<span class="token operator">!=</span><span class="token keyword">null</span> <span class="token operator">||</span> stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pNode<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>left<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//走到宇宙的尽头，当然是左尽头</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            pNode <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//将“当前”尽头的节点弹出栈</span>            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>            pNode <span class="token operator">=</span> pNode<span class="token punctuation">.</span>right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>后序遍历与之前的区别，就是取值是在遍历完左右节点之后。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//递归的方法写后序遍历，左节点->右节点->根节点</span><span class="token keyword">var</span> postOrderTraverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>root<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">postOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">postOrderTraverse</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>广度优先需要维护一个队列，先进先出。每次遇到一个非空值，就把当前值取出来。然后依次查看左右子节点是否非空，非空就从队尾加入队列。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//层次遍历二叉树——广度优先搜索的实现</span><span class="token keyword">var</span> levelTraverse <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//这是个队列</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> pNode <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//是队列，先进先出，所以从头部取出来</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//将当前的值使用</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>left<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>    arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>right<span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span>   arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>pNode<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>防抖节流函数理解</title>
      <link href="/2019/10/18/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%90%86%E8%A7%A3/"/>
      <url>/2019/10/18/%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>今天在掘金看到一篇文章，想到以前被问到防抖节流函数，让手写一个，当时听都没听过，十分惭愧。当时事后恶补了一下，感觉好像是理解了，实际上闭包都不是十分掌握。最近把js基础又看了一遍，今天无意看到这篇文章，就把自己的理解写一下。  </p><h3 id="防抖函数：debounce"><a href="#防抖函数：debounce" class="headerlink" title="防抖函数：debounce"></a>防抖函数：debounce</h3><h4 id="目的："><a href="#目的：" class="headerlink" title="目的："></a>目的：</h4><p>限制某一事件发生太快，可能是抖动产生才发生这么多次事件，来防止抖动，只运行一次。</p><h4 id="实例场景："><a href="#实例场景：" class="headerlink" title="实例场景："></a>实例场景：</h4><p>比如说百度的输入框，在输入内容后可能就会直接进行搜索，这里监听输入框的改变事件，当内容发生变化时，就发送ajax请求到后端，调用结果。但是如果用户输入过快，变化次数过多，比如说1s打了5个字，那就没有必要发送5个请求，只需要5个字打完之后，等一段时间，比如500ms，发现输入框还是没有变化，那就认为输入完毕，发送请求。</p><hr><p>这个限制条件就是：<br>一段时间内没有触发这个事件。写了函数如下，关键点如下。</p><ol><li>实际上是将timer作为闭包，一个私有变量。首先第一次调用这个debounce函数，将触发的事件和间隔事件设置好，会返回一个内部函数，运行那个返回的fn1函数即可。再也没有人能访问函数内的timer变量了，这个timer变量就是闭包。</li><li>每当事件发生变化时，运行这个fn1函数，首先会设置一个定时器，准备运行那个期望的回调函数fn，假如在间隔时间内再次触发了事件，进入了函数，则清除掉定时器timer，重新设置新的timer。直到满足间隔时间，运行时间结束后，由定时器内部的回调清除掉timer。</li></ol><hr><p>节流和防抖差不多，看到一个有意思的理解：<br><strong>防抖</strong>：不冷静的决定，最后一次才能一锤定音。<br><strong>节流</strong>：技能的cd，要间隔一段时间才能再次使用。<br>下面是防抖和节流的代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> debounce <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token operator">=</span><span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>        timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>            fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn1 <span class="token operator">=</span> <span class="token function">debounce</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"I am here!"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">fn1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//时间戳版本</span><span class="token keyword">var</span> throttle <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> lastTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> now <span class="token operator">=</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>now <span class="token operator">-</span> lastTime <span class="token operator">></span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>            fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>            lastTime <span class="token operator">=</span> Data<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> fn2 <span class="token operator">=</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"This is 节流函数"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">fn2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//定时器版本，但是要等定时器设置的时间才可以运行第一次</span><span class="token keyword">var</span> throttle2 <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> timer<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">let</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">let</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>            timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>                        fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>                        timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上就是我对于防抖和节流的理解了，今晚想要试着跑第一次半马~</p><p>2019.10.18  written by: LRQ</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习css的flex布局</title>
      <link href="/2019/10/08/%E5%AD%A6%E4%B9%A0css%E7%9A%84flex%E5%B8%83%E5%B1%80/"/>
      <url>/2019/10/08/%E5%AD%A6%E4%B9%A0css%E7%9A%84flex%E5%B8%83%E5%B1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天看了阮一峰的博客，算是差不多了解了flex弹性布局。手过一遍，把课后习题也顺带做了一做，感觉差不多会用了。<br>感觉最常用的应该就是<code>justify-content</code>主轴方向的布局；和<code>align-items</code>交叉轴方向的布局。灵活配合使用，应该布局问题就比较好解决了。</p><h3 id="Flex是什么"><a href="#Flex是什么" class="headerlink" title="Flex是什么"></a>Flex是什么</h3><p>Flex是Flex Box的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。<br>任何一个容器都可以指定为Flex。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>行内元素也可以使用Flex布局。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">display</span><span class="token punctuation">:</span> inline-flex<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>ATTENTION</strong>：设为Flex之后，子元素的<code>float</code>、<code>clear</code>、和<code>vertical-align</code>属性将失效。  </p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>采用Flex布局的元素，称为Flex容器。它的所有子元素自动成为容器成员，称为Flex项目(flex items).<br><img src="https://github.com/LRQLRQ/picture/blob/master/flex图解.png?raw=true" alt="avatar"></p><p>容器默认有两根轴，水平的主轴(main axis)和垂直的交叉轴(cross axis)。主轴的开始位置(与边框的交叉点)叫做<code>main start</code>，结束位置叫做<code>main end</code>；交叉轴的开始位置叫做<code>cross start</code>，结束位置叫做<code>cross end</code>。项目默认沿着主轴排列，单个项目占据的主轴空间叫做<code>main size</code>，占据的交叉轴空间叫做<code>cross size</code>。  </p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><p>容器主要设置以下6个属性:</p><ul><li>flex-direction</li><li>flex-wrap</li><li>flex-flow</li><li>justify-content</li><li>align-items</li><li>align-content</li></ul><hr><h4 id="1-flex-direction属性"><a href="#1-flex-direction属性" class="headerlink" title="1.flex-direction属性"></a>1.flex-direction属性</h4><p>这个属性决定主轴的方向，即项目排列的方向。有以下四种选择，顾名思义。</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">flex-direction</span><span class="token punctuation">:</span> row | row-reverse | column | column-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="2-flex-wrap属性"><a href="#2-flex-wrap属性" class="headerlink" title="2.flex-wrap属性"></a>2.flex-wrap属性</h4><p>默认情况下，项目都排在一条线上，(又称轴线)，如果一条轴线排不下该如何换行。<br>它可能取三个值:</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">flex-wrap</span><span class="token punctuation">:</span> nowrap | wrap | wrap-reverse<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ol><li>nowrap(默认) 不换行<br>虽然项目不会换行，但是会被压缩到一行。不会保持原来的宽度值。  </li><li>wrap:换行，第一行在上方</li><li>wrqp-reverse: 换行，第一行在下方</li></ol><h3 id="3-flex-flow"><a href="#3-flex-flow" class="headerlink" title="3.flex-flow"></a>3.flex-flow</h3><p>这个属性是<code>flex-direction</code>属性和<code>flex-wrap</code>属性的简写形式。默认值为<code>row nowrap</code>。</p><h4 id="4-justify-content属性-重点"><a href="#4-justify-content属性-重点" class="headerlink" title="4.justify-content属性(重点)"></a>4.justify-content属性(重点)</h4><p><code>justify-content</code>属性定义了项目在主轴上的对齐方式。  </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>它可能取5个值，具体对齐方式与主轴的方向有关， 假设主轴方向为从左到右。  </p><ul><li>flex-start(默认值): 左对齐</li><li>flex-end: 右对齐</li><li>center: 居中</li><li>space-between: 两端对齐，项目之间的间隔都相等</li><li>space-around: 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。  </li></ul><h4 id="5-align-items属性"><a href="#5-align-items属性" class="headerlink" title="5.align-items属性"></a>5.align-items属性</h4><p>此属性定义了项目在交叉轴上如何对齐。  </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>它可能取5个值，具体的对齐方式与交叉轴的方向有关，假设交叉轴从上到下。</p><ul><li>flex-start: 交叉轴的起点对齐。</li><li>flex-end: 交叉轴的终点对齐。</li><li>center: 交叉轴的中点对齐。</li><li>baseline: 项目的第一行文字的基线对齐。</li><li>stretch(默认值): 如果项目未设置高度或者设为auto，将占满整个容器的高度，</li></ul><h4 id="6-align-content属性"><a href="#6-align-content属性" class="headerlink" title="6.align-content属性"></a>6.align-content属性</h4><p><code>align-content</code>属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。  </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span> </span><span class="token punctuation">{</span>    <span class="token property">align-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个属性可能取6个值:  </p><ul><li>flex-start：与交叉轴的起点对齐。</li><li>flex-end：与交叉轴的终点对齐。</li><li>center：与交叉轴的中点对齐。</li><li>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。</li><li>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。</li><li>stretch（默认值）：轴线占满整个交叉轴。</li></ul><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><p>有6个属性值可以设置在项目上。</p><ul><li>order</li><li>flex-grow</li><li>flex-shrink</li><li>flex-basis</li><li>flex</li><li>align-self</li></ul><hr><h4 id="1-order属性"><a href="#1-order属性" class="headerlink" title="1.order属性"></a>1.order属性</h4><p>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。<br>数值相同的话，就按照在html中写的顺序进行排列。<br>如果将一个class中的item的order都改变的话，无论html中的书写顺序是什么，所有该类的item都会被提前或是延后。  </p><h4 id="2-flex-grow属性"><a href="#2-flex-grow属性" class="headerlink" title="2.flex-grow属性"></a>2.flex-grow属性</h4><p>这个属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。<br>如果所有项目的<code>flex-grow</code>属性都为1，则它们将等分剩余空间(如果还有剩余空间的话)。如果一个项目的<code>flex-grow</code>属性为2，其他项目都为1，则前者占据的剩余空间将比其他项目多一倍。  </p><h4 id="3-flex-shrink属性"><a href="#3-flex-shrink属性" class="headerlink" title="3.flex-shrink属性"></a>3.flex-shrink属性</h4><p>该属性定义了项目的缩小比例，默认为1.即如果空间不足，该项目将缩小。<br>如果一个项目的<code>flex-shrink</code>属性为0，其他项目都为1，则空间不足时，前者不缩小。<br><img src="https://github.com/LRQLRQ/picture/blob/master/flex-shrink.png?raw=true" alt="avatar"></p><p>如图，本来蓝色是400x400的图片，黄色是200x200的图片。设置蓝色的style class中的<code>flex-shrink</code>为1之后，呈现如图所示情况。  </p><h4 id="4-flex-basis属性"><a href="#4-flex-basis属性" class="headerlink" title="4.flex-basis属性"></a>4.flex-basis属性</h4><p><code>flex-basis</code>属性定义了在分配多余空间之前，项目占据的主轴空间(main size)。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。<br>它可以设置跟<code>width</code>或<code>height</code>属性一样的值，则项目将占据固定空间。  </p><h4 id="5-flex属性"><a href="#5-flex属性" class="headerlink" title="5.flex属性"></a>5.flex属性</h4><p><code>flex</code>属性是<code>flex-grow</code>，<code>flex-shrink</code>和<code>flex-basis</code>的简写，默认值是 <code>0 1 auto</code>。后两个属性可选。<br>该属性有两个快捷值: auto (<code>1 1 auto</code>),和none(<code>0 0 auto</code>).<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。  </p><h4 id="6-align-self"><a href="#6-align-self" class="headerlink" title="6.align-self"></a>6.align-self</h4><p><code>align-self</code>属性允许单个项目有与其他项目不一样的对齐方式，可覆盖<code>align-items</code>属性，默认值为<code>auto</code>，表示继承父元素的<code>align-items</code>属性，如果没有父元素，则等同于<code>stretch</code>.  </p>]]></content>
      
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编写shell脚本并添加为快捷命令</title>
      <link href="/2019/09/24/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%B8%BA%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/09/24/%E7%BC%96%E5%86%99shell%E8%84%9A%E6%9C%AC%E5%B9%B6%E6%B7%BB%E5%8A%A0%E4%B8%BA%E5%BF%AB%E6%8D%B7%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天想在mac上写一个简单的脚本，直接输入简单的命令就能跳转到我的工作目录。搞了大概半个小时终于搞定了。先贴代码，然后说几个关键点。</p><pre><code>#!/bin/bashecho &quot;$1&quot;if [ &quot;$1&quot; = &quot;blog&quot; ]; then    echo &quot;开始写博客!&quot;    cd ~/code/stuff/LRQLRQ.github.io/lrq/source/_posts/elif [ &quot;$1&quot; = &quot;book&quot; ]; then    echo &quot;看书!&quot;    cd ~/Documents/研究生涯/books/else    echo &quot;wu&quot;fi</code></pre><p>这就是代码，说几个写shell常见的点。</p><ol><li><code>$1</code>表示输入的第一个参数</li><li>在shell中用=和==不一样，刚开始用<code>==</code>一直不行，在[]中进行字符串比较的时候又是一样的。玄学问题。</li><li>shell中的if要用fi结尾</li></ol><p>因为使用的是zsh脚本，然后在home目录的隐藏文件添加一个alias，设置一个新的命令。如下:<br><code>alias lrq=&quot;source ~/code/shell/goto.sh&quot;</code>  </p><p>此外，直接<code>./goto.sh</code>运行脚本，会fork一个子shell，子shell会共享父shell的环境变量，但是不会将参数传进来，所以需要使用<code>. ./goto.sh</code>或者使用<code>source goto.sh</code>，这样就会直接在父shell中运行脚本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写的贪吃蛇</title>
      <link href="/2019/09/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/"/>
      <url>/2019/09/23/%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%86%99%E8%B4%AA%E5%90%83%E8%9B%87/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起"><a href="#前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起" class="headerlink" title="前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起~"></a>前两天在论坛上看到有人写了贪吃蛇，联机对战，自己也想学着写一个贪吃蛇，发布到网站上。先从单机版的贪吃蛇写起~</h2><p>首先介绍一下整体的思路，整个地图是一个canvas元素，这个canvas就相当于是画布。在画布上画蛇就是在canvas内的规定好的位置画矩形，边写边想，想到哪里写到哪里。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><hr><h4 id="canvas介绍"><a href="#canvas介绍" class="headerlink" title="canvas介绍"></a>canvas介绍</h4><p>首先get到页面中的canvas元素，<code>var canvas = documents.getElementById(&#39;canvas&#39;)</code>,此时canvas在js中就相当于是画布，然后再得到画笔，<code>var content = canvas.getContext(&#39;2d&#39;)</code>，之后再操作<code>content</code>的方法，就可以得到相应的图形。这里就用到了rect方法，画矩形。</p><hr><h4 id="蛇的思路"><a href="#蛇的思路" class="headerlink" title="蛇的思路"></a>蛇的思路</h4><p>在这个代码中，学到了真正的面向对象的写代码方式。<br>创建一个数组，数组中放rect()对象。蛇头的那个rect对象在数组的第一位。<br>这里介绍一下蛇移动的思路吧。</p><ol><li>蛇每移动一次，就使用splice方法，在数组中第二个位置中插入一个和头部一模一样的rect</li><li>然后判断是不是吃到了食物，如果吃到了食物，则生成新的食物，蛇头向当前的方向移动一个单位</li><li>如果没有吃到食物，就把蛇尾的元素pop掉，然后蛇头向当前方向移动一个单位。</li><li>以上是蛇的数组的操作方式，然后将蛇在画布中展示出来。使用canvas对象的draw方法，用一个for循环，将方块画出来。</li></ol><h4 id="学到的一些小东西"><a href="#学到的一些小东西" class="headerlink" title="学到的一些小东西"></a>学到的一些小东西</h4><hr><p>在js中，有一个东西叫做定时器，和单片机里面的定时器几乎是同样的东西。相当于定一个时间间隔，每过多少时间，就执行一次函数里面的代码。<br>比如：</p><pre><code>var timer = setInterval(function(){    context.clearRect(0, 0, canvas.width, canvas.height);  //清除已经画的蛇    food.draw();    //画出食物矩形    snake.move();    //蛇身进行移动，相当于在脑海中想象蛇应该在的位置    snake.draw();    //调用draw函数，把蛇的矩形画到画布上},100)</code></pre><hr><h2 id="在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。"><a href="#在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。" class="headerlink" title="在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。"></a>在随机生成食物的时候，想要生成在【0-480】之内的，20倍数的随机数，可以先生成一个【0-24】内的随机整数，然后再给这个整数乘以20，就可以达到效果了。</h2><p>判断蛇移动方向，需要设置按键监听事件。这个也是类似定时器一样，在后台自动就监听，感觉类似于外部中断。<br>具体代码如下：</p><pre><code>document.onkeydown = function(e){    var ev = e || window.event;   //防止事件冲突    switch(ev.keyCode){        //判断按键的键值是什么        case 37:    //按键为左            do()...;            break;        case 38:    //上            do()...;            break;        case 39:    //右            do()...;            break;        case 40:    //下            do()...;                break;        default:            break;    }}</code></pre><hr><h4 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h4><p>这次小项目只是一个单机版的贪吃蛇，锻炼了js的能力，学习到了js的很多基础知识，已经发布到github上了，还加了背景音乐，配了图，有机会可以去玩一玩。嘿嘿~~<br><a href="https://lrqwriting.top/snakeGame" target="_blank" rel="noopener">https://lrqwriting.top/snakeGame</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>校园网的无限流量</title>
      <link href="/2019/09/23/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2019/09/23/%E6%A0%A1%E5%9B%AD%E7%BD%91%E6%97%A0%E9%99%90%E6%B5%81%E9%87%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="无限流量归纳"><a href="#无限流量归纳" class="headerlink" title="无限流量归纳"></a>无限流量归纳</h1><p>最近学校的无限流量套餐试验结束了，原先的1分钱100M带宽无线流量套餐，现在涨到50块了，前天晚上听到室友找到了一种校园网无线流量的方法，昨天就试了试，虽然还没成功，但是稍微了解了一下原理，还有一些引申。勒石以记，待有缘之时再返以续之。</p><hr><h2 id="1-UDP的53、67、68端口转发，绕过校园网认证，来免流量。"><a href="#1-UDP的53、67、68端口转发，绕过校园网认证，来免流量。" class="headerlink" title="1. UDP的53、67、68端口转发，绕过校园网认证，来免流量。"></a>1. UDP的53、67、68端口转发，绕过校园网认证，来免流量。</h2><p>准备材料：一台公网的服务器<br>步骤：</p><ol><li>在服务器上搭建SoftEther VPN Server</li><li>在windows上下载SE-VPN Server Manager，连接到搭建好的服务器。</li><li>通过Mananger这个软件来添加用户，并启用SecureNAT功能。</li><li>改变OpenVPN监听的端口，默认是1193，改为53或67或68（不是都可以用，我测试53和67可用）。</li><li>在Manager软件里生成OpenVpn Client的配置文件。</li><li>在windows下载OpenVpn，把第5步生成的配置文件放到安装目录的config里面，并使用第3步添加的用户登录，来连接到服务器上。</li></ol><hr><p>原理介绍：<br>在连接到某个需要Web认证的热点之前，我们已经有了一个内网IP，此时，如果我们访问某个HTTP网站，网关会对这个HTTP响应报文劫持并篡改，302重定向到让我们认证的页面（就是登录让你输入账号密码的网页）。</p><p>网关（交换机）都默认放行DHCP和DNS的报文，也就是UDP53和UDP67，所以把数据通过53端口传到服务器上，服务器将返回的网页内容再通过53端口传给客户端，实际上都在费流量，只是没有计费。</p><p>参考的博客：</p><p>UDP 53/67/68 端口转发 绕过校园网认证、免流<br><code>https://blog.csdn.net/sinat_38245860/article/details/78669584</code></p><p>UDP 53免费上网、DNS隧道经验谈<code>https://blog.csdn.net/qq_42433224/article/details/82632711</code></p><p>交换机 配置WEB认证的功能原理是什么</p><p><code>http://www.ruijie.com.cn/fw/wt/36503/</code></p><hr>]]></content>
      
      
      
        <tags>
            
            <tag> vpn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>开发小程序！</title>
      <link href="/2019/09/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91/"/>
      <url>/2019/09/23/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>JSON文件在小程序代码中扮演者静态配置的作用，在小程序运行之前就决定了小程序的一些表现。需要注意的是小程序是无法再运行过程中去动态更新JSON配置文件而发生对应变化的。</li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>学习Webpack</title>
      <link href="/2019/09/23/%E5%AD%A6%E4%B9%A0webpack/"/>
      <url>/2019/09/23/%E5%AD%A6%E4%B9%A0webpack/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h1><ul><li>Entry:入口</li><li>Output:输出</li><li>Loaders:处理其他类型（不是js）的文件</li><li>Plugins:插件，其他的功能</li></ul><ul><li>Entyr:<strong>代码的入口</strong>，说自己import了什么，require了什么。可以在这里直接或者间接找到依赖。<strong>打包的入口</strong>,可以是一个或者是多个。如下代码所示：<pre><code>module.export = {  entry: {      index: [&#39;index.js&#39;, &#39;&lt;a href=&quot;&quot;&gt;&lt;/a&gt;p.js&#39;],      vender: &#39;vender.js&#39;  }}</code></pre></li><li>Output:打包的输出。webpack会提供给我们一下变量，比如name、hash ，代码中的name就分别代表entry中的index和vendor,hash是打包中出现的独一无二的码<pre><code>modules.exports = {  entry: {      index: &#39;index.js&#39;,      vendor: &#39;vendor.js&#39;  },  output: {      filename: &#39;[name].min.[hash:5].js&#39;  },}</code></pre></li><li>Loaders，用来处理其他文件，将文件转化为模块。可以将css文件变为js中的一个模块，变为依赖引入进来。如下代码，在module中加入rules，rules是一个数组，也就是可以设置很多loaders，设置它的loader是css-loader。<br>常用的loader：<strong>编译相关</strong>：babel-loader、ts-loader。<strong>样式相关</strong>：style-loader、css-loader…<strong>文件相关</strong>：file-loader、url-loader<pre><code>module.exports = {  module: {      rules: [          {              test: /\.css$/,              use: &#39;css-loader&#39;          }      ]  }}</code></pre></li><li><p>Plugins的作用<strong>参与打包整个过程，打包优化和压缩，配置编译时的变量。</strong><br>常用的Plugins有<strong>优化相关的</strong>：CommonsChunkPlugin，UglifyJsPlugin，<strong>功能相关的</strong>：HtmlWebpackPlugin、HotModuleReplacementPlugin</p><pre><code>const webpack = require(&#39;webpack&#39;);module.exports = {  plugins: [      new webpack.optimize.UglifyJsPlugin()  ]}</code></pre></li><li><p>名词<br>Chunk：代码块<br>Bundle：已经被打包后的代码<br>Module：模块。通过loaders处理后，把文件转变为模块，把图片、css处理，变为模块。</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习VUE</title>
      <link href="/2019/09/23/%E5%AD%A6%E4%B9%A0VUE/"/>
      <url>/2019/09/23/%E5%AD%A6%E4%B9%A0VUE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2018.10.15  开始学习vue</p><p>Vue.js（读音 /vjuː/, 类似于 view） 是一套构建用户界面的渐进式框架。</p><p>Vue 只关注视图层， 采用自底向上增量开发的设计。</p><p>Vue 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。</p><p>第一段vue代码示例</p><pre><code>&lt;div id=&quot;vue_det&quot;&gt;    &lt;h1&gt;site : {{site}}&lt;/h1&gt;    &lt;h1&gt;url : {{url}}&lt;/h1&gt;    &lt;h1&gt;{{details()}}&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;    var vm = new Vue({        el: &#39;#vue_det&#39;,        data: {            site: &quot;菜鸟教程&quot;,            url: &quot;www.runoob.com&quot;,            alexa: &quot;10000&quot;        },        methods: {            details: function() {                return  this.site + &quot; - 学的不仅是技术，更是梦想！&quot;;            }        }    })&lt;/script&gt;</code></pre><p>可以看到在 Vue 构造器中有一个el 参数，它是 DOM 元素中的 id。在上面实例中 id 为 vue_det，在 div 元素中：</p><pre><code>&lt;div id = &quot;vue_det&quot;&gt;&lt;/div&gt;</code></pre><h4 id="这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。"><a href="#这意味着我们接下来的改动全部在以上指定的-div-内，div-外部不受影响。" class="headerlink" title="这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。"></a><b>这意味着我们接下来的改动全部在以上指定的 div 内，div 外部不受影响。</b></h4><p>接下来我们看看如何定义数据对象。</p><p>data 用于定义属性，实例中有三个属性分别为：site、url、alexa。</p><p>methods 用于定义的函数，可以通过 return 来返回函数值。</p><p>用于输出对象属性和函数返回值。</p><h4 id="当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化"><a href="#当一个-Vue-实例被创建时，它向-Vue-的响应式系统中加入了其-data-对象中能找到的所有的属性。当这些属性的值发生改变时，html-视图将也会产生相应的变化" class="headerlink" title="当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化"></a><b>当一个 Vue 实例被创建时，它向 Vue 的响应式系统中加入了其 data 对象中能找到的所有的属性。当这些属性的值发生改变时，html 视图将也会产生相应的变化</b></h4><pre><code>&lt;div id=&quot;vue_det&quot;&gt;    &lt;h1&gt;site : {{site}}&lt;/h1&gt;    &lt;h1&gt;url : {{url}}&lt;/h1&gt;    &lt;h1&gt;Alexa : {{alexa}}&lt;/h1&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot;&gt;// 我们的数据对象var data = { site: &quot;菜鸟教程&quot;, url: &quot;www.runoob.com&quot;, alexa: 10000}var vm = new Vue({    el: &#39;#vue_det&#39;,    data: data})// 它们引用相同的对象！document.write(vm.site === data.site) // truedocument.write(&quot;&lt;br&gt;&quot;)// 设置属性也会影响到原始数据vm.site = &quot;Runoob&quot;document.write(data.site + &quot;&lt;br&gt;&quot;) // Runoob// ……反之亦然data.alexa = 1234document.write(vm.alexa) // 1234&lt;/script&gt;</code></pre><h2 id="Vue-js-模板语法"><a href="#Vue-js-模板语法" class="headerlink" title="Vue.js 模板语法"></a>Vue.js 模板语法</h2><p>Vue.js 使用了基于 HTML 的模版语法，允许开发者声明式地将 DOM 绑定至底层 Vue 实例的数据。</p><p>Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。</p><p>结合响应系统，在应用状态改变时， Vue 能够智能地计算出重新渲染组件的最小代价并应用到 DOM 操作上。</p><ol><li>插值<br><b>文本</b><br>数据绑定最常见的形式就是使用<pre><code>{{...}}（双大括号）</code></pre>的文本插值：</li></ol><pre><code>&lt;div id=&quot;app&quot;&gt;  &lt;p&gt;{{ message }}&lt;/p&gt;&lt;/div&gt;</code></pre><p><b>Html</b><br>使用 v-html 指令用于输出 html 代码：</p><h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a><b>指令</b></h4><p>指令是带有 v- 前缀的特殊属性。</p><p>指令用于在表达式的值改变时，将某些行为应用到 DOM 上。</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p v-if=&quot;seen&quot;&gt;现在你看到我了&lt;/p&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    seen: true  }})&lt;/script&gt;</code></pre><p>新建一个vue对象，用el名绑定div中的id，那么在这个id为xxx的div块中，就可以使用其元素相应的数据。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>参数在指令后以冒号指明。例如， v-bind 指令被用来响应地更新 HTML 属性</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;pre&gt;&lt;a v-bind:href=&quot;url&quot;&gt;菜鸟教程&lt;/a&gt;&lt;/pre&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    url: &#39;http://www.runoob.com&#39;  }})&lt;/script&gt;</code></pre><h4 id="用户输入"><a href="#用户输入" class="headerlink" title="用户输入"></a>用户输入</h4><p>在 input 输入框中我们可以使用 v-model 指令来实现双向数据绑定：</p><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{ message }}&lt;/p&gt;    &lt;input v-model=&quot;message&quot;&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    message: &#39;Runoob!&#39;  }})&lt;/script&gt;</code></pre><p>v-model 指令用来在 input、select、text、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。</p><p>按钮的事件我们可以使用 v-on 监听事件，并对用户的输入进行响应。</p><p>Vue.js 允许你自定义过滤器，被用作一些常见的文本格式化。由”管道符”指示, 格式如下：</p><pre><code>&lt;!-- 在两个大括号中 --&gt;{{ message | capitalize }}&lt;!-- 在 v-bind 指令中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;&lt;!-- 在两个大括号中 --&gt;{{ message | capitalize }}&lt;!-- 在 v-bind 指令中 --&gt;&lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt;</code></pre><p>过滤器函数接受表达式的值作为第一个参数。</p><p>以下实例对输入的字符串第一个字母转为大写：</p><pre><code>&lt;div id=&quot;app&quot;&gt;  {{ message | capitalize }}&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    message: &#39;runoob&#39;  },  filters: {    capitalize: function (value) {      if (!value) return &#39;&#39;      value = value.toString()      return value.charAt(0).toUpperCase() + value.slice(1)    }  }})&lt;/script&gt;</code></pre><h3 id="缩写"><a href="#缩写" class="headerlink" title="缩写"></a>缩写</h3><h4 id="v-bind-缩写"><a href="#v-bind-缩写" class="headerlink" title="v-bind 缩写"></a>v-bind 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt;</code></pre><h4 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind"></a>v-bind</h4><p>操作元素的 class 列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以我们可以用 v-bind 处理它们：只需要通过表达式计算出字符串结果即可。不过，字符串拼接麻烦且易错。因此，在将 v-bind 用于 class 和 style 时，Vue.js 做了专门的增强。表达式结果的类型除了字符串之外，还可以是对象或数组。</p><h4 id="v-on-缩写"><a href="#v-on-缩写" class="headerlink" title="v-on 缩写"></a>v-on 缩写</h4><pre><code>&lt;!-- 完整语法 --&gt;&lt;a v-on:click=&quot;doSomething&quot;&gt;&lt;/a&gt;&lt;!-- 缩写 --&gt;&lt;a @click=&quot;doSomething&quot;&gt;&lt;/a&gt;</code></pre><h3 id="Vue-js-条件与循环"><a href="#Vue-js-条件与循环" class="headerlink" title="Vue.js 条件与循环"></a>Vue.js 条件与循环</h3><pre><code>&lt;div id=&quot;app&quot;&gt;    &lt;div v-if=&quot;type === &#39;A&#39;&quot;&gt;      A    &lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;B&#39;&quot;&gt;      B    &lt;/div&gt;    &lt;div v-else-if=&quot;type === &#39;C&#39;&quot;&gt;      C    &lt;/div&gt;    &lt;div v-else&gt;      Not A/B/C    &lt;/div&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    type: &#39;C&#39;  }})&lt;/script&gt;</code></pre><h4 id="v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后"><a href="#v-else-、v-else-if-必须跟在-v-if-或者-v-else-if之后" class="headerlink" title="v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后"></a>v-else 、v-else-if 必须跟在 v-if 或者 v-else-if之后</h4><h4 id="我们也可以使用-v-show-指令来根据条件展示元素："><a href="#我们也可以使用-v-show-指令来根据条件展示元素：" class="headerlink" title="我们也可以使用 v-show 指令来根据条件展示元素："></a>我们也可以使用 v-show 指令来根据条件展示元素：</h4><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;    &lt;title&gt;Vue 测试实例 - 菜鸟教程(runoob.com)&lt;/title&gt;    &lt;script src=&quot;https://cdn.staticfile.org/vue/2.2.2/vue.min.js&quot;&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=&quot;app&quot;&gt;    &lt;h1 v-show=&quot;ok&quot;&gt;Hello!&lt;/h1&gt;&lt;/div&gt;&lt;script&gt;new Vue({  el: &#39;#app&#39;,  data: {    ok: true  }})&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h4 id="vue中的watch用法"><a href="#vue中的watch用法" class="headerlink" title="vue中的watch用法"></a>vue中的watch用法</h4><p>watch用来监听data中数据的变化，如果发生了变化，则进行操作。</p><pre><code>handler(newName,oldName){    this.fullName = newName + &#39;&#39; + this.lastName;},immediate: true</code></pre><p>以上代码，可以在一开始改变firstName的时候，就进行监听</p><p>此外，watch还有一个deep属性，默认值是<code>false</code>，代表是否深度监听。比如<code>data</code>里面有别的属性，则当属性改变时候，一般情况是监听不到的。只有加了<code>deep:true</code>，才会监听到属性值的改变。</p>]]></content>
      
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习JavaScript</title>
      <link href="/2019/09/23/%E5%AD%A6%E4%B9%A0JavaScript/"/>
      <url>/2019/09/23/%E5%AD%A6%E4%B9%A0JavaScript/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-这是我第一天学习JavaScript"><a href="#1-这是我第一天学习JavaScript" class="headerlink" title="1.这是我第一天学习JavaScript"></a>1.这是我第一天学习JavaScript</h1><p><em>斜体</em><br><strong>粗体</strong><br><del>好吗？</del></p><blockquote><p>这是引用<br>sss</p></blockquote><pre><code>print(&quot;hello!&quot;);return 0;</code></pre><hr><p>##1.为什么学习 JavaScript?##<br>JavaScript web 开发人员必须学习的 3 门语言中的一门：</p><p>HTML 定义了网页的内容<br>CSS 描述了网页的布局<br>JavaScript 网页的行为</p><p>##2.学习中的要点##</p><p>alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</p><p>您会经常看到 document.getElementById(“some id”)。这个方法是 HTML DOM 中定义的。<br>DOM (Document Object Model)（文档对象模型）是用于访问 HTML 元素的正式 W3C 标准。</p><p>###JavaScript 用法###<br>HTML 中的脚本必须位于 <script> 与 </script> 标签之间。<br>脚本可被放置在 HTML 页面的 <body> 和 <head><meta name="generator" content="Hexo 3.8.0"> 部分中。<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></body></p><p>那些老旧的实例可能会在 script 标签中使用 type=”text/javascript”。现在已经不必这样做了。JavaScript 是所有现代浏览器以及 HTML5 中的默认脚本语言</p><h3 id="在-head-或者-body-的JavaScript"><a href="#在-head-或者-body-的JavaScript" class="headerlink" title="在 head 或者 body 的JavaScript"></a>在 head 或者 body 的JavaScript</h3><p>您可以在 HTML 文档中放入不限数量的脚本。<br>脚本可位于 HTML 的 body 或 head 部分中，或者同时存在于两个部分中。</p><p>通常的做法是把函数放入 head 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p><p>###外部的 JavaScript###<br>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p><p>外部 JavaScript 文件的文件扩展名是 .js。</p><p>如需使用外部文件，请在 script 标签的 “src” 属性中设置该 .js 文件：</p><p>##JavaScript 输出##</p><p>###JavaScript 没有任何打印或者输出的函数。###</p><p>JavaScript 可以通过不同的方式来输出数据：</p><ol><li>使用 window.alert() 弹出警告框。</li><li>使用 document.write() 方法将内容写到 HTML 文档中。</li><li>使用 innerHTML 写入到 HTML 元素。</li><li>使用 console.log() 写入到浏览器的控制台。</li></ol><p>2中的操作 HTML 元素<br>如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。</p><p>请使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素内容：</p><p>请使用 document.write() 仅仅向文档输出写内容。<br>如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖</p><p>###JavaScript 注释###<br>不是所有的 JavaScript 语句都是”命令”。双斜杠 // 后的内容将会被浏览器忽略：</p><p>###JavaScript 语句###<br>JavaScript 语句是发给浏览器的命令。</p><p>这些命令的作用是告诉浏览器要做的事情。</p><p>###重新声明 JavaScript 变量###<br>如果重新声明 JavaScript 变量，该变量的值不会丢失：</p><p>在以下两条语句执行后，变量 carname 的值依然是 “Volvo”<br>var carname=”Volvo”;<br>var carname;</p><p>#JavaScript变量学习图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709822216279.gif" alt="avatar"></p><p>###JavaScript 对象###<br>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p><pre><code>var person={firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566};</code></pre><p> 等价于</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token keyword">var</span> person<span class="token operator">=</span><span class="token punctuation">{</span>    firstname <span class="token punctuation">:</span> <span class="token string">"John"</span><span class="token punctuation">,</span>    lastname  <span class="token punctuation">:</span> <span class="token string">"Doe"</span><span class="token punctuation">,</span>    id        <span class="token punctuation">:</span>  <span class="token number">5566</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>对象属性有两种寻址方式：</p><ol><li>name=person.lastname;</li><li>name=person[“lastname”];</li></ol><p>###提示：JavaScript具有隐含的全局概念，意味着你不声明的任何变量都会成为一个全局对象属性。###</p><p>#JavaScript数据类型学习脑图：#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710140220491.gif" alt="avatar"></p><p>#JavaScript函数学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470709911288582.gif" alt="avatar"></p><p>##JavaScript 全局变量##</p><p>变量在函数外定义，即为全局变量。<br>全局变量有 全局作用域: 网页中所有脚本和函数均可使用。</p><p>如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。<br>以下实例中 carName 在函数内，但是为全局变量。<br>// 此处可调用 carName 变量 </p><p>function myFunction() {<br>    carName = “Volvo”;<br>    // 此处可调用 carName 变量<br>}</p><p>##HTML 事件##<br>HTML 事件可以是浏览器行为，也可以是用户行为。</p><p>HTML 网页中的每个元素都可以产生某些可以触发 JavaScript 函数的事件。</p><p>以下是 HTML 事件的实例：</p><ol><li>HTML 页面完成加载</li><li>HTML input 字段改变时</li><li>HTML 按钮被点击<br>通常，当事件发生时，你可以做些事情。</li></ol><p>在事件触发时 JavaScript 可以执行一些代码。</p><p>常见的HTML事件<br>下面是一些常见的HTML事件的列表:</p><p>事件—————-描述<br>onchange———HTML 元素改变<br>onclick    ————用户点击 HTML 元素<br>onmouseover—–用户在一个HTML元素上移动鼠标<br>onmouseout——用户从一个HTML元素上移开鼠标<br>onkeydown——-用户按下键盘按键<br>onload————浏览器已完成页面的加载</p><p>#JavaScript运算符学习脑图#<br><img src="https://7n.w3cschool.cn/attachments/image/20170921/1505989160659350.gif" alt="avatar"></p><p>#JavaScript流程语句学习脑图#</p><p><img src="https://7n.w3cschool.cn/attachments/image/20160809/1470710031660821.gif" alt="avatar"></p><p>##Throw 语句##<br>throw 语句允许我们创建自定义错误。</p><p>正确的技术术语是：创建或抛出异常（exception）。<br>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">myFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">try</span><span class="token punctuation">{</span>         <span class="token keyword">var</span> x<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"demo"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span>    <span class="token keyword">throw</span> <span class="token string">"值为空"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isNaN</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token string">"不是数字"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span>     <span class="token keyword">throw</span> <span class="token string">"太大"</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">)</span>      <span class="token keyword">throw</span> <span class="token string">"太小"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">catch</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">var</span> y<span class="token operator">=</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">"mess"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        y<span class="token punctuation">.</span>innerHTML<span class="token operator">=</span><span class="token string">"错误："</span> <span class="token operator">+</span> err <span class="token operator">+</span> <span class="token string">"。"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>##JavaScript 调试工具##<br>在程序代码中寻找错误叫做代码调试。</p><p>调试很难，但幸运的是，很多浏览器都内置了调试工具。</p><p>内置的调试工具可以开始或关闭，严重的错误信息会发送给用户。</p><p>有了调试工具，我们就可以设置断点 (代码停止执行的位置), 且可以在代码执行时检测变量。</p><p>浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p><ol><li>console.log() 方法</li><li>设置断点<br>在调试窗口中，你可以设置 JavaScript 代码的断点。<br>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。<br>在检查完毕后，可以重新执行代码（如播放按钮）。</li><li>debugger 关键字<br>debugger 关键字用于停止执行 JavaScript，并调用调试函数。<br>这个关键字与在调试工具中设置断点的效果是一样的。<br>如果没有调试可用，debugger 语句将无法工作。<br>开启 debugger ，代码在第三行前停止执行。</li></ol><p>##JavaScript 表单验证##</p><p>###JavaScript 可用来在数据被送往服务器前对 HTML 表单中的这些输入数据进行验证###</p><p>###表单数据经常需要使用 JavaScript 来验证其正确性：###</p><ol><li>验证表单数据是否为空？</li><li>验证输入是否是一个正确的email地址？</li><li>验证日期是否输入正确？</li><li>验证表单输入内容是否为数字型？</li></ol><p>##JavaScript JSON##<br>JSON 是用于存储和传输数据的格式。</p><p>JSON 通常用于服务端向网页传递数据 。</p><p>###什么是 JSON?###</p><ol><li>JSON 英文全称 JavaScript Object Notation</li><li>JSON 是一种轻量级的数据交换格式。</li><li>JSON是独立的语言 </li><li>JSON 易于理解。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习HTTP协议</title>
      <link href="/2019/09/23/%E5%AD%A6%E4%B9%A0HTTP%E5%8D%8F%E8%AE%AE/"/>
      <url>/2019/09/23/%E5%AD%A6%E4%B9%A0HTTP%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol><li>Web使用一种名为HTTP的协议作为规范，完成从客户端到服务器等一些列运作流程。而协议是指规则的约定。Web是建立在HTTP协议上通信的。</li><li>通常实用的网络（包括互联网）实在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。</li><li>TCP/IP协议族里最重要的一点就是分层。TCP/IP协议族按层次分别分为以下4层：应用层、传输层、网络层、数据链路层。各个层次的作用：<br>应用层：应用层决定了向用户提供应用服务时通信的活动。TCP/IP协议族内预存了各类通用的应用服务，比如FTP,DNS服务就是两类。<br>传输层：传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。在传输层有两种性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议）<br>网络层：网络层用来处理网络上流动的数据包。数据包是网络传输的最小数据单位。该层规定了通过怎样的路径到达对方计算机，并把数据包传送给对方。<br>链路层：用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，等等。硬件上的范畴均在链路层的作用范围之内。<br>发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的首部消息。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去。这种数据信息包装起来的做法成为封装。</li><li>TCP位于传输层，提供可靠的字节流服务。TCP协议为了更容易传输大数据，把数据进行分割。TCP协议能够确认数据最终是否送达到对方。</li><li>在两台计算机之间使用HTTP协议通信时，在一条通信线路上必定有一端是客户端，另一端是服务器端。有时候，按照实际情况，两台计算机作为客户端和服务器端的角色有可能会互换。但就仅从一条通信路线来说，服务器端和客户端的角色是确定的，而用HTTP协议能够明确的区分哪端是客户端，哪端是服务器端。</li><li>HTTP是不保存状态的协议，即无状态（stateless）的协议。HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。<br><img src="https://github.com/LRQLRQ/picture/blob/master/stateless.png?raw=true" alt="avatar"><br>HTTP协议自身不具备保存之前发送过的请求或响应的功能。HTTP/1.1虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie技术。有了Cookie再用HTTP协议通信，就可以管理状态了。</li><li>GET–获取资源。。。POST–传输实体主体。。。HEAD–获得报文首部，HEAD方法和GET方法一样，只是不返回报文主体部分。用于确认URI的有效性及资源更新的日期时间等。。。OPTION–询问支持的方法<br><img src="https://github.com/LRQLRQ/picture/blob/master/option.png?raw=true" alt="avatar"><br>TRACE方法是让Web服务器端将之前的请求通信环回给客户端的方法。发送请求时，在Max-Forwards首部字段中填入数值，每经过一个服务器端就将该数字减1，当数值刚好减到0时，就停止传输。客户端通过TRACE方法可以查询发送出去的请求是怎样被加工修改/篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理中转，TRACE方法就是用来确认连接过程中发生的一系列操作。<br><img src="https://github.com/LRQLRQ/picture/blob/master/trace.png?raw=true" alt="avatar"></li><li>使用方法下达命令。。向请求URI指定的资源发送请求报文时，采用成为方法的命令。方法的作用在于，可以指定请求的资源按期望产生某种作用。<br><img src="https://github.com/LRQLRQ/picture/blob/master/sumup.png?raw=true" alt="avatar"></li><li>HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP连接。当年的文本传输都是容量很小的文本传输。可是随着HTTP的普及，文档中包含大量图片。HTTP/1.1和1.0想出了持久连接的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持TCP连接状态。持久连接旨在建立1次TCP连接后进行多次请求和响应的交互。</li><li>管线化—持久连接使得多数请求以管线化方式发送成为可能。从前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。即，不用等待，直接发送下一个请求。</li><li>HTTP是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。</li><li>Cookoe技术通过在请求和响应报文中写入Cookie信息来控制客户端状态。Cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。服务器端发现客户端发送的Cookie后，会去检查究竟是从哪一个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</li><li>HTTP报文本身是由多行（用CR+LF作换行符）数据构成的字符串文本。HTTP报文大致可分为报文首部和报文主体两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。<br><img src="https://github.com/LRQLRQ/picture/blob/master/struct.png?raw=true" alt="avatar"><br>请求报文和响应报文的首部由三部分组成：<br><img src="https://github.com/LRQLRQ/picture/blob/master/struct2.png?raw=true" alt="avatar"><br><strong>请求行–包含用于请求的方法，请求URL和HTTP版本。</strong><br><strong>状态行–包含表明响应结果的状态码，原因短语和HTTP版本</strong><br><strong>首部字段–包含表示请求和响应的各种条件和属性的各类首部</strong><br>一般有4种首部，分别是：通用首部、请求首部、响应首部和实体首部。</li><li>HTTP在传输数据时可以按照数据原貌直接传输，也可以在传输过程中通过编码提升传输调率。通过在传输时编码，能有效地处理大量的访问请求。但是，编码的操作需要计算机来完成，因此会消耗更多的CPU资源。<strong>编码提升速率体现在两点：</strong>1. 压缩传输的内容编码。2. 分割发送的分块传输编码</li><li>状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了状态，还是出现了错误。<br>状态码如 200 OK ，以3位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下五种：<br><img src="https://github.com/LRQLRQ/picture/blob/master/status.png?raw=true" alt="avatar"></li><li>一台Web服务器可以搭建多个独立域名的Web网站，也可以作为通信路径上的中转服务器以提升传输效率。  –在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。由此观之，当请求发送到服务器时，已经是以IP地址形式访问了。 –在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的Web网站，因此在发送HTTP请求时，必须在Host首部内完成指定主机名或域名的URI。</li><li>HTTP通信时，除客户端和服务器以外，还有一些用于通信数据转发的应用程序，例如代理、网关和隧道。这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。<br><strong>代理</strong>，是一种有转发功能的应用程序，它扮演了位于服务器和客户端“中间人”的角色，接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端。<br>使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制。。。<br><img src="https://github.com/LRQLRQ/picture/blob/master/proxy.png?raw=true" alt="avatar"><br><strong>网关</strong>，是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。。网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务。<br><img src="https://github.com/LRQLRQ/picture/blob/master/gateway.png?raw=true" alt="avatar"><br><strong>隧道</strong>，是在相隔甚远的客户端和服务器之间进行中转，并保持双方通信连接的应用程序。。隧道可按要求建立起一条与其他服务器的通信线路，届时使用SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。隧道本身不会去解析HTTP请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。</li><li><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。缓存服务器是代理服务器的一种，并归类在缓存类型汇总。当代理转发从服务器返回的响应时，代理服务器将会保存一份资源的副本。。缓存服务器的优势在于利用缓存可避免多次从源服务器转发资源。因此客户端可就近从缓存服务器上获取资源，而源服务器也不必多次处理相同的请求。</p></li><li><p><strong>HTTP的缺点：（1）通信使用明文（不加密），内容可能会被窃听。（2）不验证通信方的身份，因此有可能遭遇伪装。（3）无法证明报文的完整性，所以有可能已遭篡改。<br>这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题。</strong></p></li><li><strong>通信的加密：</strong>HTTP协议中没有加密机制，但可以通过和SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，加密HTTP的通信内容。用SSL建立安全通信线路之后，就可以在这条线路上进行HTTP通信了。与SSL组合使用的HTTP被称为HTTPS（HTTP Secure，超文本传输安全协议）或HTTP over SSL。<br><strong>内容的加密：</strong>即把HTTP报文里所含的内容进行加密处理。在这种情况下，客户点需要对HTTP报文进行加密处理后再发送请求。如图：<br><img src="https://github.com/LRQLRQ/picture/blob/master/encryption.png?raw=true" alt="avatar"><br>为了做到有效的内容加密，前提是要求客户端和服务器同时具备加密和解密机制。主要引用在Web服务中。该方式不同于SSL或TLS将整个通信线路加密处理，所以内容仍有被篡改的风险。</li><li><p>HTTP协议的实现本身非常简单，不论是谁发送过来的请求都会返回响应，因此不确认通信方，会存在以下各种隐患。<strong>（1）无法确定请求发送至目标的Web服务器是否是按真实意图返回响应的那台服务器，有可能是已经伪装的Web服务器（2）无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端。有可能是已伪装的客户端（3）无法确定正在通信的对方是否具备访问权限。因为某些Web服务器上保存着重要的信息，只想发给特定用户通信的权限。（4）无法判定请求时来自何方、出自谁手（5）即使是无意义的请求也会照单全收。无法阻止海量请求下的Dos攻击（Denial of Service，拒绝服务攻击）</strong></p></li><li><p><strong>查看对手的证书</strong>虽然使用HTTP协议无法确定通信方，但如果使用SSL则可以。SSL不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。<br>通过使用证书，以证明通信方就是意料中的服务器。这对使用者个人来讲，也减少了个人信息泄露的危险性。另外，客户端持有证书即可完成个人身份的确认，也可用于对Web网站的认证环节。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>vue的v-model和基于数据劫持的双向绑定</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B07/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B07/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>昨天在写代码的时候用到了v-model,出现了一点问题。我在vue的data中定义了一个空的对象<code>obj: {}</code>,在某个ajax操作中会对这个对象进行操作，赋予很多属性，比如说 <code>obj.name = &#39;lrq&#39;</code>。在html中我将这个属性绑定在一个input输入框中<code>&lt;input v-model=&quot;obj,name&quot;&gt;</code>，但是没有达到想要的效果，前端页面既没有显示数据，console打印出来的数据也是空。<strong>解决方案</strong>：在定义obj对象的时候要直接加上这个属性，就可以监听到变化了。 <code>obj: {name: &#39;&#39;}</code>.借着这个机会深入了解一下vue的双向绑定。</p><h3 id="什么是双向绑定"><a href="#什么是双向绑定" class="headerlink" title="什么是双向绑定?"></a>什么是双向绑定?</h3><p>v-model实现的功能就是双向绑定，前端页面的dom元素和js中的数据进行绑定。当前端元素，比如说是一个input输入框，内容发生改变后，相应的js中与之相关的数据也会发生改变。同理，当js中处理一些业务逻辑后，对数据进行了修改，前端页面中的input输入框的内容也会发生变化。这就是双向绑定。</p><h3 id="双向绑定是怎么实现的"><a href="#双向绑定是怎么实现的" class="headerlink" title="双向绑定是怎么实现的?"></a>双向绑定是怎么实现的?</h3><ol><li>dom元素内容发生变化，会触发相应的事件。比如说input元素的<code>onchange</code>、<code>oninput</code>事件，可以在事件中进行js中数据的同步修改。</li><li>而js中的数据修改之后，怎么反映到dom元素中呢?这里用到了数据劫持。非常细节的底层现在我也还不是很懂，但大概的流程基本知道了。首先在初始化数据的时候要使用Object.defineProperty()方法重写数据的set和get方法，在实际的使用中，给数据赋值实际上就是调用了set方法，这样就可以在set方法中进行一些操作，比如说把set后的value直接写到前端的页面中，进而达到js中数据改变关联到前端页面同步改变的效果。</li></ol><h3 id="v-model的语法糖"><a href="#v-model的语法糖" class="headerlink" title="v-model的语法糖"></a>v-model的语法糖</h3><p>v-model相当于是一个语法糖，比如以下代码</p><pre><code>&lt;input type=&quot;text&quot; v-model=&quot;suger&quot;&gt;&lt;input type=&quot;text&quot; v-bind:value=&quot;suger&quot;  v-on:input=&quot;$event.target.value&quot;&gt;</code></pre><p>这两段代码产生的效果是一样的，这就是语法糖的意思。</p><h3 id="需要进一步了解的东西"><a href="#需要进一步了解的东西" class="headerlink" title="需要进一步了解的东西"></a>需要进一步了解的东西</h3><p>看了很多博客，说是在数据劫持中使用了发布者订阅者模式，具体的看了一些还是不太清晰，日后再好好看一下，再回来补充。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue.nextTick()的小理解</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B06/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B06/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在项目的开发任务中遇到了点小问题。项目是用Jquery和Vue两个框架一起的，有一个需求是使显示的下拉框也可以进行搜索。我使用Bootstrap的一个插件<strong>“selectpicker”</strong>,option的数据显示是用vue的for循环展示的。但是竟然出现了这样的问题：<br><img src="https://github.com/LRQLRQ/picture/blob/master/question1.png?raw=true" alt="avatar"></p><p>两个地方原本是下拉框，可是却渲染不出来。。。思考了一下，觉得应该是Ajax的问题，我的数据是通过Ajax发送请求给后端的，当数据还没有传回来的时候，就需要渲染，这里可能会出错。</p><h3 id="Step1"><a href="#Step1" class="headerlink" title="Step1"></a>Step1</h3><p>在这个思路下我使用promise进行了尝试，就是给所有需要显示的地方加上v-if判断，设置一个标志位，只有当所有的接口数据返回之后，标志位才为True，页面再显示。代码如下</p><pre><code>    var p1 = new Promise((resolve,reject) =&gt;{        _this.queryAllAut();    //查询被测系统的方法        resolve(&quot;查询系统OK&quot;);    }).then((v)=&gt;{        console.log(v);    });    var p2 = new Promise((resolve, reject) =&gt;{        _this.getAllFlowcaseList();    //查询流程用例的方法        resolve(&quot;查询流程用例完成&quot;);    }).then((v) =&gt;{        console.log(v);    });    p = Promise.all([p1, p2]);    p.then( () =&gt;{        _this.flagShow = true;    //两个异步操作执行完成后再操作标志位    })</code></pre><p>但是还是没有成功，就接着查了一下。</p><h3 id="Step2"><a href="#Step2" class="headerlink" title="Step2"></a>Step2</h3><p>发现”selectpicker”这个基于jQuery的插件每次数据改变的时候需要刷新一下。执行一下<strong>“$(‘.selectpicker’).selectpicker(‘refresh’);”</strong>这个方法，才会渲染。我就在那两个异步操作的方法最后面加上了这句话，但是还是没有成功。</p><h3 id="Step3"><a href="#Step3" class="headerlink" title="Step3"></a>Step3</h3><p>最后在一步操作方法底部加上了这个,就成功了。</p><pre><code>Vue.nextTick(function () {    $(&#39;.selectpicker&#39;).selectpicker(&#39;refresh&#39;);});</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想了想，应该是因为Vue的数据加载在jQuery的UI渲染之后才完成。因此渲染的时候没有数据可以用，就没得办法显示。而Vue.nextTick()方法，相当于把UI的刷新任务放到事件循环中，在当前主进程的所有任务执行完成之后，再查询事件，进行刷新。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记(五)循环事件的理解</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B05/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B05/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天看了promise，一直在说promise是js的实现异步操作的解决方案。中间说了很多事件循环机制，就查了查。看到一篇博客，写的不错，很便于理解。</p><h4 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h4><ul><li>有些文章把消息队列称为任务队列，或者叫事件队列，总之是和异步任务相关的队列</li><li>可以确定的是，它是队列这种先入先出的数据结构，和排队是类似的，哪个异步操作完成的早，就排在前面。不论异步操作何时开始执行，只要异步操作执行完成，就可以到消息队列中排队</li><li>这样，主线程在空闲的时候，就可以从消息队列中获取消息并执行<br>*消息队列中放的消息具体是什么东西？消息的具体结构当然跟具体的实现有关。但是为了简单起见，可以认为：消息就是注册异步任务时添加的回调函数。</li></ul><h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><p>下面来详细介绍事件循环。下图中，主线程运行的时候，产生堆和栈，栈中的代码调用各种外部API，异步操作执行完成后，就在消息队列中排队。只要栈中的代码执行完毕，主线程就会去读取消息队列，依次执行那些异步任务所对应的回调函数<br><img src="https://github.com/LRQLRQ/picture/blob/master/eventloop.png?raw=true" alt="avatar"></p><p>详细步骤如下：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈</li><li>主线程之外，还存在一个”消息队列”。只要异步操作执行完成，就到消息队列中排队</li><li>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行</li><li>主线程不断重复上面的第三步</li></ol><h4 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h4><p>从代码执行顺序的角度来看，程序最开始是按代码顺序执行代码的，遇到同步任务，立刻执行；遇到异步任务，则只是调用异步函数发起异步请求。此时，异步任务开始执行异步操作，执行完成后到消息队列中排队。程序按照代码顺序执行完毕后，查询消息队列中是否有等待的消息。如果有，则按照次序从消息队列中把消息放到执行栈中执行。执行完毕后，再从消息队列中获取消息，再执行，不断重复。</p><p>由于主线程不断的重复获得消息、执行消息、再取消息、再执行。所以，这种机制被称为事件循环</p><h4 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h4><p>　　为什么叫事件循环？而不叫任务循环或消息循环。究其原因是消息队列中的每条消息实际上都对应着一个事件</p><p>　　DOM操作对应的是DOM事件，资源加载操作对应的是加载事件，而定时器操作可以看做对应一个“时间到了”的事件</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记(四)初探node.js</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B04/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B04/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="初始定义的模块"><a href="#初始定义的模块" class="headerlink" title="初始定义的模块"></a>初始定义的模块</h3><p>在NodeJs中，编写稍大一点的程序时一般会将代码模块化，将代码合理拆分到不同的JS文件中，每一个文件都是一个模块，文件路径就是模块名。<br>编写每个模块时，都有require、exports、module三个预定义好的变量可以使用。</p><h4 id="require模块"><a href="#require模块" class="headerlink" title="require模块"></a>require模块</h4><p>require函数用于在当前模块中加载和使用别的模块，传入一个模块名，返回一个模块导出对象。模块名可以用相对路径，或者绝对路径，模块名中的.js后缀也可以省略。</p><pre><code>var foo1 = require(&#39;./foo&#39;);var foo2 = require(&#39;./foo.js&#39;);var foo3 = require(&#39;/home/usr/foo&#39;);var foo4 = require(&#39;/home/usr/foo.js&#39;);以上四个变量都是同一个模块的导出对象</code></pre><h4 id="exports模块"><a href="#exports模块" class="headerlink" title="exports模块"></a>exports模块</h4><p>exports对象使当前模块的导出对象，用于导出模块共有方法和属性。别的模块通过require函数使用当前模块时，就是当前模块的exports对象。如:</p><pre><code>exports.hello = function(){    console.log(&#39;Hi~&#39;);}</code></pre><h4 id="module模块"><a href="#module模块" class="headerlink" title="module模块"></a>module模块</h4><p>通过module对象可以访问到当前模块的一些相关信息，但最多的用途是替换当前模块的导出对象。</p><h4 id="主模块"><a href="#主模块" class="headerlink" title="主模块"></a>主模块</h4><p>通过命令行参数传递给NodeJs启动的模块被称为主模块。主模块负责调度组成整个程序的其他模块完成工作。<br>当主模块中使用require函数之后，导入该模块。在内存空间中生成该引入模块的对象，就算在主模块中使用不同的变量反复导入统一模块，此模块也只初始化一次。只不过新声明的变量也指向第一次生成的对象。</p><hr><h3 id="代码的组织和部署"><a href="#代码的组织和部署" class="headerlink" title="代码的组织和部署"></a>代码的组织和部署</h3><p>JS模块的基本单位是单个JS文件，但复杂些的模块往往是由多个子模块组成。为了便于管理和使用，可以把由多个子模块组成的大模块称作包，并把所有子模块放在同一个目录中。</p><h4 id="index-js"><a href="#index-js" class="headerlink" title="index.js"></a>index.js</h4><p>当模块的文件名是index.js时，加载模块时可以使用模块所在目录的路径代替模块文件路径。以下两条语句等价。</p><pre><code>var cat = require(&#39;/home/usr/lib/cat&#39;);var cat = require(&#39;/home/usr/lib/cat/index&#39;);</code></pre><p>这样处理之后，只需要把包目录路径传递给require函数，感觉上整个目录被当做单个模块使用，更有整体感。</p><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>使用package.json文件，就可以<strong>自定义入口模块的文件名和存放位置，</strong>并在其中指定入口模块的路径。</p><pre><code>{    &quot;name&quot;:&quot;cat&quot;,    &quot;main&quot;:&quot;./lib/main.js&quot;}</code></pre><p>定义好package.js文件之后，就可以使用require(‘home/user/lib/cat’)的方式加载模块(这次入口文件不是index.js,也是直接引用的包目录的路径),NodeJs会根据包目录下的package.json找到入口模块所在位置。</p><h4 id="命令行程序"><a href="#命令行程序" class="headerlink" title="命令行程序"></a>命令行程序</h4><p>使用NodeJs编写的东西，要么是一个包，要么是一个命令行程序，而前者最终也会用于开发后者。如果在部署代码的时候用一些技巧，就可以让用户觉得自己是在使用一个命令行程序。<br><strong>Linux下</strong></p><ol><li>可以把JS文件当做shell脚本来运行,在编写完成的js程序第一行加上<pre><code>#!/usr/bin/env node</code></pre></li><li>然后赋予该js文件可执行的权限(node-echo.js是文件名，该文件的路径时/home/user/bin)<pre><code>chmod +x /home/user/bin/node-echo.js</code></pre></li><li>在PATH环境变量中指定的某个目录下，例如在/usr/local/bin中创建一个软链文件，文件名与我们希望使用的终端命令同名<pre><code>sudo ln -s /home/user/bin/node-echo.js /usr/local/bin/node-echo</code></pre>这样处理以后，我们就可以在任何目录下使用node-echo命令了</li></ol><h4 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h4><p>一个完整的工程目录，应该提供命令行模式和API模式两种使用方式，并且我们会借助第三方包来编写代码。除了代码以外，一个完整的程序还应该有自己的文档和测试用例。如下:</p><pre><code>-/home/usr/workspace/node-echo/   #工程目录    -bin/       #存放命令行相关代码        node-echo    +doc/       #存放文档    -lib/       #存放API相关代码        echo.js    -node_modules/  #存放三方包        + argv/    +tests/     #存放测试用例    package.json    #元数据文件    README.md       #说明文件</code></pre><p>不同的文件夹存放了不同类型的文件，并通过node_modules目录直接使用三方包名加载模块。此外，定义了package.json之后，node-echo目录也可以被当做一个包来使用。</p><h4 id="使用npm的一些东西"><a href="#使用npm的一些东西" class="headerlink" title="使用npm的一些东西"></a>使用npm的一些东西</h4><ol><li>可以上<strong>npmjs.org</strong>来搜索自己想要的包</li><li>npm install是下载最新版本的包，如果想下载指定版本的话，可以加@符号，比如<br><strong>npm install <a href="mailto:vue@0.0.1" target="_blank" rel="noopener">vue@0.0.1</a></strong></li><li>当引入的三方包比较多时，可以在package.json中添加依赖项，然后在工程目录中使用<strong>npm install</strong>,会自动安装所依赖的包。</li><li>npm install node-echo -g，为例，-g表示全局安装，安装之后NPM会自动创建好Linux系统需要的软链文件或Windows系统下的.cmd文件。<br>在linux系统下，会安装到<strong>/usr/local/lib/node_modules/</strong>这里，并且在<strong>/usr/local/bin/</strong>这里创建软链。</li></ol><h4 id="语义版本号"><a href="#语义版本号" class="headerlink" title="语义版本号"></a>语义版本号</h4><p>npm使用语义版本号来管理代码，语义版本号分为X.Y.Z三位，分别代表主版本号，次版本号和补丁版本号。当代码变更时，版本号按以下原则进行更新。</p><ul><li>如果只是修复了bug，需要更新Z位</li><li>如果是新增了功能，但是向下兼容，需要更新Y位</li><li>如果有大变动，向下不兼容，需要更新X位</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> node 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记(三)</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B03/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B03/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="由一个小问题分析JS的赋值问题"><a href="#由一个小问题分析JS的赋值问题" class="headerlink" title="由一个小问题分析JS的赋值问题"></a>由一个小问题分析JS的赋值问题</h3><p><strong>问题</strong></p><pre><code>var a = {n: 1};var b = a;a.x = a = {n:2};    console.log(a.x);    //输出是undefinedconsole.log(b.x);    //输出是{n: 2}</code></pre><p><strong>重点</strong></p><ul><li>JS引擎对<strong>赋值表达式</strong>的处理过程</li><li>赋值运算的<strong>右结合性</strong></li></ul><p>JS引擎怎么计算赋值表达式呢 比如A = B</p><ol><li>计算表达式A，得到一个引用refA</li><li>计算表达式B，得到一个值valueB</li><li>将valueB赋给refA指向的名称绑定</li><li>返回valueB</li></ol><p>右结合性<br>所谓结合性，是指表达式中同一个运算符出现多次时，是左边的优先计算还是右边的<br>赋值表达式是右结合的,也就是说：<br>A1 = A2 = A3 = A4<br>等价于<br>A1 = (A2 = (A3 = A4))</p><p>所以，表达式是从左往右找到引用，从右往左进行赋值<br>当JS引擎运行到a.x = a = {n:2};时，从左往右求引用，a.x的引用是在{n:1,x:undefined}的x,a的引用是对象{n:1}。从右往左求值，a指向{n:2},b.x指向{n:2},b的地址还是原先a对象处的地址</p><h4 id="闭包的变量并不是保存在栈内存中，而是保存在堆内存中"><a href="#闭包的变量并不是保存在栈内存中，而是保存在堆内存中" class="headerlink" title="闭包的变量并不是保存在栈内存中，而是保存在堆内存中"></a>闭包的变量并不是保存在栈内存中，而是保存在堆内存中</h4><p>闭包的简单定义：函数A返回了一个函数B，并且函数B中引用了函数A的变量。函数B就称为闭包。</p><p><strong>typeof(null)是object，可以将引用变量赋值为null。typeof(undefined)为undefined。</strong></p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ol><li>引用计数法：看一个对象是否有指向它的引用。  弊端：循环引用导致内存泄露。</li><li>标记清除法：从根部(JS中为全局对象)出发，定时扫描内存中的对象，能从根部到达的对象，都是还需要使用的。无法从根部到达的对象，标记为不再使用，稍后进行回收。</li></ol><ul><li>经验法则：连续五次垃圾回收之后，内存占用一次比一次大，就存在内存泄露。  </li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记(二)</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B02/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B02/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="函数执行中的理解"><a href="#函数执行中的理解" class="headerlink" title="函数执行中的理解"></a>函数执行中的理解</h3><ol><li>进入执行上下文，激活变量对象VO，变为活动对象AO(Activation object)</li><li>AO对象默认初始化arguments对象，存有函数形参。</li><li>进入执行上下文后，将函数内的变量、函数解析到AO中，函数中的形参在AO中存值，函数内的实参在AO中是undefined，然后顺序执行代码，一步一步给AO中的参数赋值。</li></ol><h3 id="JS中堆与栈的使用"><a href="#JS中堆与栈的使用" class="headerlink" title="JS中堆与栈的使用"></a>JS中堆与栈的使用</h3><p>JS中基本类型保存在栈内存中，因为这些类型再内存中分别占有固定大小的空间，通过按值访问。引用类型保存在堆内存中，因为这种值的大小不固定，因此不能保存在栈内存中，但是内存地址大小是固定的，可以将地址放在栈中。<br>查找引用类型的值时，先去栈中查找，读取内存地址，再通过地址找到堆内存中的值。</p><p>小青离京，好好学习~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端笔记（一）</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B01/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="什么是ES6？ES6和JS有什么区别？"><a href="#什么是ES6？ES6和JS有什么区别？" class="headerlink" title="什么是ES6？ES6和JS有什么区别？"></a>什么是ES6？ES6和JS有什么区别？</h3><p>ES6是一个标准，全名是ECMAScript6.0，而JavaScript是ES6的一个实现。</p><h3 id="什么是CommonJS和NodeJS？为什么会有它们？"><a href="#什么是CommonJS和NodeJS？为什么会有它们？" class="headerlink" title="什么是CommonJS和NodeJS？为什么会有它们？"></a>什么是CommonJS和NodeJS？为什么会有它们？</h3><p>commonjs是一种规范，nodejs是这种规范的实现。<br>JavaScript的标准定义API是为了<strong>用于构建基于浏览器的应用程序</strong>，但是没有一个用于更广泛的应用程序的标准库。<strong>最初的JavaScript只能用来给浏览器使用。</strong><br>而CommonJS API定义了很多普通应用程序使用的API，从而填补了这个空白。它的究极目标是提供一个类似Python、Ruby和Java的标准库。这样开发者就可以使用CommonJs API来编写程序，然后这些应用可以运行在不同的JavaScript解释器和不同的主机环境中。</p><h3 id="JavaScript和NodeJs的区别是什么？"><a href="#JavaScript和NodeJs的区别是什么？" class="headerlink" title="JavaScript和NodeJs的区别是什么？"></a>JavaScript和NodeJs的区别是什么？</h3><p>JavaScript：</p><ul><li>ECMAScript（语言基础，如语法、数据类型结构、以及一些内置对象）</li><li>DOM（一些操作页面元素的方法）</li><li>BOM（一些操作浏览器的方法）</li></ul><p>NodeJS：</p><ul><li>ECMAScript（语言基础，如语法、数据类型结构、以及一些内置对象）</li><li>os（操作系统）</li><li>file（文件系统）</li><li>net（网络系统）</li><li>database（数据库）</li></ul><p>总结：前端和后端js的共同点就是，他们的语言基础都是ECMAScript，只是他们扩展的东西不同，前端需要操作页面元素，于是扩展了DOM，也需要操作浏览器，于是扩展了BOM。而服务端的js则也是基于ECMAScript扩展出了服务端所需要的一些API。常见的后台语言需要有操作系统的能力，于是扩展了os，需要有操作文件的能力，于是扩展了file文件系统，需要操作网络，于是扩展出了net网络系统，需要操作数据，于是扩展出了database能力。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端杂笔记</title>
      <link href="/2019/09/23/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/23/%E5%89%8D%E7%AB%AF%E6%9D%82%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.<br>&lt;meta&gt;元素，提供有关页面的元信息<br>&lt;meta&gt;标签永远位于head元素内部<br>元数据总是以名称/值的形式被成对传递的<br>如：&lt;meta charset=’utf-8’ &gt; 告知浏览器此页面是属于什么字符编码格式。<br>&lt; meta http-equiv=”charset” content=”iso-8859-1” &gt;  使用带有 http-equiv属性的&lt;meta&gt;标签时，服务器将把名称/值对添加到发送给浏览器的内容头部。</p><hr><h4 id="CSS、JS的放置位置与前端性能的关系？"><a href="#CSS、JS的放置位置与前端性能的关系？" class="headerlink" title="CSS、JS的放置位置与前端性能的关系？"></a>CSS、JS的放置位置与前端性能的关系？</h4><h4 id="前备知识：浏览器的解析方式"><a href="#前备知识：浏览器的解析方式" class="headerlink" title="前备知识：浏览器的解析方式"></a>前备知识：浏览器的解析方式</h4><p>浏览器解析html页面首先浏览器先下载html，然后再内存中把html代码转化成Dom Tree，然后浏览器根据Dom Tree上的Node分析CSS和Images，当文档下载遇到JS时，JS独立下载。</p><p>Q:为什么将引用的外部JS放在下面，外部CSS放在上面？（浏览器会有自己的解析顺序）<br>A1:<br>JS是阻塞加载，会影响页面加载的速度，如果JS文件比较大，算法也比较复杂的话，影响更大。<br>CSS放在前端是页面渲染时，首先是根据DOM结构生成一个DOM树，然后加上CSS生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑，直到CSS加载完成。<br>A2:<br>一般来说CSS放在头部，JS放在底部来确保用户至少能早一点看到界面，让网站看起来至少反应快一点，不过如果CSS稍微有点多了，会让屏幕白屏时间更长，所以并不是说把CSS都放顶部是一个完美的方法，而且有些JS必须在页面加载前执行掉。<br>所以应该是，把必须的js和css放在顶部，把不那么重要的css和js放在底部。</p><hr><p><strong>如何在图片上设置多个跳转</strong><br>今天完成了项目首页的搭建，在一张图片上设置多个跳转。查了很久资料，发现是用HTML中的map和area标签定位使用。主要用到了 <strong>shape</strong> <strong>coords</strong> <strong>href</strong> 这三个标签，shape来表明在图片上的什么形状，如矩形、圆形、多边形。coords来标出图片上的位置，以坐标的形式表示出来。href则表示跳转的链接。<br>图片和热点区域元素关联是使用图片的usemap属性，其值对应&lt;map&gt;的id或者name值。</p><pre class=" language-html"><code class="language-html">&lt;map name="Map" id = "CribMap">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>32,205,193,247<span class="token punctuation">"</span></span>  <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./architecture.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,207,475,247<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--被测系统管理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,294,475,336<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>newfunpoint<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--新建功能点--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,378,475,421<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>architecture<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--配置元素库--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>269,463,475,505<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./aut.html<span class="token punctuation">"</span></span> <span class="token attr-name">onclick</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goHere(<span class="token punctuation">'</span>architecture<span class="token punctuation">'</span>)<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--生成基础脚本--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>570,204,686,246<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./testplan-execute.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--批量执行--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>561,294,696,336<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./scene.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--场景管理--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>545,379,713,420<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./datatable.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--测试资源配置--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>545,460,713,508<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./caseManagement.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--新增用例--></span>                   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>803,204,914,247<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./execution.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!--执行记录查询--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>area</span> <span class="token attr-name">shape</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rect<span class="token punctuation">"</span></span> <span class="token attr-name">coords</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>786,379,932,421<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>./testProject.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>   <span class="token comment" spellcheck="true">&lt;!--新增测试项目--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>map</span><span class="token punctuation">></span></span></code></pre><p>####PS</p><pre><code>#main-content {    display: flex;    flex-flow: column;    min-height: 100vh;}#main-content .wrapper {    flex: 1;}#main-content .fixedwh {    width: 1100px;    height: 650px;}</code></pre><p>在途中遇到了一点CSS的问题，最后一段代码是我加上的，强制图片的像素为宽1100像素，高650像素，实际上图片有自己的强制缩放比，图片的最后比例是1100x700多。</p><pre><code>&lt;section class=&quot;wrapper fixedwh&quot; &gt;</code></pre><p>通过在代码里面给框柱图片上的那部分加上这个css的类，来限制图片的大小。因为mian-content.wrapper这个属性是一个模板，在每个页面都会被使用，所以这样加一个多的属性，来与一下。</p><p>可以通过PhotoShop来，先将图片的大小设置为css中限定的大小，然后找到croods的坐标。</p><p><strong>vue中的Vac对象和sessionstorge可以在页面之间传递数据</strong></p><hr><p><strong>关于作用域的问题</strong><br>在Vue中，若声明在data里面的数据temp，如果想要在Vue的method里面对temp进行操作，就必须在方法内部写</p><pre><code>var _this = this;_this.temp = 123;</code></pre><p>这样才能调用data里面的数据</p><p>此外，如果想要在Vue体外写Javascript的function，在函数内部想引用的Vue内部的数据的话，先看声明的Vue对象名字是什么，然后进行引用，如</p><pre><code>var app=new Vue({el:&#39;#something&#39;data:{temp:‘’,}})app.temp=1</code></pre><hr><p><strong>在页面之间传递值-sessionStorage</strong><br>sessionStorage属性允许在浏览器中存储key/value对的数据，在页面进行跳转的时候可以将某些数据进行传递。</p><pre><code>sessionStorage.setItem(&#39;name&#39;,&#39;liuruiqing&#39;);    //在a页面存储变量name的值为lrq//当跳转到另一页面时，可以对sessionStorage进行操作，读出name的值var temp = sessionStorage.getItem(&#39;name&#39;);</code></pre><p>需要注意的地方是，如果要判断一个变量是否存在应这样判断:</p><pre><code>var temp = session.getItem(name);if (temp==null){    ...} else{    ...}</code></pre><p>应该判断该值是不是为null，而不是判断</p><pre><code>if(temp==&#39;&#39;)</code></pre><p>因为如果数值并没有传递的话，该值是undefined，是null，而不是为’’，具体的情况可以在浏览器进行调试。</p><hr><p><strong>button、input、a标签的区别</strong><br>button、input和a标签都可以加上一定的样式后成为外观上没有很大差别的按钮，但是这三个标签应用的场景不尽相同。</p><ol><li>button,通过onclick来绑定javascript事件。</li><li>&amp;It input type=”submit” value=”提交” /&amp;gt  将表单内用户设置或者选择的所有数据一并<strong>提交到后台</strong>。</li><li>&amp;It a class=”btn” href=’#’ &amp;gt 提交 &amp;It/a&amp;gt<br>通过添加链接访问到页面中的某一个位置或者另一个页面，不向后台提供数据</li></ol><hr><p>对于输入框，可以在input内加一个placeholder，来显示默认提示信息。</p><hr><p>今天遇到一个bug，在写一个日历组件的时候，将代码从demo中扒过来之后，发现不能用。以后要先检查一下，看下console报的什么错误。然后看source里面的文件，都用了哪里的地方，然后一起扒过来。<br>在抄过来的时候，报了错误，$(…).datetimepicker is not a function，是因为我在html中先引用了这个函数，后引用了库函数，顺序反了，所以没有找到这个函数。顺序改好了就好了。</p><hr><p>12.1日<br>昨天新增了一个日历的插件，在查询的时候，后端给的接口需要输入时间戳的格式的时间。现在的时间格式是2018-12-01,但是时间戳的格式是  1543593600000  ，首先解释一下时间戳的意思，<strong>是从1970年1月1日开始，到此时此刻所经过的秒数。</strong>在这里帖上把时间转换为时间戳的代码：</p><pre><code>var startTime = &#39;2018-12-1 21:57:00:000&#39;var date = new Date(startTime.replace(/-/g,&#39;/&#39;));var time1 = date.getTime();    //这种会精确到毫秒var time2 = date.valueOf();    //同上，会精确到毫秒var Date.parse(date);        //只会精确到秒</code></pre><p>第二行使用了正则表达式，两个<code>/</code>之间的是表达式，<code>g</code>是所有的意思，这行代码的意思是将所有的<code>-</code>都变为<code>&#39;/&#39;</code></p><hr><p><strong>vue中的bind和model的比较</strong></p><ol><li>select控件使用model时，不应该将model写到 option里面，应该写到select中，绑定selece的value值</li><li>model是双向绑定。将html比作前面展示出来的东西，将js比作后面处理的动作。使用model之后，比如对于input控件，当用户进行输入，改变值之后，后面的js中的绑定的变量也会改变。同理js进行改变之后，前面的html页面也会进行修改。</li><li>bind是单向绑定。前改后不改，后改了前改。js中变量的改变会引起HTML中值的变化，显示就改变。而前面发生改变的话，js的变量是不会发生改变的。</li></ol><hr><p>2018-12-10</p><h4 id="廖雪峰网站中学到的js基础知识"><a href="#廖雪峰网站中学到的js基础知识" class="headerlink" title="廖雪峰网站中学到的js基础知识"></a>廖雪峰网站中学到的js基础知识</h4><p><strong>对于相等比较符，<code>==</code>和<code>===</code></strong>，JavaScript在设计时，有两种运算符：<br>第一种是<code>==</code>,它会自动转换数据类型再比较，很多时候会得出很诡异的结果。。<br>第二种是<code>===</code>比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再进行比较。<br>由于JavaScript这个设计缺陷，不要使用<code>==</code>比较，始终坚持使用<code>===</code>进行比较。</p><p><strong>NaN这个特殊的number与其他所有的值都不相等，包括他自己</strong><br><code>NaN===NaN  //false</code><br>唯一能判断NaN的方式是使用<code>isNaN()</code>函数：<br>isNaN(NaN);  //true</p><p><strong>JavaScript是一门动态语言</strong>，变量本身类型不固定的语言称为动态语言，与之对应的是静态语言。静态语言在定义变量的时候就必须指定变量类型，如果赋值的时候类型不匹配，就会报错。<br>比如在C语言中:</p><pre><code>int a = 123; //a是整形变量，类型用int声明a = &#39;LRQ&#39;;   //错误，不能把字符串变量赋值给整形变量</code></pre><p><strong>字符串是不可变的，如果对某个字符串的索引赋值，不会有错误，但也没有任何效果</strong><br>要获取字符串某个指定位置的字符，可以使用类似Array的下标操作，索引号从0开始：</p><pre><code>var str = &#39;lrqiswriting&#39;;a = str[0];   //a = &#39;l&#39;b = str[3];   //b = &#39;i&#39;str[2] = &#39;z&#39;; //不会出错，但也不会有任何效果</code></pre><p><strong>如果要在Array数组的头部添加若干元素，可以使用unshift()方法，shift()方法则把Array数组的第一个元素删掉</strong></p><pre><code>var str=[1,2];str.unshift(&#39;A&#39;,&#39;B&#39;);   //此时str为[&#39;A&#39;,&#39;B&#39;,1,2]arr.shift();        //去掉头部元素，则str为[&#39;B&#39;,1,2]</code></pre><p>空数组连续shift()不会报错，而是会返回undefined</p><p><strong>concat()方法把当前的Array和另一个Array连接起来，并返回一个新的Array</strong></p><pre><code>var arr = [1,2,3];var added = arr.cncat([4,5,6]);//此时added为[1,2,3,4,5,6]</code></pre><p>concat()方法并没有修改当前的Array(),而是返回了一个新的Array</p><p><strong>for…in…是for循环的一个变体，他可以把一个对象的所有属性依次循环出来</strong></p><pre><code>var object = {    name: &#39;lrq&#39;,    age: 22,    city: &#39;BeiJing&#39;}for(key in object){    console.log(key);//&#39;name&#39;,&#39;age&#39;,&#39;city&#39;    console.log(object[key]);  //使用索引取出值}</code></pre><hr><h3 id="2018-12-12"><a href="#2018-12-12" class="headerlink" title="2018-12-12"></a>2018-12-12</h3><h4 id="arguments关键字"><a href="#arguments关键字" class="headerlink" title="arguments关键字"></a>arguments关键字</h4><p>JavaScript有一个免费赠送的关键字，<strong>arguments</strong>,在函数体内使用这个关键字可以得到当前函数的调用者传入的所有参数。<code>arguments</code>类似于一个<code>Array</code>而又不是一个<code>Array</code>.<br>实际上<strong>arguments</strong>这个参数一般用于判断传入参数的个数。</p><pre><code>function foo(x){    console.log(&#39;x = &#39; + x);    for(var i=0;i&lt;arguments.length;i++){        console.log(&#39;arg&#39; + i + &#39; = &#39; + arguments[i]);    }}`foo(10,20,30,40,50);`输入以上函数可以获得以下结果**x = 10arg0 = 10arg1 = 20arg2 = 30arg3 = 40arg4 = 50**</code></pre><h4 id="rest参数"><a href="#rest参数" class="headerlink" title="rest参数"></a>rest参数</h4><p>ES6引入了rest参数</p><pre><code>function foo(a,b,...rest){    console.log(&#39;a = &#39; + a);    console.log(&#39;b = &#39; + b);    console.log(rest);}</code></pre><p>输入函数<code>foo(1,2,3,4,5,6,7,8,9);</code><br>输出如下:<br><strong>a = 1<br>b = 2<br>[3,4,5,6,7,8,9]</strong></p><p><strong>注意：rest参数只能写在最后面，前面用<code>...</code>来进行标识，传入的参数先绑定a和b，其余的再放入rest数组内。如果传入的参数连正常的都没有填满，rest参数会接收一个空数组。而不是<code>undefined</code></strong></p><p><strong>JavaScript有一个在行末自动加分号的机制。</strong></p><p><strong>变量提升</strong><br>JavaScript的函数定义有个特点，它会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部。</p><pre><code>&#39;use strict&#39;function foo(){    var x = &#39;hello&#39;+y;    console.log(x);    var y = &#39;Lrq&#39;;}foo();</code></pre><p>当运行以上函数时，返回的结果是helloundefined.如果没有定义y变量的话，则会显示referenceError.<br>实际上JavaScript引擎看到的代码如下：</p><pre><code>function foo(){    var y;    var x = &#39;hello&#39;+y;    console.log(x);    var y = &#39;Lrq&#39;;}</code></pre><p>在给y赋值之前已经声明，但是还没有值。所以可以运行，只不过结果是undefined.但是如果连定义也没有的话，运行都会出错，会提示ReferenceError。</p><hr><h4 id="函数的一种写法"><a href="#函数的一种写法" class="headerlink" title="函数的一种写法"></a>函数的一种写法</h4><p>发现师兄写的一个函数的写法，感觉很高级使用。带参数可以使用，不带参数也可以使用。代码如下：</p><pre><code>var page = {    totalCount = 1;    currentPage = 1;    totalPage = 1;    pageSize = 20;}getRecord(page){    var pageSize = page?page.pageSize:this.page.pageSize,    currentPage = page?page.currentPage:this.page.currentPage;}</code></pre><p>这么写的好处，可以直接调用<code>getRecord()</code>来使用函数，这样的话就是传入的page参数是null，然后在函数内部使用表达式判断进行赋初值。<br><code>page?page.pageSize:this.page.pageSize</code>这句话的意思是，判断page是不是存在，如果存在的话就给<code>pageSize</code>赋值为传入对象的储值，如果不存在的话，就赋值为全局变量中的初值。这么写省了很多逻辑。</p><h3 id="ES6是什么？和javascript有什么关系？"><a href="#ES6是什么？和javascript有什么关系？" class="headerlink" title="ES6是什么？和javascript有什么关系？"></a>ES6是什么？和javascript有什么关系？</h3>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>刷LeetCode的笔记</title>
      <link href="/2019/09/23/%E5%88%B7LeetCode%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/23/%E5%88%B7LeetCode%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>刷LeetCode心得体会</strong></p><p>11.23日，第一次刷LeetCode，有一个题我写了28行，看了讨论区别人只写了4行，看了他写的代码，是用了javascript的一些方法，我不知道这些方法，还是像C语言一样实现了一下。<br>总结一下javascript的一些方法</p><p>有个题目是返回输入的数字的倒序<br>代码如下</p><pre><code>var reverse = function(x){    result = parseInt(x.toString().split(&#39;&#39;).reverse().join(&#39;&#39;));    if(result &gt; Math.pow(2,31)-1 || -result &lt; Math.pow(-2,31)-1) return 0;    return x &gt; 0 ? result : -result;}</code></pre><p><code>x.toString</code> 是把输入的数字转化为字符串<br><code>x.split(&#39;&#39;)</code>是把生成的字符串根据’’切割，转化为数组<br><code>x.reverse()</code> 是把数组进行倒序<br><code>x.join(&#39;&#39;)</code> 是将数组组合成字符串</p><hr><p>11.27 Roman to Integer<br>        今天做了一道将罗马数字转化为数字的题，罗马数字中I为1，V为5，X为10，L为50，C为100，D为500，M为1000.但是表示4的时候不是表示IIII，而是IV，I在V左边表示5-1=4，像这样的都有 IV=4  IX=9  XL=40  XC=90  CD=400 CM=900.<br>然后根据罗马数字的输入来得到整数的输出，我的代码是这样：</p><pre><code>/** * @param {string} s * @return {number} */var romanToInt = function(s) {    var num_IV = s.split(&#39;IV&#39;).length-1;    //-1    var num_IX = s.split(&#39;IX&#39;).length-1;    //-1        var num_XL = s.split(&#39;XL&#39;).length-1;    //-10    var num_XC = s.split(&#39;XC&#39;).length-1;    //-10    var num_CD = s.split(&#39;CD&#39;).length-1;    //-100    var num_CM = s.split(&#39;CM&#39;).length-1;    //-100    var num_I = s.split(&#39;I&#39;).length-1;    var num_V = s.split(&#39;V&#39;).length-1;    var num_X = s.split(&#39;X&#39;).length-1;    var num_L = s.split(&#39;L&#39;).length-1;    var num_C = s.split(&#39;C&#39;).length-1;    var num_D = s.split(&#39;D&#39;).length-1;    var num_M = s.split(&#39;M&#39;).length-1;    var result = 0;    result = num_I + num_V*5 + num_X*10 + num_L*50 + num_C*100 + num_D*500 + num_M*1000     - num_IV*2 - num_IX*2 - num_XL*20 - num_XC*20 - num_CD*200 - num_CM*200;    return result;};</code></pre><p>这样写代码很冗杂，才超过了百分之30多的人。。。也算是初步会用了js的一些方法吧。<br>如果想求某个字符串temp，在字符串s中出现的次数，可以用s.split(‘temp’).length-1，来获得。s.split(‘temp’)后得到一个数组，再求出这个数组的长度，再-1，因为split操作后，数组中会出现’’元素。</p><p>看了看discussion，发现另一种用slice实现的方法，虽然也有点暴力，没有为之一振的感觉，但是初学者，能吸收一点是一点，放在这里刚好可以对比着学习split和slice这两个方法了</p><pre><code>var romanToInt = function(s) {    var roman = {        //定义存储的数组        &#39;I&#39;: 1,        &#39;V&#39;: 5,        &#39;X&#39;: 10,        &#39;L&#39;: 50,        &#39;C&#39;: 100,        &#39;D&#39;: 500,        &#39;M&#39;: 1000,        &#39;IV&#39;: 4,        &#39;IX&#39;: 9,        &#39;XL&#39;: 40,        &#39;XC&#39;: 90,        &#39;CD&#39;: 400,        &#39;CM&#39;: 900,    };    var ret = 0;    for (var i = 0; i &lt; s.length; ) {        var j = i + 1;    //每次j只比i大1，是当前元素的下一个元素        if (j === s.length) {    //如果j为字符串的长度，就说明到了最后，进行最后一次运算            ret += roman[s.slice(i, j)];            return ret;        }        if (s.slice(i, j + 1) in roman) {        //如果连着2个字符出现在之前存储的数组中，即出现了IV、IX这些            ret += roman[s.slice(i, j + 1)];            i = j + 1;        } else {            ret += roman[s.slice(i, j)];            i = j;        }    }    return ret;};</code></pre><p><code>if (s.slice(i, j + 1) in roman)</code> 我觉得这个知识点有点东西，得记一下。<br>依据键来取声明式对象中的值</p><p>此外，slice方法，是输入两个index，返回的是该字符串中，两个index之间的字符串。<br>而split方法，是把字符串进行切分，分割成若干个数组。</p><hr><p>11.28 求一个数组中，前面相同的部分<br>如输入 strs = [‘flower’,’flow’,’fly’]  就输出’fl’</p><p>做这道题我自己的方法是<br>1.最多循环数组中第一个元素的长度<br>2.以第一个元素为基准，以此和数组中别的元素的相同位置的字符进行比较<br>3.如果相同，则将该字符添加到ret后面</p><p>做这道题，掌握到的<strong>新知识点</strong>：<br>1.对于一些乱七八糟的输入，比如空数组[] ,比如[‘’]，可以这样来判断输入值是否合法<br><code>if(!strs || strs.length)</code>,如果是undefined的话，加一个取反，逻辑就为true。如果是长度为0，也会返回true。<br>2.对于输入的strs，可以用这种方式来取值<code>strs[i][j]</code><br>即对于string类型的数据，可以直接通过[]的方式取值<br>3.string类型的一个新方法，截取字符串 <code>string.substring(i,j)</code>，则返回字符串string中的i到j坐标中的字符串</p><hr><p>11.29 判定一个括号是不是成对出现，符合规则<code>{[()]}</code>,比如说是这样</p><p>我的思路：<br>1.重复将输入的字符串根据<code>() [] {}</code> 进行split拆分成数组，再合并起来，一直到最后结果变为 <code>&#39;&#39;</code>,这就说明成功了。具体代码如下：</p><pre><code>var temp = s;while(1){    temp = s.split(&quot;()&quot;).join(&quot;&quot;).split(&quot;[]&quot;).join(&quot;&quot;).split(&quot;{}&quot;).join(&quot;&quot;);    if(temp==&quot;&quot;)        return true;    if(temp==s){        return false;    }    s = temp;}</code></pre><p>但是这样运行效率太差劲了，只超过了10%的人，菜的要死。<br>然后在dission看到了超过100%的人。。学习一下<br>思路：<br>1.将括号的左边，和括号的右边存在两个Set对象中，将成对的括号制成map表，以左边括号为key，以右边括号为value<br>2.用一个栈，随时储存和进行操作<br>3.对传入的字符串进行遍历，如果是一个左括号的类型的值，则push到栈顶。如果是一个右括号类型的值，就pop弹出栈顶的值，此时栈顶是左括号的最后一个的值，弹出之后就变成了前一个。拿弹出的值对应的map和此时的右括号的某个值进行比较，看相不相等。相等就继续判断下一个，不等就直接输出false</p><p>优点：<br>1.遍历的过程一次只判断一个字母，速度快一点。<br>2.提前制好了表，即两个set对象和一个map，查找更快。<br>3.用到了栈，巧妙的用后进先出的特点，解决了括号要按同种类型嵌套的问题<br>代码如下：</p><pre><code>var isValid = function(s) {    let stack = [];    let openSet = new Set([&#39;(&#39;, &#39;{&#39;, &#39;[&#39;]);    let closeSet = new Set([&#39;}&#39;, &#39;]&#39;, &#39;)&#39;]);    let bracketMap = new Map([[&#39;(&#39;, &#39;)&#39;], [&#39;[&#39;, &#39;]&#39;], [&#39;{&#39;, &#39;}&#39;]]);     for (let c of s) {        if (openSet.has(c))  {            stack.push(c);           }        else if (closeSet.has(c)) {            let temp = stack.pop();            if (temp === undefined || c !== bracketMap.get(temp)) return false;        }     }    return stack.length === 0;};</code></pre><p>新学的知识点：<br>1.Set对象，和map类似，是一组key的集合，但是不存储value，因为key不能重复，所以在Set中没有重复的元素。<br>2.map,是一组键值对的结构，具有极快的查找速度，通过传入的数组的数组建立。通过set(key,value)方法添加元素，通过get(key)来取值。<br>3.栈的push和pop，栈是一种后进先出的数据结构，栈中项的推入和弹出都发生在栈顶。javascript中为数组提供了push()和pop()方法，push()可以接受任意数量的参数，逐个添加到数组的末尾，并返回修改后数组的长度。pop()方法则从数组的末尾弹出最后一项，减少数组的length值，返回弹出的项</p>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>前端开发笔记--JS的void函数传参问题</title>
      <link href="/2019/09/23/%E5%85%B3%E4%BA%8EJS%E7%9A%84void%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/"/>
      <url>/2019/09/23/%E5%85%B3%E4%BA%8EJS%E7%9A%84void%E5%87%BD%E6%95%B0%E4%BC%A0%E5%8F%82%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>这周要修复一个系统的BUG，在某个页面有查询功能，点击查询按钮后，前端发送查询信息到后端，后端返回给查询的数据。但是在前台翻页的时候，没有保留查询条件。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>原来系统的结构是正常翻页有一个函数，查询有一个函数。<strong>（如果现在让我构造的话我要把他们构造到一个函数，在传参的时候增加一个’search=false’的默认值，但是系统太复杂了，耦合太多，进行这些改动影响太大。）</strong>在点击搜索按钮之后进行查询函数。我的思路是设置一个全局标志位，在查询按钮点击之后触发标志位改变为true，然后在正常的翻页的查询函数中进行判断，如果点击过一次搜索按钮，那么以后都要进行搜索条件的查询。这个问题就解决了。</p><h3 id="新发现的问题"><a href="#新发现的问题" class="headerlink" title="新发现的问题"></a>新发现的问题</h3><p>查询条件保留的问题解决了，但是发现了一个新的问题。<strong>在已经查询翻页的条件下，假如我点击了查询，已经翻到了第三页，此时再点击查询，发现查询条件改变了，但还是在第三页。</strong></p><h3 id="新问题的尝试"><a href="#新问题的尝试" class="headerlink" title="新问题的尝试"></a>新问题的尝试</h3><p>解决思路是，在第一次点击按钮的时候，将查询的发送请求当前页设置为1.之后的请求照常运行。<br>因为系统框架使用的vue，最初想在data设置一个标志位，在html的按钮中对这个标志位进行v-onclick=”isClick=!isClick”,然后再watch监听这个变量，当这个变量改变的时候，就说明进行了点击操作，新增一个标志位置true，此时在发送的请求中设置请求页码为1，在返回处理信息中将标志位置false。<br>思路我觉得没毛病，虽然逻辑有点冗余复杂，尝试了之后发现不行，因为watch监听中的操作，在函数执行结束之后才会进行。也就是说，我的true标志位总是比我发送请求慢一步。因此也无法达到要求。<br><strong>抽空看一下vue中watch的生命周期，以后补上</strong></p><h3 id="最终的解决思路"><a href="#最终的解决思路" class="headerlink" title="最终的解决思路"></a>最终的解决思路</h3><p>突然想起arguments这个东西，在JAVA、C里面默认都有这个东西，C语言虽然没有显式声明，但是可以通过argu数组这个来调用传进来的参数。就在javascript中进行了尝试，果然成功了。<br><strong>虽然我的函数是一个void函数，不需要传递任何参数，但是还是可以在arguments这个数组中调用查询的参数。</strong><br>这样就简单了啊，在html中绑定函数的时候在函数内传递’1’,在js文件中进行判断，如果传递了’1’，就把当前页设置为第1页，进行查询。否则还是照常运行。哈哈，完美解决！</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript(3)</title>
      <link href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript3/"/>
      <url>/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>不变性</strong></p><ol><li>对象常量<br>结合writable:false 和configurable:false就可以创建一个真正的常量属性(不可修改、重定义或删除)<pre><code>var myObject = {};Object.defineProperty( myObject, &quot;FAVORITE_NUMBER&quot;, { value:42, writable: false, configurable: false})</code></pre></li><li>禁止扩展<br>如果想禁止一个对象添加新属性并且保留已有属性，可以使用Object.preventExtensions(..)<pre><code>var myObject = { a: 2};Object.preventExtensions( myObject );myObject.b = 3;myObject.b  //undefined</code></pre></li><li>密封<br>Object.seal(..)会创建一个”密封”的对象，这个方法实际上会在一个现有对象上调用Object.preventExtensions(..) 并把所有现有属性标记为 <code>configurable:false</code><br>密封后不仅不能添加新的属性，也不能重新配置或者删除任何现有的属性  </li><li>冻结<br>Object.freeze(..)会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有”数据访问”属性标记为<code>writable:false</code>,这样就无法修改它们的值。<br>这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改。<br>你可以“深度冻结” 一个对象，具体方法为，首先在这个对象上调用Object.freeze(..)，然后遍历它引用的所有对象并在这些对象上调用Object.freeze(..)。但是一定要小心，因为这样做有可能会在无意中冻结其他（共享） 对象。</li></ol><p><strong>Getter和Setter</strong><br>对象默认的 [[Put]] 和[[Get]]操作分别可以控制属性值的设置和获取。<br>getter是一个隐藏函数，会在获取属性值时调用。setter也是一个隐藏函数，会在设置属性值时调用。<br><strong>存在性</strong><br>可以在不访问属性值的情况下判断对象中是否存在某个属性:</p><pre><code>var myObject = {    a: 2};(&quot;a&quot; in myObject);  //true(&quot;b&quot; in myObject);  //falsemyObject.hasOwnProperty( &quot;a&quot; ); //truemyObject.hasOwnProperty( &quot;b&quot; ); //false</code></pre><p>in操作符会检查属性是否在对象及其 [[Prototype]] 原型链中，相比之下，hasOwnProperty(..) 只会检查属性是否在myObject对象中，不会检查[[Prototype]]链。</p><p>in操作符只会检查容器内是否有某个值，但是它实际上检查的是某个属性名是否存在。对于数组来说这个区别特别重要。比如： 4 in [ 2, 4, 6] 的结果并不是true，因为 [2, 4, 6] 这个数组的属性名是 0、1、2  </p><p><strong>可枚举性</strong><br>在数组上应用<code>for ... in ...</code>循环时可能会产生出乎意料的结果，因为这种枚举不仅会包含所有数值索引，还会包含所有可枚举属性。最好只在对象上应用 <code>for .. in</code>循环，如果要遍历数组就使用传统的for循环来遍历数值索引。  </p><pre><code>var myObject = {};Object.defineProperty(    myObject,    &quot;a&quot;,    { enumerable: true, value:2 });Object.defineProperty(    myObject,    &quot;b&quot;,    { enumerable: false, value: 3 });myObject.propertyIsEnumerable(&quot;a&quot;); //truemyObject.propertyIsEnumerable(&quot;b&quot;); //falseObject.keys( myObject );    // [&quot;a&quot;]Object.getOwnPropertyNames( myObject ); //[ &quot;a&quot;, &quot;b&quot;]</code></pre><p><code>propertyIfEnumerable(..)</code>会检查给定的属性名是否直接存在于对象中(而不是阿紫原型链上)，并且满足<code>enumerable: true</code><br><code>Object.keys(..)</code> 会返回一个数组，包含所有可枚举属性，<code>Object.getOwnPropertyNames(..)</code>会返回一个数组，包含所有属性，无论它们是否可枚举。<br><code>in</code> 和 <code>hasOwnProperty(..)</code>的区别在于是否查找 <code>[[property]]</code> 链，然而<code>Object.keys(..)</code>和<code>Object.getOwnPropertyNames(..)</code>都只会查找对象直接包含的属性。  </p><p><strong>遍历</strong><br>下面是一个标准的for循环遍历程序</p><pre><code>var myArray = [1, 2, 3];for(var i=0; i&lt;myArray.length; i++) {    console.log( myArray[i] );}</code></pre><p>这实际上并不是在遍历值，而是遍历下标来指向值。<br>ES5中增加了一些数组的辅助迭代器，包括<code>forEach(..)</code> 、<code>every(..)</code> 和<code>some(..)</code>。每种辅助迭代器都可以接受一个回调函数，并把它应用到数组的每个元素上，唯一的区别是他们对于回调函数返回值的处理方式不同。<br><code>forEach(..)</code>会遍历数组中的所有值并忽略回调函数的返回值。<code>every(..)</code>会一直运行直到回调函数返回false，<code>some(..)</code>会一直运行直到回调函数返回true。<br>可以用<code>for ..of..</code>遍历数组的值。  </p><pre><code>var myArray = [1,2,3];for(var v of myArray) {    console.log(v);}</code></pre><p><strong>小结</strong><br>JavaScript 中的对象有字面形式（比如 var a = { .. }） 和构造形式（比如 var a = newArray(..)）。字面形式更常用，不过有时候构造形式可以提供更多选项。许多人都以为“JavaScript中万物都是对象”， 这是错误的对象是 6 个（或者是7个，取决于你的观点）基础类型之一。  </p><p>对象有包括function在内的子类型，不同子类型具有不同的行为，比如内部标签[objectArray]表示这是对象的子类型数组。对象就是键 / 值对的集合。可以通过 .propName 或者 [“propName”] 语法来获取属性值。  </p><p>访问属性时，引擎实际上会调用内部的默认[[Get]]操作（在设置属性值时是[[Put]]），[[Get]]操作会检查对象本身是否包含这个属性，如果没找到的话还会查找[[Prototype]]链属性的特性可以通过属性描述符来控制，比如<code>writable</code>和<code>configurable</code>。此外，可以使用<code>Object.preventExtensions(..)、Object.seal(..)和Object.freeze(..)</code>来设置对象（及其属性）的不可变性级别。  </p><p>属性不一定包含值——它们可能是具备getter/setter的“访问描述符”。此外，属性可以是可枚举或者不可枚举的，这决定了它们是否会出现在 for..in 循环中。</p><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><p>JavaScript中的对象有一个特殊的[[Prototype]]内置属性，其实就是对于其他对象的引用。几乎所有的对象在创建的时候[[prototype]]  属性都会被赋予一个非空的值。  </p><pre><code>var anotherObject = {    a: 2};var myObject = Object.create( anotherObject );  //Object.create会创建一个对象并把这个对象的[[Prototype]]关联到指定的对象myObject.a  // 2</code></pre><p>使用<code>for...in</code>遍历对象时原理和查找[[Prototype]]链类似，任何可以通过原型链访问到的(并且是enumerable)的属性都会被枚举。使用in操作符来检查属性在对象中是否存在时，同样会查找对象的整条原型链(无论属性是否可枚举)<br>到哪里才是[[Prototype]]的 “尽头”呢？所有普通的[[Prototype]]链最终都会指向内置的<code>Object.prototype</code>。由于所有的“普通”对象都“源于”(或者说把[[Prototype]]链的顶端设置为)这个Object.prototype对象，所以它包含JavaScript中许多通用的功能，比如你熟悉的<code>.toString()  .valueOf()  .hasOwnProperty(..)</code>  </p><h4 id="属性设置和屏蔽"><a href="#属性设置和屏蔽" class="headerlink" title="属性设置和屏蔽"></a>属性设置和屏蔽</h4><p>给一个对象设置属性并不仅仅是添加一个新属性或者修改已有的属性值。如：<code>myObject.foo = &quot;bar&quot;</code><br>如果myObject对象中包含名为foo的普通数据访问属性，这条赋值语句只会修改已有的属性值。<br>如果foo不是直接存在于myObject中，[[Prototype]]链就会被遍历，类似[[Get]]操作。如果原型链上找不到foo，foo就会被直接添加到myObject上。<br>如果属性名foo既出现在myObject中也出现自myObject的[[Prototype]]链上层，那么就会发生屏蔽。myObject中包含的foo属性会屏蔽原型链上层的所有foo属性，因为myObject.foo 总是会选择原型链中最底层的foo属性。  </p><p>如果foo不直接存在于myObject而是存在于原型链上层时 myObject.foo = “bar”可能出现三种情况：</p><ol><li>如果在[[Prototype]]链上层存在名为foo的普通数据访问属性，并且没有被标记为只读(writable: false)，那就会直接在myObject中添加一个名为foo的新属性，它是<strong>屏蔽属性</strong>。</li><li>如果在[[Prototype]]链上层存在foo，但是它被标记为只读(writable: false)，那么无法修改已有属性或者在myObject上创建屏蔽属性，如果运行在严格模式下，代码会抛出一个错误。否则，这条赋值语句会被忽略。  总之不会发生屏蔽</li><li>如果在[[Prototype]] 链上层存在foo并且它是一个setter，那就一定会调用这个setter。foo不会被添加到myObject，也不会重新定义这个setter。</li></ol><p><strong>隐式屏蔽</strong></p><pre><code>var anotherObject = {    a: 2};var myObject = Object.create( another );another.a;       //2myObject.a;     //2anotherObject.hasOwnProperty(&quot;a&quot;);  //truemyObject.hasOwwnProperty( &quot;a&quot; );    //falsemyObject.a++;   //隐式屏蔽anotherObject.a     // 2myObject.a;         // 3myObject.hasOwnProperty( &quot;a&quot; ); //true</code></pre><p>尽管myObject.a++看起来应该查找并增加anotherObject.a属性，但是别忘了 ++操作相当于<code>myObject.a = myObject.a + 1</code> 因此++操作首先会通过[[Prototype]] 查找a属性并从 anotherObject.a获取当前属性值2，然后给这个值加1，接着用[[ Put ]]将值3赋给 myObject中新建的屏蔽属性a。  </p><h4 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h4><pre><code>function Foo(name) {    this.name = name;}Foo.prototype.myName = function() {    return this.name;}var a = new Foo(&quot;a&quot;);var b = new Foo(&quot;b&quot;);a.myName();     // &quot;a&quot;b.myName();     // &quot;b&quot;</code></pre><p><code>Foo.prototype.myName = ...</code> 有个有趣的技巧，他会给<code>Foo.prototype</code>对象添加一个属性(函数),现在a.myName()可以正常工作，看起来似乎创建a和b时会把Foo.prototype对象复制到这两个对象中，但事实并非如此。在创建过程中，a和b的内部 [[Prototype]] 都会关联到Foo.prototype上。当a和b中无法找到myName时，它会(通过委托)在Foo.prototype上找到。  </p><p>思考以下代码</p><pre><code>function Foo {    //...}Foo.prototype = {   //创建一个新的原型对象    //...};var a1 = new Foo();a1.constructor ===Foo;      //falsea1.constructor ===Object;   //true</code></pre><p>a1并没有 <code>.constructor</code> 属性，所以它会委托 [[Prototype]] 链上的 <code>Foo.prototype</code>。但是这个对象也没有 <code>.constructor</code>属性(默认的Foo.prototype对象有这个属性，只是刚刚我们改了)，所以它会继续委托，这次会委托给委托链顶端的 <code>Object.prototype</code>，这个对象有 <code>.constructor</code>属性，指向内置的 <code>Object(..)</code>函数。  </p><p><strong>典型的原型风格</strong></p><pre><code>function Foo(name) {    this.name = name;}Foo.prototype.myName = function() {    return this.name;}function Bar(name, label) {    Foo.call( this, name);    this.label = label;}//创建了一个新的Bar.prototype 对象并关联到Foo.prototypeBar.prototype = Object.create( Foo.prototype );//现在没有 Bar.prototype.constructor 了Bar.prototype.myLabel = function() {    return this.label;}var test = new Bar(&quot;a&quot;, &quot;obj a&quot;);test.myName();     // &quot;a&quot;test.myLabel();    // &quot;obj a&quot;</code></pre><p>这段代码的核心部分就是语句 <code>Bar.prototype = Object.create( Foo.prototype )</code> 调用 <code>Object.create(..)</code> 会凭空创建一个“新”对象，并把新对象内部的[[prototype]] 关联到你指定的对象。（本例中是Foo.prototype），换句话说，这句话的意思就是创建一个新的Bar.prototype对象，并把它关联到Foo.prototype 。<br>声明 function Bar() {..}时，和其他函数一样，Bar会有一个 .prototype 关联到默认的对象，但是这个对象并不是我们想要的Foo.prototype。因此我们创建了一个新对象并把原来的对象抛弃掉。<br>有两种常见的错误做法：</p><ol><li><p><code>Bar.prototype = Foo.prototype</code>  //和想要的机制不一样<br>并不会创建一个关联到 <code>Bar.prototype</code>的新对象，他只是让 <code>Bar.prototype</code>直接引用<code>Foo.prototype</code>对象。因此当执行类似<code>Bar.prototype.myLabel = ...</code>的赋值语句会直接修改<code>Foo.prototype</code>对象本身，显然这不是想要的结果，否则你根本不需要Bar对象，直接使用Foo就可以了，这样代码也会简单一些。  </p></li><li><p><code>Bar.prototype = new Foo();</code>     //基本上满足需求，但是可能会产生一些副作用<br>这样确实会创建一个关联到 <code>Bar.prototype</code>的新对象，但是使用了<code>Foo(..)</code>的 “构造函数调用”，如果函数Foo有一些副作用(应该是在constructor写了什么东西)，比如写日志、修改状态、注册到其他对象等等。。这样就会影响到Bar()的 “后代”，后果很严重。  </p></li></ol><p>两种把Bar.prototypr 关联到 Foo.prototype 的方法:</p><pre><code>//ES6之前需要抛弃默认的Bar.prototype  Bar.prototype = Object.create( Foo.prototype );//ES6开始可以直接修改现有的Bar.prototypeObject.setPrototypeOf( Bar.prototype, Foo.prototype );</code></pre><h4 id="检查”类“关系"><a href="#检查”类“关系" class="headerlink" title="检查”类“关系"></a>检查”类“关系</h4><p>检查一个实例（JavaScript中的对象）的继承祖先（JavaScript中的委托关联）通常被称为内省，或者反射。  </p><pre><code>function Foo() {    // ...}Foo.prototype.blah = ...;var a = new Foo();</code></pre><ol><li>站在“类”的角度来判断：<br><code>a instanceoof Foo   //true</code><br>instanceof操作符的左操作数是一个普通的对象，右操作数是一个函数。instanceof回答的问题是：在a的整条[[Prototype]]链中是否有指向Foo.prototype的对象？<br>这个方法只能处理对象(a)和函数(带 .prototype引用的Foo)之间的关系。如果你想判断两个对象，比如a和b之间是否通过[[prototype]]链关联，只用instanceof无法实现。  </li><li>另一种判断[[Prototype]]反射的方法，更加简洁。<br><code>Foo.prototype.isPrototypeOf( a )</code>  //true<br>在本例中，我们实际上并不关心甚至不需要Foo，我们只需要一个可以用来判断的对象（本例中是Foo.prototype）就行，isPrototypeOf(..)回答的问题是：在a的整条 [[Prototype]]链中是否出现过Foo.prototype?<br>我们只需要两个对象就可以判断它们之间的关系。  <pre><code>b.isPrototypeOf( c )        //b是否出现在c的[[Prototype]]链中？</code></pre>有一种方法能引用某个对象的prototype，如 <code>a.__proto__ ===Foo.prototype   //true</code> ，和constructor一样， <code>.__proto__</code>实际上并不存在于正在使用的对象中，它存在于内置的 <code>Object.prototype</code>中。  </li></ol><h4 id="对象关联"><a href="#对象关联" class="headerlink" title="对象关联"></a>对象关联</h4><p>ok，fine。[[Prototype]]机制就是存在于对象中的一个内部链接，它会引用其他对象。这个链接的作用是：<strong>如果在对象上没有找到需要的属性或者方法引用，引擎就会继续在 [[Prototype]] 关联的对象上进行查找。同理，如果后者也没有找到需要的引用，就会继续查找它的 [[Prototype]]，以此类推</strong>。这一系列对象的链接被称为 “原型链”。  </p><pre><code>var foo = {    something: function() {        console.log(&quot;Tell me something good...&quot;);    }};var bar = Object.create(foo);bar.something();    //Tell me something</code></pre><p>Object.create(..)会创建一个新对象(bar)并把它关联到我们指定的对象(foo)，这样我们就可以充分发挥[[Prototype]]的机制的威力了，(委托)并且避免不必要的麻烦(比如使用new的构造函数调用会生成 .prototype 和 .constructor引用)<br>我们不需要类来创建两个对象之间的关系，只需要通过委托来关联对象就足够了。Object.create(..)可以完美的创建我们想要的关联关系。  </p><p><strong>小结（精华）</strong>  </p><ol><li>如果要访问对象中并不存在的一个属性，[[Get]]操作就会查找对象内部[[Prototype]]关联的对象。这个关联关系实际上定义了一条“原型链”（很像嵌套作用域链），在查找属性时会对它进行遍历。  </li><li>所有普通对象都有内置的Object.prototype，指向原型链的顶端（比如说全局作用域），如果在原型链中找不到指定的属性就会停止。toString()、 valueOf()和其他一些通用的功能都存在于Object.prototype对象上，因此语言中所有的对象都可以使用它们。  </li><li>关联两个对象最常用的方法是使用new关键字进行函数调用，在调用的4个步骤中会创建一个关联其他对象的新对象。  </li><li>使用new调用函数时会把新对象的 <code>.prototype</code>属性关联到“其他对象”。带new 的函数调用通常被称为“构造函数调用”，尽管他们实际上和传统面向类语言中的<strong>类构造函数</strong>不一样。</li><li>虽然这些JavaScript机制和传统面向类语言中的“类初始化”和“类继承”很相似，但是JavaScript中的机制有一个核心区别，那就是不会进行复制，对象之间是通过内部的[[Prototype]]链进行关联。</li><li>处于各种原因，以“继承”为结尾的术语（包含“原型继承”）和其他面向对象的术语都无法帮助你理解JavaScript的<strong>真实机制</strong>（不仅仅是限制我们的思维模式）。相比之下，“委托”是一个更合适的术语，因为对象之间的关系不是<strong>复制</strong>，而是委托。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript(2)</title>
      <link href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript2/"/>
      <url>/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h5 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h5><p>先说一段代码</p><pre><code>var foo = true;if(foo) {    var bar = foo * 2;    console.log(bar);}console.log(bar);</code></pre><p>上述代码会输出什么呢？我一直以为第一个console输出2，到第二个会输出undefined，但是两个都输出了2.就是因为定义的时候用的是var！！使用var声明变量时，bar在哪里都是一样的，最终都会属于外部作用域。<br>const 和 let有块级作用域，var出来的变量没有块级作用域。</p><h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ol><li>函数是JavaScript中最常见的作用域单元。本质上，声明在一个函数内部的变量或函数会在所处的作用域中“隐藏”起来，这是有意为之的良好软件的设计原则。</li><li>函数不是唯一的作用域单元。块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块(通常是指{ .. }内部)</li><li>从ES3开始，try/catch结构在 catch分句中具有块作用域。</li><li>在ES6中引入了<code>let</code>关键字(<code>var</code>关键字的表亲),用来在任意代码块中声明变量。if( .. ){ let a = 2; }会声明一个劫持了if的 { .. }块的变量，并且将变量添加到这个块中。</li></ol><h3 id="提升"><a href="#提升" class="headerlink" title="提升"></a>提升</h3><p>编译：引擎会在解释JavaScript代码之前首先对其进行编译。编译阶段的一部分工作就是找到所有的声明，并用合适的作用域将他们关联起来。<br><strong>只有声明本身会被提升，而赋值操作或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的后果</strong><br>函数声明会被提升，但是函数表达式却不会被提升。  </p><pre><code>foo();  var foo = function bar() {    //}</code></pre><p>上面这种就是函数表达式，  变量标识符<code>foo()</code>被提升并分配给所在作用域，因此<code>foo()</code>不会导致ReferenceError。但是foo此时没有赋值，(如果他是一个函数声明而不是函数表达式，就会被赋值),程序运行到foo()时，foo的内容还是undefined，对undefined进行调用导致非法操作，因此会抛出TypeError异常。<br>此外，即使是具名的函数表达式，名称标识符在赋值之前也无法再所在作用域中使用：</p><pre><code>foo();  //TypeErrorbar();  //ReferenceErrorvar foo = function bar() {    //...};</code></pre><p>上段代码提升后，实际上会理解为以下形式:</p><pre><code>var foo;foo();  //TypeErrorbar();  //ReferenceErrorfoo = function() {    var bar = ...self...;   //其实我也不太懂}</code></pre><h4 id="函数优先"><a href="#函数优先" class="headerlink" title="函数优先"></a>函数优先</h4><p>函数声明和变量声明都会被提升，但是两者同时呢？答案是函数会首先被提升，然后才是变量。  </p><pre><code>foo();var foo;function foo() {    console.log(&quot;1&quot;);}foo = function() {    console.log(&quot;2&quot;);}</code></pre><p>输出的结果是1，而不是2. <code>var foo</code>尽管出现在<code>function foo()...</code>的声明之前，但它是重复的声明，被忽略了，因为函数的声明会被提升到普通变量之前。  </p><h3 id="作用域闭包"><a href="#作用域闭包" class="headerlink" title="作用域闭包"></a>作用域闭包</h3><p>闭包是基于词法作用域书写代码时所产生的自然结果，甚至不需要为了利用它们而有意识地创建闭包。闭包的创建和使用值代码中随处可见，<strong>缺少的是根据自己的意愿来识别、拥抱、和影响闭包的思维环境。</strong><br>闭包定义：<strong>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数是在当前词法作用域之外执行</strong><br>引擎有垃圾回收器来释放不再使用的内存空间，但是闭包可以阻止这件事的发生。内部作用域依然存在，闭包的哪个引用，仍然在使用内部作用域的某个变量。<br>某个函数在定义时的词法作用域以外的地方被调用。闭包使得函数可以继续访问定义时的词法作用域。无论通过何种手段将内部函数传递到所在的词法作用域以外，<strong>它都会持有对原始定义作用域的引用</strong>，无论在何处执行这个函数都会使用闭包。  </p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><p>先看一块代码：</p><pre><code>function CoolModule() {    var something = &quot;cool&quot;;    var another = [1, 2, 3];    function doSomething() {        console.log( something );    }    function doAnother() {        console.log( another.join(&quot;!&quot;) );    }    return {        doSomething: doSomething,        doAnother: doAnother    }}var foo = CoolModule();foo.doSomething();      //coolfoo.doAnother();        //1!2!3!</code></pre><p>模块模式需要具备两个必要条件：</p><ol><li>必须有外部的封闭函数，该函数至少被调用一次（每次调用都会创建一个新的模块实例）</li><li>封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以返回或者修改私有的状态。  </li></ol><p>一个具有函数属性的对象本身并不是真正的模块，从方便观察的角度看，一个从函数调用所返回的，只有数据属性而没有闭包函数的对象并不是真正的模块。<br>模块内部的函数也可以改动，如下代码：</p><pre><code>var foo = (function CoolModule(id) {    function change() {        // 修改公共API        publicAPI.identify = identify2;    }    function identify1() {        console.log( id );    }    function identify2() {        console.log( id.toUpperCase() );    }    var publicAPI = {        change: change,        identify: identify1    };    return publicAPI;})( &quot;foo module&quot; );foo.identify(); // foo modulefoo.change();foo.identify(); //FOO MODULE </code></pre><p>通过在模块实例的内部保留对公共API对象的内部引用，可以从内部对模块实例进行修改，包括添加或删除方法和属性，以及修改他们的值。</p><p>贴一个模块管理器的代码：</p><pre><code>var MyModules = (function Manager() {    var modules = {};    function define(name, deps, impl) {        for(var i=0; i&lt;deps.length; i++) {            deps[i] = module[deps[i]];        }        modules[name] = impl.apply( impl, deps );  //这句话很关键    }    function get(name) {        return modules[name];    }    return {        define: define,        get: get    };})();</code></pre><p>那句关键的话，为了模块的定义引入了包装函数，(可以传入任何依赖)，并且将返回值，也就是模块的API，存储在一个根据名字来管理的列表中。<br>模块管理器没有任何的”魔力”，他们符合前面说的模块模式的两个特点：<strong>为函数定义引入包装函数，并保证它的返回值和模块的API保持一致。</strong>  </p><p>词法作用域和动态作用域的区别：  </p><ol><li>词法作用域是在写代码或者说定义时确定的，而动态作用域是在运行时确定的。(this 也是)</li><li>词法作用域关注函数在何处声明，而动态作用域关注函数从何处调用。</li></ol><h2 id="第二章-this和原型对象"><a href="#第二章-this和原型对象" class="headerlink" title="第二章 this和原型对象"></a>第二章 this和原型对象</h2><h4 id="误解"><a href="#误解" class="headerlink" title="误解"></a>误解</h4><h5 id="1-指向自身"><a href="#1-指向自身" class="headerlink" title="1.指向自身"></a>1.指向自身</h5><h5 id="2-指向它的作用域"><a href="#2-指向它的作用域" class="headerlink" title="2.指向它的作用域"></a>2.指向它的作用域</h5><p>在某种情况下它是正确的，但是在其他情况下它确实错误的。 <code>this</code>在任何情况下都不指向函数的词法作用域。在JavaScript内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域”对象”无法通过JavaScript代码访问，他存在于JavaScript引擎内部。  </p><h5 id="this到底是什么"><a href="#this到底是什么" class="headerlink" title="this到底是什么"></a>this到底是什么</h5><p>this是在运行时进行绑定的，并不是在编写时绑定的，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置没有任何关系，只取决于函数的调用方式。<br>当一个函数被调用时，会创建一个活动记录(也称为执行上下文)。这个记录会记录函数在哪里被调用(调用栈)、函数的调用方法、传入的参数等信息。this就是记录的其中一个属性，会在函数执行的过程中用到。<br><strong>this既不指向函数自身，也不指向函数的词法作用域，this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用</strong>  </p><h4 id="调用位置"><a href="#调用位置" class="headerlink" title="调用位置"></a>调用位置</h4><p>调用位置是函数在代码中被调用的位置（而不是声明的位置）。要分析调用栈(就是为了到达当前的执行位置所调用的所有函数)。我们关心的调用位置就是当前正在执行的函数的前一个调用中。</p><h4 id="调用规则"><a href="#调用规则" class="headerlink" title="调用规则"></a>调用规则</h4><h5 id="1-默认绑定"><a href="#1-默认绑定" class="headerlink" title="1. 默认绑定"></a>1. 默认绑定</h5><p>独立函数调用。</p><pre><code>function foo() {    console.log( this.a );}var a = 2;foo();</code></pre><p><strong>tip</strong>：声明在全局作用域中的变量(比如var a = 2)就是全局对象的一个同名属性。当调用foo()时，this.a被解析成了全局变量a。因为在本例中，函数调用时应用了this的<code>默认绑定</code>，因此this指向全局对象。<br>如果使用严格模式(strict mode)，那么全局对象将无法使用默认绑定，因此this会绑定到undefined。有时候写代码可能会用到第三方的库，其严格程度和你写的代码有所不同，要注意这类兼容性细节。</p><h5 id="2-隐式绑定"><a href="#2-隐式绑定" class="headerlink" title="2. 隐式绑定"></a>2. 隐式绑定</h5><p>需要考虑调用位置是否有上下文对象，或者说是否被某个对象拥有或者包含。</p><pre><code>function foo() {    console.log( this.a );}var obj = {    a: 2,    foo: foo};var bar = obj.foo;  //函数别名var a = &quot;global&quot;;   //a是全局对象的属性bar();               //&quot;global&quot;</code></pre><p>参数传递其实是一种隐式赋值。回调函数丢失this绑定是非常常见的。除此之外，还有一种情况this也会令人出乎意料：调用回调函数的函数可能会修改this</p><h5 id="3-显式绑定"><a href="#3-显式绑定" class="headerlink" title="3. 显式绑定"></a>3. 显式绑定</h5><p>在<strong>隐式绑定</strong>中，我们必须在一个对象内部包含一个指向函数的属性，并通过这个属性简介引用函数，从而把<code>this</code>间接(隐式)绑定到这个对象上。  </p><pre><code>function foo() {    console.log( this.a );}var obj = {    a: 2};foo.call( obj )     //2</code></pre><p>通过<code>foo.call(...)</code>，我们可以在调用foo时强制把它的this绑定到obj上。<br>如果传入的是一个原始值(字符串类型、布尔类型或者数字类型)来当做this的绑定对象，这个原始值会被转换成它的对象形式。（也就是 new String(..) 、 new Boolean(..) 或者 new Number(..) ）。这通常被称为”装箱”  .</p><h6 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h6><pre><code>function foo() {    console.log( this.a );}var obj = {    a: 2}var bar = function() {    foo.call(obj);}bar();  // 2setTimeout( bar, 100)   // 2</code></pre><p>创建了函数bar(),并在它的内部手动调用了foo.call(obj), 因此强制把foo的this绑定到了obj， 无论之后如何调用函数bar，他们总会手动在obj上调用foo，这种绑定是一种显示的强制绑定，因此我们称为硬绑定。<br><code>硬绑定</code>是一种非常常用的模式，在ES5中提供了内置的方法<code>Function.prototype.bind</code>,它的用法如下：</p><pre><code>function foo(something) {    console.log( this.a , something);    return this.a + something;}var obj = {    a: 2};var bar = foo.bind( obj );var b = bar(3);     // 2 3console.log( b );   //5</code></pre><p>bind(..)会返回一个硬编码的新函数，它会把参数设置为this的上下文并调用原始函数。  </p><h5 id="4-new绑定"><a href="#4-new绑定" class="headerlink" title="4. new绑定"></a>4. new绑定</h5><p>使用new来调用函数，或者说发生都早函数调用时，会自动执行下面的操作：</p><ol><li>创建（或者说构造）一个全新的对象</li><li>这个新对象会被执行 [[原型 ]]连接。</li><li>这个新对象会绑定到函数调用的this</li><li>如果哈数没有返回其他对象，那么new表达式中的函数调用会自动返回这个新对象。</li></ol><pre><code>function foo(a) {    this.a = a;}var bar = new foo(2);console.log( bar.a );   //2</code></pre><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><p>有些地方多条规则都可以用，就得讨论一下优先级了。”默认绑定”这个弟弟肯定是优先级最低的了。</p><h5 id="显式绑定和隐式绑定优先级比较"><a href="#显式绑定和隐式绑定优先级比较" class="headerlink" title="显式绑定和隐式绑定优先级比较"></a>显式绑定和隐式绑定优先级比较</h5><pre><code>function foo() {    console.log( this.a );}var obj1 = {    a: 2,    foo: foo};var obj2 = {    a: 3,    foo: foo};obj1.foo();             //2obj2.foo();             //3obj1.foo.call( obj2 );  //3obj2.foo.call( obj1 );  //2</code></pre><p><strong>显示绑定</strong>优先级更高，也就是说在判断时应当优先考虑是否可以应用<strong>显示绑定</strong>。</p><h5 id="判断this"><a href="#判断this" class="headerlink" title="判断this"></a>判断this</h5><p>可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照以下顺序判断：</p><ol><li>函数是否在new中调用(new 绑定)？如果是的话，this绑定的对象是新创建的对象。<br><code>var bar = new foo();</code></li><li>函数是否通过call、apply(显式绑定)或者硬绑定调用？如果是的话，this绑定的是指定的对象。<br><code>var bar = foo.call( obj2 );</code></li><li>函数是否在某个上下文对象中调用(隐式绑定)？ 如果是的话，this绑定的是那个上下文对象。<br><code>var bar = obj1.foo();</code></li><li>如果都不是，使用默认绑定。如果在严格模式下，就绑定到undefined，否则绑定到全局对象。<br><code>var bar = foo();</code></li></ol><h5 id="被忽略的this"><a href="#被忽略的this" class="headerlink" title="被忽略的this"></a>被忽略的this</h5><p>如果你把null或者undefined作为this的绑定对象传入call。apply或者bind，这些值在调用时会被忽略，实际使用的是默认绑定规则。  </p><h5 id="this语法"><a href="#this语法" class="headerlink" title="this语法"></a>this语法</h5><p>ES6中有一种无法使用这些规则的特殊函数类型：箭头函数。<br>箭头函数不是用function关键字定义的，而是使用被称为”胖箭头”的操作符 =&gt;定义的。箭头函数不使用this的四种标准规则，而是根据外层(函数或全局)作用域来决定this。  </p><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>如果要判断一个运行中的函数的this绑定，就需要找到这个函数的直接调用位置。找到之后就可以顺序应用下面的这四条规则来判断this的绑定对象。  </p><ol><li>由new 调用？  则绑定到新创建的对象。</li><li>由call 或者 apply (或者bind)调用？  绑定到指定的对象。</li><li>由上下文对象调用？  绑定到上下文对象</li><li>默认： 在严格模式下绑定到undefined，  否则绑定到全局对象。</li></ol><p><strong>ATTENTION</strong>：有些调用可能再无意中使用默认绑定规则。如果想”更安全”地忽略this绑定，可以使用一个DMZ对象，比如φ = Object.create(null),以保护全局对象。<br>ES6中的箭头函数并不会使用四条标准的绑定规则，而是根据当前的词法作用域来决定this。具体来说，箭头函数会继承外层函数调用的this绑定，(无论this绑定到什么)。这其实和ES6之前的代码中的self = this机制一样。  </p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><h4 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h4><p>对象是JavaScript的基础。在JavaScript中一共有六种主要类型(术语是”语言类型”):<br>string 、number 、boolean 、null 、undefined 、object<br>简单基本类型(string 、boolean 、number 、null 、undefined )本身并不是对象。null有时会被当做一种对象类型，但是这其实只是语言本身的一个bug，即对null执行 <code>typeof null</code> 会返回 <code>object</code>，实际上，null本身是基本类型。<br>JavaScript中海油一些对象子类型，通常被称为内置对象，如： Strig、Number、Boolean、Object、Function、Array、Date、RegExp、Error  </p><pre><code>var str = &quot;I am a string&quot; ;console.log( str.length );      //13console.log( str.charAt(3));    //&quot;m&quot;</code></pre><p>原始值 <code>I am a string</code>并不是一个对象，他只是一个字面量，并且是一个不可变的值。如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为String对象。<br>使用以上的方法，我们可以直接在字符串字面量上访问属性或者方法，之所以可以这样做，是因为引擎自动把字面量转换成String对象，所以可以访问属性和方法。  </p><h4 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h4><p>对象的内容是由一些存储在特定明明位置的(任意类型的)值组成的，称之为属性。存储在对象容器内部的是这些属性的名称，它们就像指针，(从技术角度来说就是引用)，指向这些值真正存储的位置。</p><pre><code>var myObject = {    a: 2};myObject.a;     //2myObject[&quot;a&quot;]   //2</code></pre><p>如果要访问myObject中a位置上的值，我们需要.操作符或者[]操作符。 .a 语法通常被称为”属性访问”，[“a”]语法通常被称为”键访问”。实际上访问的是同一个位置。这两种语法的主要区别在于.操作符要求属性名满足标识符的命名规范，而[“..”]语法可以接受任何UTF-8字符串作为属性名。比如 myObject[“Super-Fun!”]  </p><h5 id="属性与方法"><a href="#属性与方法" class="headerlink" title="属性与方法"></a>属性与方法</h5><p>从技术角度来说，函数永远不会”属于”一个对象。每次访问对象的属性就是属性访问，如果属性访问返回的是一个函数，那它也并不是一个”方法”。属性访问返回的函数和其他的函数没有任何区别。除了可能发生隐式绑定：<strong>有些函数有this引用，有时候这些this确实会指向调用位置的对象引用，但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为this是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</strong>  </p><p><strong>复制对象</strong><br>JSON安全的对象：也就是说可以被序列化为一个JSON字符串并且可以根据这个字符串解析出一个结构和值完全一样的对象</p><pre><code>function anotherFunction() {    //..}var anotherObject = {    c: true}var anotherArray = [];var myObject = {    a: 2,    b: anotherObject,    c: anotherArray,    d: anotherFunction}var newObj = Object.assign( {}, myObject );</code></pre><p><strong>属性描述符</strong>  </p><pre><code>var myObject = {    a: 2}Object.getOwnPropertyDescriptor( myObject, &quot;a&quot;);//{//  value:2,//  writable: true,//  enumerable: true,//  configurable: true//}</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript(1)</title>
      <link href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/"/>
      <url>/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1.作用域"></a>1.作用域</h3><p>javascript是一门编译语言，与传统的编译语言不同，它不是提前编译的，编译结果也不能在分布式系统中移植。</p><h4 id="编译的三个步骤"><a href="#编译的三个步骤" class="headerlink" title="编译的三个步骤"></a>编译的三个步骤</h4><h5 id="1-分词，词法分析"><a href="#1-分词，词法分析" class="headerlink" title="1. 分词，词法分析"></a>1. 分词，词法分析</h5><p>将字符串分解为有意义的代码块，这些代码块被称为词法单元。</p><h5 id="2-解析"><a href="#2-解析" class="headerlink" title="2. 解析"></a>2. 解析</h5><p>将词法单元流转换成一个由数组逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”</p><h5 id="3-代码生成"><a href="#3-代码生成" class="headerlink" title="3. 代码生成"></a>3. 代码生成</h5><p>将AST转换为可执行代码的过程被称为代码生成。这个过程与语言、目标平台等息息相关。</p><h4 id="对于javascript来说，大部分情况下编译发生在代码执行前的几微秒。"><a href="#对于javascript来说，大部分情况下编译发生在代码执行前的几微秒。" class="headerlink" title="对于javascript来说，大部分情况下编译发生在代码执行前的几微秒。"></a>对于javascript来说，大部分情况下编译发生在代码执行前的几微秒。</h4><p>变量的赋值操作会执行两个动作，首先编译器会在当前作用域中声明一个变量（如果之前没有声明过），然后在运行时引擎会在作用域中查找该变量，如果能够找到就会对它赋值。  </p><hr><p>当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量。</p><h5 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h5><p><strong>LHS查询和RHS查询是有区别的</strong> </p><ul><li>如果RHS查询在所有嵌套的作用域中遍寻不到所需的变量，引擎就会抛出<code>ReferenceError</code>异常。</li><li>当引擎执行LHS查询时，如果在顶层（全局作用域）中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，，并将其返还给引擎，前提是程序运行在<strong>非严格模式</strong>下。  </li><li>在<strong>严格模式</strong>下，LHS查询失败时，并不会创建并返回一个全局变量，引擎会同样抛出<code>ReferenceError</code>异常。</li></ul><p>如果RHS查询到了一个变量，但是尝试对这个变量值进行不合理的操作，比如试图对一个非函数类型的值进行函数调用，或者引用null或者undefined类型的值中的属性，那么引擎会抛出<code>TypeError</code>类型的异常。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>作用域是一套规则，用于确定在何处以及如何查找变量。如果查找的目的是对变量进行赋值，那么就会使用LHS查询；如果目的是获取变量的值，就会使用RHS查询。</p><h3 id="2-词法作用域"><a href="#2-词法作用域" class="headerlink" title="2.词法作用域"></a>2.词法作用域</h3><p>全局变量会自动成为全局对象（比如浏览器中的window对象）的属性，因此可以不直接通过全局对象的词法名称，而是间接的通过对全局对象的属性的引用来对其进行访问。比如<code>window.a</code> 通过这种技术可以访问那些被同名变量所遮盖的全局变量。但是非全局的变量如果被遮蔽了，无论如何都无法被访问到。</p><h4 id="欺骗词法"><a href="#欺骗词法" class="headerlink" title="欺骗词法"></a>欺骗词法</h4><h5 id="（1）eval"><a href="#（1）eval" class="headerlink" title="（1）eval"></a>（1）eval</h5><p>JavaScript中的<code>eval(...)</code>函数可以接收一个字符串为参数，并将其中的内容视为好像在书写时就存在于程序中这个位置的代码。即：可以在你写的代码中用程序生成代码，并运行，就好像代码是写在那个位置的一样。  </p><pre><code>function foo(str, a) {    eval(str);  //此处就是欺骗    console.log(a,b);}var b = 2;foo(&quot;var b = 3&quot;, 1);    // 1, 3</code></pre><p><code>eval(...)</code>调用中的<code>var b = 3</code>这段代码会被当做本来就在那里一样来处理。由于那段代码声明了一个新的变量b，因此它对已经存在的<code>foo(...)</code>的词法作用域进行了修改。<br>在严格模式中，<code>eval(...)</code>在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。<br>在程序中动态生成代码的使用场景非常罕见，因为它所带来的好处无法抵消性能上损失。</p><h5 id="（2）with"><a href="#（2）with" class="headerlink" title="（2）with"></a>（2）with</h5><p>with通常被当做重复引用同一个对象中的多个属性的快捷方式，可以<strong>不需要</strong>重复引用对象本身。</p><pre><code>var obj = {    a: 1,    b: 2,    c: 3}//way1:obj.a = 2;obj.b = 3;obj.c = 4;//way2:with(obj) {    a = 2;    b = 3;    c = 4;}</code></pre><p>with块可以将一个对象处理为词法作用域，但是这个块内部正常的var声明并不会被限制在这个块的作用域中，而是被添加到with所处的函数作用域中。<br><code>eval(...)</code>和<code>with</code>会被严格模式所影响，<code>with</code>被完全禁止，间接或非安全的使用<code>eval(...)</code>也被禁止了。  </p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>词法作用域意味着作用域是由书写代码时，函数声明的位置来决定的。编译的词法分析阶段基本能够知道全部标识符在哪里以及是如何声明的，从而能够预测在执行过程中如何对它们进行查找。<br>JavaScript中有两个机制可以“欺骗”词法作用域：<code>eval(...)</code>和<code>with</code>。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。后者本质是通过将一个对象的引用当做作用域来处理，将对象的属性当做作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。<br>这个两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎只能谨慎的认为这样的优化是无效的。使用这其中任何一个机制都将导致代码运行变慢。<strong>因此不要使用他们！！</strong></p><h3 id="3-函数作用域和块作用"><a href="#3-函数作用域和块作用" class="headerlink" title="3.函数作用域和块作用"></a>3.函数作用域和块作用</h3><p>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。这种设计方案是非常有用的，能充分利用JavaScript变量可以根据需要改变值类型的“动态”特性。<br><strong>tips</strong>：从所写的代码中挑选出一个任意的片段，然后用函数声明对它进行包装，实际上就是把这些代码“隐藏”起来了。<br><strong>最小特权原则（最小授权最小暴露原则）</strong>：这个原则是指在软件设计中，应该最小限度地暴露必要内容，而将其他内容都“隐藏”起来，比如某个模块或对象的API设计。  </p><h5 id="规避冲突"><a href="#规避冲突" class="headerlink" title="规避冲突"></a>规避冲突</h5><p>“隐藏作用域”中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突，两个标识符可能具有相同的名字但用途不一样，无意间可能造成命名冲突。冲突会导致变量的值被意外覆盖。  </p><h5 id="全局命名空间："><a href="#全局命名空间：" class="headerlink" title="全局命名空间："></a>全局命名空间：</h5><p>当程序中加载了多个第三方库时，如果它们没有妥善地将内部私有的函数或变量隐藏起来，就会很容易引发冲突。这些库通常会在全局作用域中声明一个名字足够独特的变量，通常是一个对象。这个对象被用作库的<strong>命名空间</strong>，所有需要暴露给外界的功能都会成为这个对象（命名空间）的属性，而不是将自己的标识符暴露在顶级的词法作用域中。  </p><h5 id="函数声明与函数表达式"><a href="#函数声明与函数表达式" class="headerlink" title="函数声明与函数表达式"></a>函数声明与函数表达式</h5><p>区分函数声明和表达式最简单的方法是看function关键字出现在声明中的位置，（不仅仅是一行代码，而是整个声明中位置）。如果function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。<br>函数声明和函数表达式之间最重要的区别是他们的名称标识符将会绑定在何处。<br>函数表达式可以是匿名的，而函数声明则不可以省略函数名——在JavaScript的语法中这是非法的。<br>匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难。</p><p>立即执行函数表达式(IIFE)：</p><pre><code>1. (function foo() { .. })()2. (function foo() { .. }())</code></pre><p>IIFE一个非常普遍的进阶用法是把它们当做函数调用并传递参数进去。</p><pre><code>var a = 2;(function IIFE( global ) {    var a = 3;    console.log( a );           //3    console.log( global.a );    //2})( window );</code></pre><pre><code>有趣的undefinedundefined = true;(function IIFE(undefined) {    var a;    if(a === undefined) {        concole.log(&quot;undefined 在这里不是true哦&quot;);    }})();</code></pre><p>方法论=建模=从各个维度分析，一件事情，一个问题，从不同的角度去分析。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Vue中v-bind动态改变样式及Vue.set()方法使用</title>
      <link href="/2019/09/23/Vue%E7%9A%84bind%E5%92%8Cset%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/23/Vue%E7%9A%84bind%E5%92%8Cset%E6%96%B9%E6%B3%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="需求及问题描述"><a href="#需求及问题描述" class="headerlink" title="需求及问题描述"></a>需求及问题描述</h3><p>现在用v-for将后端传来的图片显示在页面上了，想实现这样一个功能：</p><ol><li>点击某张图片后该图片添加边框 </li><li>同时该图片右侧增加标记，提示已经点击。 </li><li>边框是只有正在操作的图片才有，标记是只要点击过就有。</li></ol><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>这里因为是在for循环里面，每一张图片自带了index这个属性。</p><h4 id="第一个需求"><a href="#第一个需求" class="headerlink" title="第一个需求"></a>第一个需求</h4><p>对于第一个需求，首先在html中使用v-bind绑定class属性，然后设置点击事件，点击之后设置某标志位为当前点击的index，使用三目表达式来判断当前的class中的index是不是点击的index，进而实现显示边框的效果。<br>下面是html代码</p><pre><code>&lt;a :class=&quot;clickActive==index? &#39;active&#39;:&#39;&#39; &quot;  @click=&quot;clickPic(index)&quot;&gt;</code></pre><p>下面是js代码</p><pre><code>clickPic: function(index) {    this.clickActive = index;     //将全局变量设置为当前点击的下标}</code></pre><p>其中clickActive是全局变量，用来表示当前点击图片的下标。active是一个类，需要在css中定义这个类的样式。<br>至此第一个需求完成。</p><h4 id="第二个需求"><a href="#第二个需求" class="headerlink" title="第二个需求"></a>第二个需求</h4><p>想要达到一个”记忆”的效果，肯定要设置一个全局的东西，将点击过的东西记录下来。本来是设置了一个数组，点击了某个图片后，在clickPic函数中给数组中设置true。代码如下</p><pre><code>clickPic: function(index) {    this.clickActive = index;     //将全局变量设置为当前点击的下标    this.clickActives[index] = true;    //将点击过的图片index记录}</code></pre><p>然后在显示图片旁边加上标记,代码如下：</p><pre><code>&lt;span v-show=&quot;clickActives[index]==true&quot;&gt;已点击&lt;/span&gt;</code></pre><p>逻辑上没什么问题，但是一直不能成功，在Chrome上看元素也是没有显示，display:none 这样。查了查，试了试别的方法，发现数组布尔值无法监听，看到有一种方法是将数组内设为对象数组，改动对象的属性之后就可以监听到变化。尝试以后发现确实可以，然后思考了一下。</p><h4 id="总结陈词"><a href="#总结陈词" class="headerlink" title="总结陈词"></a>总结陈词</h4><p>归根结底是没有监听到的原因，对于数组中直接放布尔值vue无法监听到，加入将数组内的元素变为对象，实质上还是监听的对象。想要实现监听数组，就需要使用<strong>Vue.set(arr, index, item)</strong>这个方法,代码如下:</p><pre><code>clickPic: function(index) {    this.clickActive = index;     //将全局变量设置为当前点击的下标    Vue.set(this.clickActives, index, true);   //使用vue.set给设置布尔值并监听}</code></pre><p>至此，功能实现。</p><p>下面是效果图<br><img src="https://github.com/LRQLRQ/picture/blob/master/vueSet.png?raw=true" alt="avatar"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 vue </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RPC框架--远程过程调用</title>
      <link href="/2019/09/23/RPC%E6%A1%86%E6%9E%B6--%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
      <url>/2019/09/23/RPC%E6%A1%86%E6%9E%B6--%E8%BF%9C%E7%A8%8B%E8%BF%87%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先了解什么叫RPC，为什么要RPC，RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，由于不在一个内存空间，不能直接调用，需要通过网络来表达调用的语义和传达调用的数据。</p><p>比如说，一个方法可能是这样定义的：<br>Employee getEmployeeByName(String fullName)那么：<br><ul><li>首先，要解决通讯的问题，主要是通过在客户端和服务器之间建立TCP连接，远程过程调用的所有交换的数据都在这个连接里传输。连接可以是按需连接，调用结束后就断掉，也可以是长连接，多个远程过程调用共享同一个连接。</li><li>第二，要解决寻址的问题，也就是说，A服务器上的应用怎么告诉底层的RPC框架，如何连接到B服务器（如主机或IP地址）以及特定的端口，方法的名称名称是什么，这样才能完成调用。比如基于Web服务协议栈的RPC，就要提供一个endpoint URI，或者是从UDDI服务上查找。如果是RMI调用的话，还需要一个RMI Registry来注册服务的地址。<br></li><li>第三，当A服务器上的应用发起远程过程调用时，方法的参数需要通过底层的网络协议如TCP传递到B服务器，由于网络协议是基于二进制的，内存中的参数的值要序列化成二进制的形式，也就是序列化（Serialize）或编组（marshal），通过寻址和传输将序列化的二进制发送ss给B服务器。</li><li>第四，B服务器收到请求后，需要对参数进行反序列化（序列化的逆操作），恢复为内存中的表达方式，然后找到对应的方法（寻址的一部分）进行本地调用，然后得到返回值。</li><li>第五，返回值还要发送回服务器A上的应用，也要经过序列化的方式发送，服务器A接到后，再反序列化，恢复为内存中的表达方式，交给A服务器上的应用</li></ul></p><hr><p>为什么RPC呢？就是无法在一个进程内，甚至一个计算机内通过本地调用的方式完成的需求，比如不同的系统间的通讯，甚至不同的组织间的通讯。由于计算能力需要横向扩展，需要在多台机器组成的集群上部署应用.</p><hr><p>##经典回答##<br>本地过程调用</p><p>RPC就是要像调用本地的函数一样去调远程函数。在研究RPC前，我们先看看本地调用是怎么调的。假设我们要调用函数Multiply来计算lvalue * rvalue的结果:</p><pre><code>1 int Multiply(int l, int r) {2    int y = l * r;3    return y;4 }5 6 int lvalue = 10;7 int rvalue = 20;8 int l_times_r = Multiply(lvalue, rvalue);</code></pre><p>那么在第8行时，我们实际上执行了以下操作：</p><ol><li>将 lvalue 和 rvalue 的值压栈</li><li>进入Multiply函数，取出栈中的值10 和 20，将其赋予 l 和 r</li><li>执行第2行代码，计算 l * r ，并将结果存在 y</li><li>将 y 的值压栈，然后从Multiply返回</li><li>第8行，从栈中取出返回值 200 ，并赋值给 l_times_r<br>以上5步就是执行本地调用的过程。</li></ol><p>##<strong>远程过程调用带来的新问题</strong>##</p><p>在远程调用时，我们需要执行的函数体是在远程的机器上的，也就是说，Multiply是在另一个进程中执行的。这就带来了几个新问题：</p><ol><li><p><strong>Call ID映射。</strong>我们怎么告诉远程机器我们要调用Multiply，而不是Add或者FooBar呢？在本地调用中，函数体是直接通过函数指针来指定的，我们调用Multiply，编译器就自动帮我们调用它相应的函数指针。但是在远程调用中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。所以，在RPC中，所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 <--> Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</--></p></li><li><p><strong>序列化和反序列化。</strong>客户端怎么把参数值传给远程的函数呢？在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读就行。但是在远程过程调用时，客户端跟服务端是不同的进程，不能通过内存来传递参数。甚至有时候客户端和服务端使用的都不是同一种语言（比如服务端用C++，客户端用Java或者Python）。这时候就需要客户端把参数先转成一个字节流，传给服务端后，再把字节流转成自己能读取的格式。这个过程叫序列化和反序列化。同理，从服务端返回的值也需要序列化反序列化的过程。</p></li><li><p><strong>网络传输。</strong>远程调用往往用在网络上，客户端和服务端是通过网络连接的。所有的数据都需要通过网络传输，因此就需要有一个网络传输层。网络传输层需要把Call ID和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。只要能完成这两者的，都可以作为传输层使用。因此，它所使用的协议其实是不限的，能完成传输就行。尽管大部分RPC框架都使用TCP协议，但其实UDP也可以，而gRPC干脆就用了HTTP2。Java的Netty也属于这层的东西。</p></li></ol><p><strong>所以，要实现一个RPC框架，其实只需要把以上三点实现了就基本完成了。Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。序列化反序列化可以自己写，也可以使用Protobuf或者FlatBuffers之类的。网络传输库可以自己写socket，或者用asio，ZeroMQ，Netty之类。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> rpc netty </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>npm是干什么的</title>
      <link href="/2019/09/23/npm%E6%98%AF%E4%BB%80%E4%B9%88/"/>
      <url>/2019/09/23/npm%E6%98%AF%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="npm-一个和pip一样的东西"><a href="#npm-一个和pip一样的东西" class="headerlink" title="npm,一个和pip一样的东西"></a>npm,一个和pip一样的东西</h2><p>一直在别人的博客里看到npm，今天查了一下，终于知道这是什么了,npm全名是Node Package Manager，是一个包管理器。因为前端js的文件每天都有无数个贡献者贡献代码，如果没有这么一个npm，包管理工具的话，那我们想要找到需要的代码，那得费一百牛二百虎之力。在社区中，大家把自己开发好的前端模块发给npm的作者，然后npm的作者把接收到的代码放到服务器上。当我们下好的npm之后，只需要输入命令，就可以方便快捷的下载好需要的代码，下载到node_modules目录中。</p><p>在这里抄一下npm的实现思路：</p><ol><li>买一个服务器当做代码仓库，把所有需要共享的代码放到服务器里。</li><li>发邮件给jQuery，Bootstrap作者，使用npm publish把代码提交到registry上，分别取名jquery、bootstrap。</li><li>社区里的其他人如果想使用这些代码，就吧jquery、bootstrap写到package.json里，然后运行npm install，npm就会帮他们自动下载</li><li>下载完之后的代码就在node_modules里面，可以使用了。</li></ol><h3 id="这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。"><a href="#这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。" class="headerlink" title="这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。"></a>这些可以使用的代码叫做“包”，（package）这就是NPM名字的由来，包管理器。</h3><p>都是从这里学习的↓↓↓↓↓<br>原文地址：<br><a href="https://blog.csdn.net/qq_37696120/article/details/80507178" target="_blank" rel="noopener">https://blog.csdn.net/qq_37696120/article/details/80507178</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> npm 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第4题</title>
      <link href="/2019/09/23/leetcode%E7%AC%AC4%E9%A2%98/"/>
      <url>/2019/09/23/leetcode%E7%AC%AC4%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2.27</p><h4 id="第4题题目要求如下："><a href="#第4题题目要求如下：" class="headerlink" title="第4题题目要求如下："></a>第4题题目要求如下：</h4><p>给出两个已经排好序的数组，nums1和nums2，要求输出两个数组合并后的中位数。要求时间复杂度不能超过 log(m+n) (假设两个数组长度分别为m和n)<br>我的思路是：分别求出两个数组的中位数，合并后的中位数也一定在这两个中位数之间。就一步一步的逼近，当走过总长度的四分之一后，就达到了中位数。但是我被其中的奇数偶数困扰太多，越写情况越麻烦，最后筋疲力尽。</p><p>然后看讨论区，有个人写的比较简单的解：使用shift方法，依次将两个数组头部中比较小的元素弹出，只要弹出总长度一半的次数，剩下的就是中位数了。为了应对奇数偶数的问题，设置一个缓冲变量记录上一次的值，如果总长度是奇数则剩下的就是中位数；如果总长度是偶数则对当前变量与缓冲变量求和即可。<br>感觉其实我的思路和这个差不多，但是一开始想的太局限了，陷入细节，越来越麻烦。如果跳出去的话就能更好些一点。<br>今日份感慨：<strong>算法===抽象，业务逻辑===具体</strong>，算法就像诗，业务逻辑写的越多就像屎。</p><p>下面贴出代码：</p><pre><code>var findMedianSortedArrays = function(nums1, nums2) {    const totalLength = nums1.length + nums2.length;    //计算出总共的长度    let mid = Math.floor(totalLength/2) + 1;            //算出中位数所在的位置，进行这么多次数    let last = null, preLast = null;                    //用两个变量作为缓冲，用于应对奇数偶数长度    while (mid--) {                preLast = last;            //保存上次的值        last = ((nums2.length === 0 || nums1[0] &lt; nums2[0]) ? nums1 : nums2).shift();    //从两个数组头开始计算，把小的数字弹出去    }    console.log(totalLength % 2 ? last : (last + preLast)/2 );    return totalLength % 2 ? last : (last + preLast)/2         //如果有奇数个数字，则返回当前的值；如果有偶数个数字，则返回当前与上次值的均值};</code></pre><p>鞭策一下自己吧<br>然后是我的屎：</p><pre><code>var findMedianSortedArrays = function(nums1, nums2) {    var start1 = parseInt((nums1.length-1)/2);    var start2 = parseInt((nums2.length-1)/2);    var step1 = 0;    var step2 = 0;    var length = nums1.length + nums2.length;    while(nums1[start1] &lt; nums2[start2] &amp;&amp; (step1+step2)&lt;(parseInt(length/4+1) )){        if(start1&lt;nums1.length-1){            start1++;            step1++;        }        if(start2&gt;0){            start2--;            step2++;        }    }    while(nums1[start1] &gt; nums2[start2] &amp;&amp; (step1+step2)&lt;(parseInt(length/4+1))){        if(start1&gt;0 ){            start1--;            step1++;        }        if(start2&lt;nums2.length-1){            start2++;            step2++;        }    }    if(nums1[start1] &lt; nums2[start2]){       if(length%2===1){   //如果总共是有奇数个，且数组1中位数小于数组2            console.log(step1&gt;step2?nums1[start1]:nums2[start2]);            return step1&gt;step2?nums1[start1]:nums2[start2];        } else{             //如果总数是有偶数个            if(step1&gt;step2){                console.log((nums1[start1]+nums1[start1-1])/2);                return (nums1[start1]+nums1[start1-1])/2;            } else if(step1===step2){                console.log((nums1[step1]+nums2[step2])/2);                return (nums1[step1]+nums2[step2])/2;            } else{                console.log((nums2[start2]+nums2[start2-1])/2);                return (nums2[start2]+nums2[start2-1])/2;            }        }    }    if(nums1[start1] &gt; nums2[start2]){        if(length%2===1 ){   //如果总共是有奇数个，且数组1中位数大于数组2            console.log(step1&gt;step2?nums1[start1]:nums2[start2]);            return step1&gt;step2?nums1[start1]:nums2[start2];        } else{             //如果总数是有偶数个            if(step1&gt;step2){                console.log((nums1[start1]+nums1[start1-1])/2);                return (nums1[start1]+nums1[start1+1])/2;            } else if(step1===step2){                console.log((nums1[step1]+nums2[step2])/2);                return (nums1[step1]+nums2[step2])/2;            } else{                console.log((nums2[start2]+nums2[start2-1])/2);                return (nums2[start2]+nums2[start2+1])/2;            }        }    }};</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LeetCode第3题</title>
      <link href="/2019/09/23/leetcode%E7%AC%AC3%E9%A2%98/"/>
      <url>/2019/09/23/leetcode%E7%AC%AC3%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2018.2.26</p><h2 id="题目要求：输入一个字符串，输出其中连续的不重复的最长的子字符串的长度。"><a href="#题目要求：输入一个字符串，输出其中连续的不重复的最长的子字符串的长度。" class="headerlink" title="题目要求：输入一个字符串，输出其中连续的不重复的最长的子字符串的长度。"></a>题目要求：输入一个字符串，输出其中连续的不重复的最长的子字符串的长度。</h2><h4 id="第一次用了滑动窗口的思想"><a href="#第一次用了滑动窗口的思想" class="headerlink" title="第一次用了滑动窗口的思想"></a><strong>第一次用了滑动窗口的思想</strong></h4><p>解题思路：将输入的字符串使用split方法分割成数组，然后使用pop方法将数组尾的字符弹出。再构造一个移动窗口的数组–temp，每弹出一个字符先用变量tail存着，跟窗口–temp对比一下，如果重复了就记下当前temp的长度，和历史的比较留下大的，如果不重复就用push方法，推进窗口数组中。</p><p><strong>代码如下：</strong></p><hr><pre><code>var lengthOfLongestSubstring = function(s) {    var sArray = s.split(&#39;&#39;);   //将所给的字符串分成数组    var sTemp = [];             //缓存移动窗口    var count = 0;              //返回的数字    var tail;                   //每次循环数组队尾的字母       while(sArray.length&gt;0){     //当字符串数组有值时进行循环        tail = sArray.pop();     //取出sArray末尾的元素        for(let i=0;i&lt;sTemp.length;i++){    //取出字符串尾的元素与缓存窗口进行比较            if(sTemp[i]===tail){            //如果字符重复则进行操作                count = count&gt;sTemp.length?count:sTemp.length;  //将历史中最大的count与窗口缓存的数组长度进行比较，取其大者                for(let j=0;j&lt;i+1;j++){                         sTemp.shift();          //将重复字符以前的字符弹出数组                }            }        }        sTemp.push(tail);                   //缓存移动窗口推入末尾的元素    }    count = count&gt;sTemp.length?count:sTemp.length;  //有时传入的字符串本身就是最大的字符串，没有进入循环中的判断，因此最后还要进行赋值    console.log(count);    return count;};</code></pre><hr><p>然后看了一下别人的代码，感觉能写好一点。不需要将传入的s字符串转换为数组，也不需要对s进行操作，只需要每次取出s中的元素进行比较就行了。<strong>s[i]</strong>就可以取出字符串s中第i位的元素。思路是一样的，用滑动窗口进行判断，如果用<strong>temp.indexOf(s[i])</strong>进行判断后，发现这个字符在缓冲区的话，就使用slice方法，给temp重新赋值，从重复的位置的后一个到队尾，重新赋给temp。并记录下最大的长度和历史比较。如果不在缓冲区的话，直接push到缓冲区就好。<br><strong>代码如下：</strong></p><hr><pre><code>var lengthOfLongestSubstring = function(s) {    var temp = [];    var maxLength = 0;     for(var i = 0; i &lt; s.length; i++){        if(temp.indexOf(s[i]) === -1){            temp.push(s[i]);            if(temp.length &gt; maxLength)                maxLength = temp.length;        }else{            temp = temp.slice(temp.indexOf(s[i]) + 1,temp.length);            temp.push(s[i]);        }    }    return maxLength;};</code></pre><hr>]]></content>
      
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Java</title>
      <link href="/2019/09/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/23/Java%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>##关于，面向对象<br>类用于客观世界里某一类对象的共同特征，而对象则是类的具体存在，Java程序使用类的构造器来创建该类的对象</p><p>构造器用于对类实例进行初始化操作，构造器支持重载。</p><hr><p>##对于一个类定义而言，可以包含三种最常见的成员：构造器、成员变量和方法。</p><hr><p>static修饰的成员不能访问没有static修饰的成员</p><hr><p>成员变量用于定义该类或该类的实例所包含的状态数据，方法则用于定义该类或该类的实例的行为特征或者功能实现。构造器用于构造该类的实例，Java语言通过new关键字来调用构造器，从而返回该类的实例。</p><hr><p>##命名<br>成员变量应该由一个或多个有意义的单词连缀而成，第一个单词首字母小写，后面每个单词首字母大写，其他字母全部小写。方法名的命名规则与成员变量的命名规则基本相同。</p><hr><p>static修饰的成员表明它属于这个类本身，而不属于该类的单个实例。因为通常把static修饰的成员变量和方法也称为类变量、类方法。不使用static修饰的普通方法、成员变量则属于该类的单个实例，而不属于该类。通常把不使用static修饰的成员变量和方法也成为实例变量、实例方法。</p><hr><p>构造器是一个特殊的方法，<strong>构造器名必须和类名相同</strong>。<br>构造器既不能定义返回值类型，也不能使用void声明构造器没有返回值。如果为构造器定义了返回值类型，或使用void声明构造器没有返回值，编译时不会出错，但是java会把这个所谓的构造器当成方法来处理—它就不是构造器。</p><p>##<strong>实际构造器是有返回值的，当使用new关键字来调用构造器时，构造器返回该类的实例。</strong>##<br>创建对象的根本途径是构造器</p><hr><pre class=" language-java"><code class="language-java">Person p<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//使用person类定义一个person类型的变量</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//通过new关键字调用Person类的构造器，返回一个Person的实例，将Person</span>或者Person p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//定义p变量的同时为p变量赋值</span></code></pre><p>Person p = new Person();<br>这行代码创建了一个Person实例，也被称为Person对象，这个Person对象被赋给p变量。<br>在这行代码实际产生了两个东西，一个是p变量，一个是Person对象。<br>程序中定义的Person类型的变量实际上是一个引用，它存放在栈内存中，指向实际的Person对象。而真正的Person对象则存放在堆（heap）内存中。</p><hr><p>栈内存里的引用变量并未真正存储对象的成员变量，对象的成员变量数据实际存放在堆内存里；而引用变量只是指向该堆内存里的对象。从这个角度看，引用变量与C语言里的指针很像，他们都是存储一个地址值，通过这个地址来引用到实际对象。实际上，Java里的引用就是C里的指针。<br>p引用变量本事只存储了一个地址值，并未包含任何实际数据。但它指向实际的Person对象，当访问p引用变量的成员变量和方法时，实际上是访问p所引用对象的成员变量和方法。</p><hr><p>如果堆内存里的对象没有任何变量指向该对象，那么程序将无法再访问该对象，这个对象也就变成了垃圾，Java的垃圾回收机制将回收该对象，释放该对象所占的内存区。<br>因此，如果希望通知垃圾回收机制回收某个对象，只需切断该对象的所有引用变量和它之间的关系即可。也就是把这些引用变量赋值为null。</p><hr><p>this关键字总是指向调用该方法的对象<br>this关键字最大的作用就是让类中一个方法，访问该类里的另一个方法或实例变量。</p><p>##<strong>没有使用static修饰的成员变量和方法都必须使用对象调用。</strong>##</p><p>this可以代表任何对象，当this出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的：它所代表的只能是当前类的实例，只有当这个方法被调用时，它所代表的对象才被确定下来：谁在调用这个方法，this就代表谁。</p><p>java允许对象的一个成员直接调用另一个成员，可以省略this前缀。</p><p>##<strong>static修饰的方法属于类，而不属于对象。</strong>##<br>Java编程时不要使用对象去调用static修饰的成员变量、方法，而是应该使用类去调用static修饰的成员变量、方法。</p><hr><p>##方法##<br>在结构化编程语言里，函数是一等公民，整个软件由一个个的函数组成；在面向对象编程语言里，类才是一等公民。整个系统由一个个的类组成。因此在Java语言里，方法不能独立村子，方法必须属于类或对象。</p><p>Java语言是静态的。一个类定义完成后，只要不再重新编译这个类文件，该类和该类的对象所拥有的方法是固定的，永远都不会改变。</p><p>同一个类的一个方法调用另外一个方法时，如果被调用方法是普通方法，则默认使用this作为调用者；如果被调方法是静态方法，则默认使用类作为调用者，表面上看起来某些方法可以被独立执行，但实际上还是使用this或者类作为调用者。</p><p>##方法重载##<br>Java程序中确定一个方法需要三个要素：<br>调用者，也就是方法的所属者，既可以是类，也可以是对象。<br>方法名，方法的标识<br>形参列表，当调用方法时，系统将会根据传入的实参列表匹配。</p>]]></content>
      
      
      
        <tags>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2019/09/23/hello-world/"/>
      <url>/2019/09/23/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>Git的简单使用</title>
      <link href="/2019/09/23/Git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
      <url>/2019/09/23/Git%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>提交版本：<br>git add xxx<br>git commit -m “注释”</p><p>查看修改了什么东西：git diff xxx</p><p>查看历史记录：git log    精简版:git log –pretty=oneline<br>版本回退到上一个版本：git reset –hard HEAD^<br>版本回退到上100个版本：git reset –hard HEAD~100</p><p>恢复之前的版本：<br>1.获得之前的版本号git reflog<br>2.git reset –hard 版本号       来恢复<br><img src="http://www.ruanyifeng.com/blogimg/asset/2014/bg2014061202.jpg" alt="avatar"></p><p>修改了文件之后，还未git add的情况下，想回复之前的状态，可以输入:git checkout – 文件名 </p><p>文件修改后，还没有add放到暂存区，使用撤销修改就回到和版本库一模一样的状态。<br>另外一种是文件已经add放入暂存区了，接着又作了修改，撤销修改就回到添加暂存区后的状态。</p><p>删除了文件之后，还未commit提交的情况下，想回复仓库之前的状态，可以输入 git checkout – 文件名<br>经常输入git status 来查看文件的状态</p><p>把本地的仓库上传到github上：<br>1.在github新建一个仓库<br>2.输入git remote add origin 地址</p><p>把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程<br>由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了</p><p>从现在起，只要本地作了提交，就可以通过如下命令：<br>git push origin master</p><p>克隆远程库：<br>假如远程库有新的内容了，我想克隆到本地来，如何克隆呢<br>使用命令git clone克隆一个本地库<br>git clone -b 分支名 地址</p><p>##创建与分支合并##</p><p>git checkout 命令加上 –b参数表示创建并切换，相当于如下2条命令</p><p>git branch dev  //创建分支</p><p>git checkout dev    //切换分支</p><p>##总结创建与合并分支命令如下：##</p><p>   查看分支：git branch</p><p>   创建分支：git branch name</p><p>   切换分支：git checkout name</p><p>创建+切换分支：git checkout –b name</p><p>合并某分支到当前分支：git merge name</p><p>删除分支：git branch –d name</p><p>##如何解决冲突？##<br>在merge时，主干和分支不同的情况下，会产生冲突<br>Git用&lt;&lt;&lt;&lt;&lt;&lt;&lt;，=======，&gt;&gt;&gt;&gt;&gt;&gt;&gt;标记出不同分支的内容，其中&lt;&lt;&lt;HEAD是指主分支修改的内容，&gt;&gt;&gt;&gt;&gt;fenzhi1 是指fenzhi1上修改的内容</p><p>如果我想查看分支合并的情况的话，需要使用命令 git log</p><p>##分支策略##</p><p>首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><p>##BUG分支##<br>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p>]]></content>
      
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git的远程建立分支</title>
      <link href="/2019/09/23/Git%E5%BB%BA%E7%AB%8B%E5%88%86%E6%94%AF/"/>
      <url>/2019/09/23/Git%E5%BB%BA%E7%AB%8B%E5%88%86%E6%94%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2018-12-03<br>项目需要给邮政那边一个版本，所以需要给他们进行定制。因此就需要在现在的git仓库上新建一个分支，在此列出需要的几个命令。</p><p><code>git branch</code> :列出本地的分支，当前分支会标有<code>*</code>号<br><code>git branch -r</code> :列出远程的分支<br><code>git branch -a</code> :列出所有本地和远程的分支</p><h2 id="首先新建一个本地分支："><a href="#首先新建一个本地分支：" class="headerlink" title="首先新建一个本地分支："></a>首先新建一个本地分支：</h2><p><code>git checkout -b lrqTest</code><br>上面这行代码代表新建一个分支并切换到分支内，等同于下<br><code>git branch lrqTest</code><br><code>git checkout lrqTest</code></p><h2 id="第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起"><a href="#第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起" class="headerlink" title="第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起"></a>第二步，将新建的本地分支push到远程服务器，远程分支名字可以随便起</h2><p><code>git push origin lrqTest:remoteTest</code><br>其中<code>lrqTest</code>是本地的分支名,<code>remoteTest</code>是远程服务器的分支名，可以随便起名</p><p>到此，就建立了远程分支。</p><hr><h2 id="如果想要删除远程分支"><a href="#如果想要删除远程分支" class="headerlink" title="如果想要删除远程分支"></a>如果想要删除远程分支</h2><p><code>git push origin  :lrqTest</code><br>意思是将一个空的分支push到远程名为lrqTest的分支，就是相当于删除.<br>也可以使用此命令：<br><code>git pust origin --delete lrqTest</code></p><hr><h2 id="如果某个用户想要拉取远程的分支"><a href="#如果某个用户想要拉取远程的分支" class="headerlink" title="如果某个用户想要拉取远程的分支"></a>如果某个用户想要拉取远程的分支</h2><ol><li>直接使用<code>git checkout -b 本地分支名 origin/远程分支名</code><br>这种方式会直接在本地新建分支，并且切换到该分支。<br>并且，这种方式会将新建立的本地分支和远程分支建立<strong>映射关系</strong></li><li>使用<code>git fetch origin 远程分支名:本地分支名</code><br>这种方式建立的分支不会切换到新建的分支，需要自己手动进行checkout<br>而且，这种方式建立的本地分支<strong>不会和远程分支建立映射关系</strong></li></ol><hr><p>##建立本地分支和远程分支之间的映射关系<br>建立了映射关系之后，就不需要在每次<code>git pull</code> 和 <code>git push</code>的时候指定从远程的哪个分支拉取合并和推送到哪个分支。</p><p>使用<code>git branch -vv</code>查看本地分支和远程分支的映射关系<br>如果没有映射关系，就需要自己<strong>手动建立</strong>：<br><code>git branch -u origin/分支名</code><br>或者<br><code>git branch --set-upstream-to origin/分支名</code><br>origin为git地址的标志，可以建立当前分支与远程分支的映射关系</p><p><strong>撤销本地分支与远程分支的映射关系</strong><br><code>git branch -unset-upstream</code> 就撤销掉了与远程分支的映射关系</p>]]></content>
      
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>学习Ajax</title>
      <link href="/2019/09/23/Ajax%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/09/23/Ajax%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>####Ajax应用的工作流程如下：</p><ol><li>JavaScript脚本使用 XMLHttpRequest 对象向服务器发送请求。发送请求时，既可以发送GET请求，也可以发送POST请求。</li><li>JavaScript脚本使用 XMLHTTPRequest 对象解析服务器响应数据</li><li>JavaScript 脚本通过 DOM 动态更新 HTML 页面。也可以为服务器响应数据增加 CSS 样式表，在当前网页的某个部分加以显示。</li></ol><p>####JavaScript 脚本是Ajax 技术中另一个重要的部分。JavaScript 主要完成如下部分；</p><ol><li>创建 XMLHTTPRequest 对象</li><li>通过XMLHTTPRequest 向服务器发送请求</li><li>创建回调函数，监视服务器响应状态，在服务器响应完成之后，回调函数启动</li><li>回调函数通过 DOM 更新HTML页面</li></ol><p>JSON是一种跨平台，跨语言的轻量级数据交换格式，以JSON作为数据交换格式不仅简单，而且网络传输的数据量更小，因此， JSON 取代了 Ajax 技术中 XML 的地位。</p><hr><p>Ajax在于给用户连续的体验<br>对于Ajax应用，浏览器不仅可以包含简单逻辑，甚至可以保存用户会话转状态。<br><strong>Ajax技术有以下优势：</strong></p><ol><li>减轻了客户端的内存消耗。Ajax的根本理念是“按需取数据”</li><li>无刷新更新页面。通过异步发送请求，避免了频繁刷新页面，从而减少了用户的等待时间，给于用户一种连续的体验</li><li>Ajax技术可以将传统的服务器工作转嫁到客户端，从而减轻服务器和带宽的负担，节约空间和带宽租用成本。</li></ol><hr><p>Ajax采用异步的方式发送请求，页面的更新由JavaScript操作DOM完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> ajx </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript (中卷)2</title>
      <link href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD2/"/>
      <url>/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="异步和性能"><a href="#异步和性能" class="headerlink" title="异步和性能"></a>异步和性能</h2><p>如何表达和控制持续一段时间的程序行为。是指程序的一部分<strong>现在运行</strong>，而另一部分在<strong>将来运行</strong>——现在和将来之间有间隙，在这段间隙中，程序没有活跃。<br>所有重要的程序(特别是 JavaScript 程序)都需要通过这样或那样的方法来管理这段时间间隙，这时可能是在等待用户输入、从数据库或文件系统中请求数据、通过网络发送数据并等待响应。在诸如此类的场景中，程序都需要管理这段时间间隙的状态。<br><strong>程序中现在运行的部分和将来运行的部分之间的关系，就是异步编程的核心</strong></p><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><p>JavaScript 引擎并不是独立运行的，它运行在<strong>宿主环境</strong>中，对多数开发者来说通常就是 Web 浏览器。最近几年 JavaScript 已经超出了浏览器的范围，进入了其他环境。比如通过像 node.js 这样的工具进入服务器领域。但是这些所有环境都有一个共同的“点”，即他们都提供了一种机制来处理程序中多个块的执行，且执行每块时调用 JavaScript 引擎。这种机制被称为<strong>事件循环</strong>。<br>换句话说，JavaScript 引擎本身并没有时间的概念，只是一个按需执行 JavaScript 任意代码片段的环境。“事件”(JavaScript 代码执行)调度总是由包含它的环境进行。</p><p><code>setTimeOut(..)</code>并没有把你的回调函数挂在事件循环队列中，他所做的是设定一个定时器。当定时器到时，环境会把你的回调函数放在事件循环中，这样在未来某个时刻的 tick 会摘下并执行这个回调。假如此时事件循环中已经有 100 个项目了怎么办？它就得排在其他项目之后。这也解释了为什么<code>setTimeOut(..)</code>定时器的精度可能不高。只能保证你的回调函数不会在指定的时间间隔之前运行，可能在那个时刻，也可能在那个时刻之后运行。</p><h3 id="并行线程"><a href="#并行线程" class="headerlink" title="并行线程"></a>并行线程</h3><p>术语“异步”和“并行”常常被混为一谈，但实际上它们的意义完全不同。异步是<strong>现在</strong>和<strong>将来</strong>的时间间隙。而并行是关于能够同时发生的事情。</p><p>并行计算最常见的工具就是<strong>进程</strong>和<strong>线程</strong>。进程和线程独立运行，并可能同时运行：在不同的处理器，甚至不同的计算机上，但多个线程能够共享单个进程的内存。与之相对的是，事件循环把自身的工作分成一个个任务并顺序执行，不允许对共享内存并行访问和修改。通过分立线程中彼此合作的事件循环，并行和顺序执行可以共存。</p><p>并行线程的交替执行和异步事件的交替调度，其粒度是完全不同的。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  a <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  a <span class="token operator">=</span> a <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://some.url.1"</span><span class="token punctuation">,</span> foo<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://some.ur2.1"</span><span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>完整运行</strong><br>JavaScript 单线程运行特性，所以 foo()和 bar()中的代码具有原子性。也就是说，一旦 foo()开始运行，它的所有代码都会在 bar()中的任意代码运行之前完成。或者 bar()比 foo()运行的完整。这称为：<strong>完整运行</strong> 特性。</p><p>但是，同一段代码有两个可能输出意味着还是存在不确定性！！~但是，这种不确定性是在函数(事件)顺序级别上，而不是多线程情况下的语句顺序级别(或者说，表达式运算顺序级别)。换句话说，这一确定性要高于多线程情况。<br>在 JavaScript 特性中，这种函数顺序的不确定性，就是通常所说的<strong>竞态条件</strong>，foo()和 bar()相互竞争，看谁先运行。具体的说，因为无法可靠预测 a 和 b 的最终结果，所以才是竞态条件。</p><p>单线程事件循环是==并发==的一种形式。</p><p><strong>不交互</strong><br>两个或多个“进程”在同一个程序内并发地交替运行它们的步骤/事件时，如果这些任务彼此不相关，就不一定需要交互。<strong>如果进程间没有相互影响的话，不确定性是完全可以接受的</strong>。</p><p><strong>交互</strong><br>并发的“进程”需要相互交流，通过作用域或 DOM 间接交互。如果出现这样的交互，就需要对它们的交互进行协调以避免竞态的出现。</p><p><strong>协作</strong><br>一种并发合作方式，称为“并发协作”。<br>如下情况:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">response</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">//创建一个新的变换数组并把所有data值加倍</span>    data<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://some.url.1"</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//异步的ajax请求</span></code></pre><p>当 ajax 请求返回结果之后，整个列表会映射到 res 中，如果记录只有几千条，就没什么关系，如果有 1000w 条记录的话，就可能需要运行很长时间了。这样的“进程”运行时，页面上的其他代码都不能运行，包括不能有其他的 response 调用或 UI 刷新，甚至像滚动、输入、按钮点击这样的用户事件。</p><p>所以要创建一个协作性更强更友好且不会霸占事件循环队列的并发系统，可以异步地批处理这些结果。每次处理之后返回事件循环，让其他等待事件有机会运行。如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">response</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> chunk <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//分块，将数据一次运算1000个</span>    res <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>        chunk<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>data<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">//如果还有数据，就接着调用</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">response</span><span class="token punctuation">(</span> data <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://some.url.1"</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//异步的ajax请求</span></code></pre><p>把数据集合放在最多包含 1000 条项目的块中。这样，就确保了“进程”运行时间很短，即使这意味着需要更多后续“进程”，因为事件循环的交替运行会提高站点/APP 的响应(性能)。这里使用 setTimeout(..,0),进行异步调度，意思就是“把这个函数插入到当前事件循环队列的结尾处”。</p><p><strong>任务</strong>：<br>对于任务队列最好的理解方式：它是挂在事件循环队列的每个 tick 之后的一个队列。在事件循环的每个 tick 中，可能出现的异步动作不会导致一个完整的新事件添加到事件循环队列中，而会在当前 tick 的任务队列末尾添加一个项目。(一个任务)。提一下，promise 的异步特性是基于任务的。</p><p><strong>小结</strong><br>实际上，JavaScript 程序总是至少分为两块：第一块<strong>现在</strong>执行，下一块<strong>将来</strong>运行，以响应某个事件。尽管程序是一块一块执行的，但是所有这些块共享对程序作用域和状态的访问，所以对状态的修改都是在之前累积的修改之上进行的。<br>一旦有事件需要运行，事件循环就会运行，直到队列清空。事件循环的每一轮称为一个 tick。用户交互、IO 和定时器会向事件队列中加入事件。<br>任意时刻，一次只能从队列中处理一个事件。执行事件的时候，可能直接或间接地引发一个或多个后续事件。<br>并发是指两个或多个事件链随事件发展交替执行，以至于从更高的层次来看，就像是同时在运行(尽管在任意时刻只处理一个事件)。<br>通常需要对这些并发执行的“进程”(和操作系统中的进程不同)进行某种形式的交互协调，比如需要确保执行顺序或者需要防止竞态出现。这些“进程”也可以通过把自身分割为更小块，以便于其他“进程”插入进来。</p><p><strong>回调地狱</strong>：<br>我们的顺序阻塞式的大脑计划行为无法很好地映射到面向回调的异步代码。这就是回调方式最主要的缺陷：对于它们在代码中表达异步的方式，我们的大脑需要努力才能同步得上。</p><p><strong>Node 风格</strong>：<br>有一种常见的回调模式叫做“error-first 风格”，有时也叫 Node 风格，因为几乎所有的 Node.js API 都会采用这种风格。其中回调的第一个参数保留用作错误对象(如果有的话)，如果成功的话，这个参数就会被清空/置假(后续的参数就是成功数据)。不过，如果产生了错误结果，那么第一个参数就会被置起/置真(通常就不会再传递其他结果)：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">response</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//出错？</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//否则认为成功</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://some.url.1"</span><span class="token punctuation">,</span> response<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面展示一个工具：验证概念版本</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">timeoutify</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这个setTimeout会隔一段delay的时间</span>  <span class="token comment" spellcheck="true">//再把这个function放到任务队列里面</span>  <span class="token comment" spellcheck="true">//到了时间，就抛出timeout错误</span>  <span class="token keyword">var</span> intv <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    intv <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Timeout!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//return的这个函数算是闭包了</span>  <span class="token comment" spellcheck="true">//里面有intv这个东西，会提升到全局变量吧</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//返回的函数判断一下intv是否存在</span>    <span class="token comment" spellcheck="true">//如果超时了delay就会置为null</span>    <span class="token comment" spellcheck="true">//没超时的话就把定时器清除掉</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>intv<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">clearTimeout</span><span class="token punctuation">(</span>intv<span class="token punctuation">)</span><span class="token punctuation">;</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//使用方式</span><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">"http://someurl.1"</span><span class="token punctuation">,</span> <span class="token function">timeoutify</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>ajax 异步调用请求需要耗费时间，如果响应很快，500ms 以内就能响应，那就调用了<code>timeoutify</code>返回的那个函数，在函数里面执行相应的逻辑：500ms 还没到， 定时器的任务还没执行，intv 还是真值，判断后清除这个定时器，然后让 foo 函数在 ajax 回调的环境中执行。猜测，ajax 必定至少返回两个参数，一个是 err 的位置，返回的必然是 null，另一个是 data 的位置，应该返回相应的请求数据。</p><p><strong>小结</strong><br>回调函数是 JavaScript 异步的基本单元。但是随着 JavaScript 越来越熟，对于异步编程领域的发展，回调已经不够用了。</p><ol><li>大脑对于事情的计划方式是线性的、阻塞的、单线程的语义，但是回调表达异步流程的方式是非线性的，非顺序的，这使得正确推导这样的代码难度很大。难于理解的代码是坏代码，会导致 bug。</li><li>更重要的一点是，回调会受到控制翻转的影响！因为回调会把控制权交给第三方(通常是不受控制的第三方工具！)来调用代码中的<code>continuation</code>。这种控制转移导致一系列麻烦的信任问题，比如回调的次数是否会超出预期。</li></ol><p>可以发明一些特定的逻辑来解决这些信任问题，但是其难度高于应有的水平，可能会产生更笨重、更难维护的代码。并且缺少足够的保护，其中的损害要直到受到 bug 的影响才会被发现。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>一但我需要的值准备好了，我就用我的承诺值换取这个值本身。</p><p>从外部看，由于 Promise 封装了依赖于时间的状态——等待底层值的完成或拒接，所以 Promise 本身是与时间无关的。因此，Promise 可以按照可预测的方式组成(组合)，而不用关心时序或底层的结果。</p><p>一旦 Promise 决议，它就永远保持在这个状态。此时它就成为了不变值，可以根据需求多次查看。Promise 决议后就是外部不可变的值，我们可以安全地把这个值传递给第三方，并确信它不会被有意无意地修改。特别是对于多方查看同一个 Promise 决议的情况，尤其如此。<br>Promise 是一种封装和组合未来值的易于复用的机制。</p><h4 id="具有-then-方法的鸭子类型"><a href="#具有-then-方法的鸭子类型" class="headerlink" title="具有 then 方法的鸭子类型"></a>具有 then 方法的鸭子类型</h4><p>如何判断某个值是不是 promise？既然 promise 是通过 new promise(..)语法创建的你可能认为使用 <code>p instanceof Promise</code>来判断，但是这种方式不足以作为检查方法。最重要的原因是，Promise 值可能是从其他浏览器窗口(iframe 等)接收到的，这个浏览器窗口自己的 Promise 可能和当前窗口/frame 的不同，因此这样的检查无法识别 Promise 实例。此外，库和框架可能会选择实现自己的 Promise，而不是使用原生 ES6 Promise 实现。实际上，很可能使用的是早期根本没有 Promise 实现的浏览器中使用由库提供的 Promise。</p><p>根据一个值的形态(具有哪些属性)对这个值的类型作出一些假定。这种类型检查一般用术语<strong>鸭子类型</strong>来表示——(如果它看起来像只鸭子，叫起来像只鸭子，那它一定就是鸭子)，于是检测大概就是这样：</p><pre><code>if(    p !== null &amp;&amp;    (        typeof p === &quot;object&quot; ||        typeof p == &quot;function&quot;    ) &amp;&amp;    typeof p.then === &quot;function&quot;) {    //假定这就是一个thenable}else {    //不是一个thenable}</code></pre><p>假如在原型中加入了 then 函数，那么生成的对象就会被认定为 thenable 的。</p><pre><code>Object.prototype.then = function() {};Array.prototype.then = function() {};var v1 = { hello: &quot;world&quot; };var v2 = [ &quot;hello&quot;, &quot;world&quot;];</code></pre><p>v1 和 v2 都会被认作是 thenable。如果有任何代码无意或恶意地给 Object.prototype、Array.prototype 或任何原生原型添加 then(..)，如果有 Promise 决议到这样的值，就会永远挂住。</p><h4 id="Promise-的信任问题"><a href="#Promise-的信任问题" class="headerlink" title="Promise 的信任问题"></a>Promise 的信任问题</h4><p>把一个回调传入工具 foo(..)时，可能会出现如下问题：</p><ul><li>调用回调过早</li><li>调用回调过晚(或不被调用)</li><li>调用回调次数过少或过多</li><li>未能传递所需的环境和参数</li><li>吞掉可能出现的错误和异常<br>Promise 的特性就是专门用来为这些问题提供一个有效的可复用的答案。</li></ul><p><strong>调用过早</strong><br>根据定义，promise 就不必担心这种问题，因为即使是立即完成的 Promise,如下：</p><pre><code>new Promise( function(resolve) {    resolve(32);})</code></pre><p>也无法被同步观察到。也就是说，对一个 Promise 调用 then(…)的时候，即使这个 Promise 已经决议，提供给 then(..)的回调的总会被异步调用。</p><p><strong>调用过晚</strong><br>Promise 创建对象调用 resolve(..)或 reject(..)时，这个 promise 的 then(..)注册的观察回调就会被自动调度。一个 promise 决议后，这个 promise 上所有的通过 then(..)注册的回调都会在下一个异步时机点上依次被立即调用。这些回调中的任意一个都无法影响或延误对其他回调的调用。</p><p><strong>回调未调用</strong><br>没有任何东西(甚至是 JavaScript 错误)能阻止 Promise 向你通知它的决议(如果它决议了的话)。如果对一个 Promise 注册了一个完成回调和一个拒绝回调，那么 Promise 在决议时总是会调用其中的一个。</p><p><strong>调用次数过多或过少</strong><br>根据定义，回调被调用的正确次数应该是 1.“过少”的调用次数就是 0 次，和前面解释的唯美调用是一个道理。“过多”的情况很容易解释。Promise 的定义方式使得它只能被决议一次，如果出于某种原因，Promise 创建的代码试图调用 resolve(..)或 reject(..)多次，或者试图两者都调用，那么这个 Promise 将只会接受第一次决议，并默默地忽略任何后续调用。由于 Promise 只能被决议一次，所以任何通过 then(..)注册的(每个)回调就只会被调用一次。</p><p><strong>未能传递参数/环境值</strong><br>Promise 最多只能有一个决议值(完成或拒绝)。<br>如果没有用任何值显式决议，那么这个值就是<code>undefined</code>,这是 JavaScript 常见的处理方式。但不管这个值是什么，无论当前或未来，他都会被传给所有注册的(且适当的完成或拒绝)回调。<br>此外，如果使用多个参数调用 resolve(..)或者 reject(..)，第一个参数之后的所有参数都会被默默忽略。如果要传递多个值，就必须要把它们封装在单个值中传递，比如通过一个数组或对象。</p><p><strong>吞掉错误或异常</strong><br>如果拒绝一个 promise 并给出一个理由(也就是一个出错信息)，这个值就会被传给拒绝回调。如果在 promise 的创建过程中或在查看决议过程中的任意时间点，出现了一个 JavaScript 异常错误，比如一个 TypeError 或 ReferenceError，那这个异常就会被捕捉，并且会使这个 promise 被拒绝。</p><p><strong>链式流</strong><br>Promise并不只是一个单步执行this-then-that操作的机制，我们可以把多个Promise连接到一起以表示一系列异步步骤。<br>这种方式可以实现的关键在于以下两个Promise固有行为特性：  </p><ul><li>每次对Promise调用then(..)，他都会创建并返回一个新的promise，我们可以将其链接起来。</li><li>不管从then(..)调用的完成回调(第一个参数)返回的值是什么，它都会被自动设置为被链接Promise(第一点中的)的完成。  </li></ul><p>一个链式的demo：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">21</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//创建一个promise并返回</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span> resolve<span class="token punctuation">,</span> reject <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//这里是一些异步操作</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolve</span><span class="token punctuation">(</span> v <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//上一个promise1000ms后执行这个</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> v <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//42</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>将这种链式的异步链接封装为一个工具，以便多个步骤调用，如下:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">delay</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> time <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">100</span> <span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">//步骤1</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">STEP2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"在第一步过后的100ms，进行第二步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">200</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">STEP3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"第二步过后的200ms，进行第三步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">delay</span><span class="token punctuation">(</span> <span class="token number">300</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span> <span class="token function">STEP4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"第三步过后的300ms，进行第四步"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>假如promise链中的某个步骤出错了会怎么样？错误和异常是基于每个promise的，这意味着可能在链的任意位置捕捉到这样的错误，而这个捕捉动作在某种程度上就相当于将整条链“重置”到了正常运作,如下：  </p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//前置操作</span><span class="token keyword">function</span> <span class="token function">request</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//ajax()回调应该是我们这个promise的resolve函数</span>        <span class="token function">ajax</span><span class="token punctuation">(</span> url<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//步骤1</span><span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.1/"</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//步骤2</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>response1<span class="token punctuation">)</span><span class="token punctuation">{</span>    foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//undefined出错</span>    <span class="token comment" spellcheck="true">//永远走不到这里</span>    <span class="token keyword">return</span> <span class="token function">request</span><span class="token punctuation">(</span> <span class="token string">"http://some.url.2/?v="</span> <span class="token operator">+</span> response1 <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//步骤3</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span>response2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//永远不会到这里    </span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//来自foo.bar()的错误TypeError</span>        <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//步骤4</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> msg <span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//42  上一个步骤的错误返回值</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第2步出错后，第3步的拒绝函数会捕捉到这个错误。如果有拒绝处理函数的返回值的话，会用来完成交给下一个步骤的promise。这样，这个链现在就回到了完成状态。  </p><p>如果没有给then(..)传递一个适当有效的函数作为完成处理函数参数，还是会有作为替代的一个默认处理函数：  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span> <span class="token number">42</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>    <span class="token comment" spellcheck="true">//假定的完成处理函数，如果省略或者传入任何非函数值</span>    <span class="token comment" spellcheck="true">//function(v) {</span>    <span class="token comment" spellcheck="true">//    return v;</span>    <span class="token comment" spellcheck="true">//}</span>    <span class="token keyword">null</span><span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token function">reject</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//到不了这里，因为promise直接被resolve了</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>默认的完成处理函数，会把接收到的任何传入值传递给下一个步骤(promise).<br><strong><code>then(null, function(err){..})</code>这个模式——只处理拒绝，但又把完成值传递下去，它有一个缩写形式的API:<code>catch(function(err) {..})</code></strong>  </p><p>总结一下使链式流程控制可行的Promise固有特性:  </p><ul><li>调用Promise的then(..)会自动创建一个新的Promise从调用返回</li><li>在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的(可链接的)Promise就响应地决议。  </li><li>如果完成或拒绝处理函数返回一个Promise，他会将被展开，这样一来，无论它的决议值是什么，都会成为当前then(..)返回的链接promise的决议值。</li></ul><p><code>Promise.resolve()</code> 会将传入的真正Promise直接返回，对传入的<code>thenable</code>则会展开。</p><p><strong>术语：决议、完成以及拒绝</strong><br>看一下Promise的构造器:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span>Y<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// X(); //用于完成</span>    <span class="token comment" spellcheck="true">// Y(); //用于拒绝</span><span class="token punctuation">}</span> <span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第一个函数标识Promise已经完成，第二个标识Promise被拒绝。代码的名称只是一个标识符，对引擎而言没有任何意义。</p><p><strong>错误处理</strong><br>同步处理错误，使用<code>try ..catch</code>;异步处理错误，有一种<code>error-first</code>回调风格:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> baz<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">cb</span><span class="token punctuation">(</span> <span class="token keyword">null</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//成功</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">err</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">cb</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> err <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> val <span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>写一个函数，传入的参数是一个回调函数，业务逻辑都在函数内部，只有按照逻辑完成或者出错后，给回调函数传递相应的参数。上面的例子，只有在baz.bar()调用会同步地立即成功或失败的情况下，<code>try..catch</code>才能工作，如果baz.bar()本身有自己的异步完成函数，其中的任何异步错误都将无法捕捉。  </p><p>门机制是要等待两个或更多并行/并发的任务都完成才能继续。完成的顺序并不重要，但是必须都要完成。Promise.all([..])需要一个参数，是一个数组，通常由promise实例组成。从Promise.all([..])调用返回的promise会收到一个完成消息。这是一个由所有传入promise的完成消息组成的数组，与指定顺序一致(与完成顺序无关)。传给Promise.all([..])的数组中的值可以是Promise、thenable，甚至是立即值。列表中的每个值都会通过Promise.resolve(..)过滤，以确保等待的是一个真正的Promise。  </p><p>有时有这种需求，只响应第一个跨过终点线的Promise，而抛弃其他的Promise，这就需要用到——<code>Promise.race([..])</code>，这中模式传统上称为门闩，但在Promise中称为竞态。<br>一旦有任何一个Promise决议为完成，Promise.race([..])就会完成；一旦有任何一个Promise决议为拒绝，他就会拒绝。  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">"promise1"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">setTimeout</span><span class="token punctuation">(</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">"promise2"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>Promise<span class="token punctuation">.</span><span class="token function">race</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span> <span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token punctuation">)</span></code></pre><p>这里写一个demo试一下，确实是第一个决议后的promise，无论是完成还是拒绝，都会返回第一个完成的结果。  </p><p><strong>all([..])和race([..])的变体</strong>  </p><ul><li>none([..])，这个模式类似于all([..])，不过完成和拒绝的情况互换了，所有的Promise都要被拒绝，即拒绝转化为完成值。  </li><li>any([..])，这个模式和all([..])类似，但是会忽略拒绝，所以只需要完成一个而不是全部。  </li><li>first([..]) 这个模式类似于与any([..])的竞争。即只要第一个Promise完成，它就会忽略后续的任何拒绝和完成。  </li><li>last([..])这个模式类似于first([..])，但却是最后一个完成胜出。  </li></ul><h5 id="Promise-API概述"><a href="#Promise-API概述" class="headerlink" title="Promise API概述"></a>Promise API概述</h5><p><strong>new Promise(..)构造器</strong>  </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span> <span class="token keyword">function</span><span class="token punctuation">(</span>resovle<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//resolve(..)   用于决议/完成这个promise</span>    <span class="token comment" spellcheck="true">//reject(..)    用于拒绝这个promise</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  </code></pre><p>reject(..)就是拒绝这个promise，但是resolve(..)既可能完成promise也可能拒绝。要根据传入的参数而定。如果传给resolve(..)的是一个非Promise、非thenable的立即值，这个promise就会用这个值完成。但是如果传给resolve(..)的是一个真正的Promise或thenable值，这个值就会被递归展开，并且(要构造的)promise将取用其最终决议值或状态。  </p><p><strong>then(..)和catch(..)</strong><br>每个promise实例(不是promise API命名空间)都有then(..)和catch(..)方法，通过这两个方法可以为这个Promise注册完成和拒绝处理函数。Promise决议之后，立即回调用这两个处理函数之一，但不会两个都调用，而且总是异步调用。<br>then(..)接受一个或两个参数：第一个用于完成回调，第二个用于拒绝回调。如果两者中的任何一个被省略或者作为非函数值传入的话，就会替换为相应的默认回调。默认完成回调<strong>只是把消息传递下去</strong>；默认拒绝回调<strong>则只是重新抛出(传播)其接收到的出错原因</strong>。  </p><p><strong>如果向Promise.all([..])传入空数组，它会立即完成， 但Promise.race([..])会挂住，且永远不会决议。</strong>  </p><h5 id="Promise的局限性"><a href="#Promise的局限性" class="headerlink" title="Promise的局限性"></a>Promise的局限性</h5><ul><li><p>顺序错误处理<br>在promise链中，假如中间的某个promise出了错误，链中的任何地方的任何错误都会在链中一直传播下去，直到被查看。</p><pre><code>var p = foo(42);.then( STEP2).then( STEP3);</code></pre><p>这里的p并不指向链中的第一个promise，而是指向最后一个promise，即来自调用then(STEP3)的那一个。很多时候并没有为Promise链序列的中间步骤保留的引用，没有这样的引用就无法关联错误处理函数来可靠地检查错误。  </p></li><li><p>无法取消的Promise<br>一旦创建了一个Promise并为其注册了完成或拒绝函数，如果出现某种情况使得这个任务悬而未决的话，开发者也没有办法从外部停止它的进程。  </p></li></ul><p>如果说Promise确实有一个真正的性能局限的话，那就是它们没有真正提供可信任性保护支持的列表以供选择(你总是得到全部)。  </p><ul><li>小结<br>promise解决了我们因只用回调的代码而备受困扰的<strong>控制反转</strong>问题。<br>是它们并没有摒弃回调，只是把回调的安排转交给了一个位于我们和其他工具之间的可信任的中介机制。  </li></ul><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>先看一段合作式并发的ES6代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token keyword">yield</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//暂停</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"x:"</span> <span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    x<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//下面构造一个迭代器it来控制这个生成器</span><span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//启动foo()</span>x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//2</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      x<span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//3</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//x: 3</span></code></pre><p>运行流程：  </p><ol><li>it = foo()运算并没有执行生成器 *foo()，而只是构造了一个迭代器，这个迭代器会控制它的执行。  </li><li>第一个it.next()启动了生成器<code>*foo()</code>，并运行了<code>*foo()</code>的第一行的x++。</li><li><code>*foo()</code>在yield语句处暂停，在这里第一个it.next()的调用结束。此时<code>*foo()</code>仍然是活跃的，但处于暂停状态。</li><li>查看x的值，此时为2.</li><li>调用bar()，它通过x++再次递增x。</li><li>再次查看x的值，此时为3.</li><li>最后的it.next()调用从暂停处恢复了生成器<code>*foo()</code>的执行，并运行console.log(..)，此时当前x的值是3.</li></ol><p>显然foo()启动了，但是没有完整运行。它在yield处暂停了。后面恢复了foo()并让它运行到结束。但这不是必须的。生成器就是一类特殊的函数，可以一次或多次启动和停止，并不一定非得要完成。</p><p><strong>生成器的迭代消息传递</strong><br>除了能够接受参数并提供返回值之外，生成器甚至提供了更强大的内建消息输入输出能力，通过yield和next(..)实现。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> y <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//启动foo(..)</span><span class="token keyword">var</span> res <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//传参</span>res<span class="token punctuation">.</span>value<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//42</span></code></pre><p>首先传入6作为参数x。然后调用it.next(),这会启动<code>*foo(..)</code>,在<code>*foo(..)</code>内部，开始执行赋值语句，但随后就遇到了一个yield表达式，它就会在这一点上暂停<code>*foo(..)</code>，并在本质上要求调用代码为yield表达式提供一个结果值。接下来，调用it.next(7)，这一句把值7传回作为被暂停的yield的表达式。  </p><p>yield和next(..)调用有一个不匹配，一般来说，next()要比yield语句多一个。为什么呢？因为第一个next(..)总是启动一个生成器，并运行到第一个yield处。不过，是第二个next(..)调用完成第一个被暂停的yield表达式，第三个next(..)调用完成第二个yield，以此类推。  </p><p>消息是双向传递的——yield..作为一个表达式可以发出消息响应next(..)调用，next(..)也可以向暂停的yield表达式发送值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> y <span class="token operator">=</span> x <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">yield</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> res <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第一个next，开启生成器</span>res<span class="token punctuation">.</span>value               <span class="token comment" spellcheck="true">// "Hello"</span>res <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//向等待的yield传入7</span>res<span class="token punctuation">.</span>value<span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">//42</span></code></pre><p>yield..和next(..)这一对组合起来，<strong>在生成器的执行过程中</strong>构成了一个双向信息传递系统。  </p><p>我们并没有向第一个next()调用发送值，只有暂停的yield才能接受这样一个通过next(..)传递的值，而在生成器的起始处我们调用第一个next()时，还没有暂停的yield来接受这样一个值。规范和所有兼容浏览器都会默默丢弃传递给第一个next()的任何东西。<br>next()提出问题，yield回答问题。但是next()比yield要多一个，最后就由return来回答最后一个问题！  </p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>你不知道的JavaScript(中卷)1</title>
      <link href="/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD1/"/>
      <url>/2019/09/23/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JavaScript%E4%B8%AD1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一部分-类型和语法"><a href="#第一部分-类型和语法" class="headerlink" title="第一部分 类型和语法"></a>第一部分 类型和语法</h2><h3 id="第一章-类型"><a href="#第一章-类型" class="headerlink" title="第一章 类型"></a>第一章 类型</h3><p>这些工具库之所以功能强大，正是因为它们的开发者理解这门语言的本质和优点，并将它们运用到了极致。<br>JavaScript 有 7 中内置类型：</p><ul><li>空值（null）</li><li>未定义（undefined）</li><li>布尔值（boolean）</li><li>数字（number）</li><li>字符串（string）</li><li>对象（object）</li><li>符号（symbol ES6 新增）<br><strong>除了对象之外，其他类型被称为基本类型</strong><br>使用符合条件来检验 null 值的类型:</li></ul><pre><code>(!a &amp;&amp; typeof a === &quot;object&quot;);  //true</code></pre><p>还有一种情况，<code>typeof function a(){ /*...*/} === &quot;function&quot;; //true</code> 这么看来 function 也是 JavaScript 的内置类型之一，但实际上它是 object 的一个子类型。</p><h4 id="值和类型"><a href="#值和类型" class="headerlink" title="值和类型"></a>值和类型</h4><p>JavaScript 中的变量是没有类型的，只有值才有。变量可以随时持有任何类型的值。JavaScript 不做“类型强制”，即一个变量可以现在被赋值为字符串类型值，随后又被赋值为数字类型的值。<br>polyfill:衬垫代码，用来为旧浏览器提供它没有原生支持的较新的功能。<br>与 undeclared 变量不同，访问不存在的对象属性，甚至是在全局对象 windos 上，也不会产生 ReferenceError 错误。</p><h3 id="第二章-值"><a href="#第二章-值" class="headerlink" title="第二章 值"></a>第二章 值</h3><p>和其他强类型语言不同，在 JavaScript 中，数组可以容纳任何类型的值，可以是字符串、数字、对象、甚至是其他数组。使用 delete 运算符可以将单元从数组中删除，但是，单元删除后，数组的 length 属性不会发生变化。<br>数组通过数字进行索引，但它们也是对象，所以也可以包含字符串键值和属性（但这些并不计算在数组长度内），但是有个问题需要注意，如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当作数字索引来处理。</p><pre><code>var a = [];a[0] = 1;a[&quot;test&quot;] = 1;a.length;   //1var b = [];b[&quot;13&quot;] = 1;b.length;   //14</code></pre><p>JavaScript 中字符串是不可变的，而数组是可变的。字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。<br>将字符串反转的方法：先将字符串转换为数组，待处理完后再将结果转换回字符串。</p><pre><code>var str_reverse = str                .split(&quot;&quot;)  //将值转换为字符串数组                .reverse()  //将数组中的值进行反转                .join(&quot;&quot;);  将数组中的字符拼接为字符串</code></pre><p>JavaScript 只有一种数值类型，number(数字),包括”整数”和带小数的十进制数。<br>二进制浮点数最大的问题是会出现这种情况: <code>0.1+0.2 === 0.3 //false</code>，因为二进制浮点数中的 0.1 和 0.2 并不是很精确，相加结果是 0.30000000000004。<br>有时 JavaScript 程序需要处理一些比较大的数字，如数据库中的 64 位 ID 等。由于 JavaScript 的数字类型无法精确呈现 64 位数值，所以必须将它们保存(转换)为字符串。</p><p>可以使用<code>Number.isSafeInter(..)</code>来检测一个数是不是整数。<br>a|0 可以将变量中的数值转换为 32 位有符号整数，因为数位运算符|只适用于 32 位整数(它只关心 32 位以内的数，其他的数位将被忽略)，因此和 0 做|运算即可截取 a 中的 32 位数位。</p><p><strong>void 运算符</strong><br>按照惯例我们使用<code>void 0</code>来获得 undefined，使用其他表达式也可以，<code>void 0</code>、<code>void true</code>、<code>undefined</code>没有本质的区别。</p><p><strong>-0</strong><br><code>var a = -1/3;</code> <code>// -0</code><br>有些应用程序中的数据需要以级数的形式来表示(比如动画帧的移动速度)，数字的符号位用来代表其他数据，(比如移动的方向)。如果一个值为 0 的变量失去了他的符号位，它的方向信息就会丢失。</p><p><strong>特殊等式</strong><br>ES6 加入了一个工具方法<code>Object.is(..)</code>，可以判断两个值是否绝对相等。</p><pre><code>var a = 2 / &quot;foo&quot;;var b = -3 / 0;Object.is(a, NaN);  //trueObject.is(b, -0);   //trueObject.is(b, 0);    //false</code></pre><p><strong>值和引用</strong></p><pre><code>var a = 2;var b = a;  //b是a值的一个副本b++;a;  //2b;  //3var c = [1, 2, 3];var d = c;  //d是[1, 2, 3] 的一个引用d.push(4);c;  //[1, 2, 3, 4]d;  //[1, 2, 3, 4]</code></pre><p>简单值，即标量基本类型，总是通过值复制的方式来赋值/传递的。包括 null、undefined、字符串、数字、布尔值和 ES6 的 symbol。<br>复合值——对象(包括数组和封装对象)和函数，则总是通过引用复制的方式来赋值/传递的。<br><strong>清空数组的一个快捷方法</strong></p><pre><code>x = [1, 2, 3, 4];x.length = 0;x;  //[]</code></pre><p>这样，数组就被清空了。<br>如果通过值复制的方式来传递复合值(如数组)，就需要为其创建一个副本，这样传递的值就不是原始值。如:<code>foo( a.slice() )</code>，slice()不带参数会返回当前数组的一个浅副本。</p><h3 id="第-3-章-原生函数"><a href="#第-3-章-原生函数" class="headerlink" title="第 3 章 原生函数"></a>第 3 章 原生函数</h3><p><strong>内部属性 class</strong><br>所有 typeof 返回值为”object”的对象，都包含一个内部属性，[[Class]]，(我们可以把它看一个内部的分类，而非传统的面向对象意义上的类)，这个属性无法直接访问，一般通过<code>Object.prototype.toString(..)</code>来查看。如：</p><pre><code>Object.prototype.toString( [1,2,3] );   //&quot;[object Array]&quot;Object.prototype.toString( /regex-literal/i );   //&quot;[object RegExp]&quot;</code></pre><p>如数组的内部[[Class]]属性值是”Array”,正则表达式的是”RegExp”。基本类型的值，如 string，number，boolean，会被各自的封装对象自动装箱。由于基本类型值没有.length 和/toString() 这样的属性和方法，需要通过封装对象才能访问，此时 JavaScript 会自动为基本类型值包装一个封装对象。<br>想要得到封装后的对象的值，可以使用 valueOf()方法。<br>Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度(length)，而非只充当数组中的一个数组。<br>JavaScript 为基本数据类型提供了封装对象，成为原生函数，(如 String、Number、Boolean)，他们为基本数据类型值提供了该子类型所特有的方法和属性。(如<code>String.prototype.trim()</code> 、<code>Array.prototype.concat()</code>等。) 对于简单标量基本类型值，比如”abc”，如果要访问它的 length 属性或者<code>String.prototype</code>方法，JavaScript 引擎会自动对该值进行封装。</p><h3 id="第-4-章-类型强制转换"><a href="#第-4-章-类型强制转换" class="headerlink" title="第 4 章 类型强制转换"></a>第 4 章 类型强制转换</h3><h4 id="值类型转换"><a href="#值类型转换" class="headerlink" title="值类型转换"></a>值类型转换</h4><p>将值从一种类型转换为另一种类型通常称为类型转换，这是显式的情况，隐式的情况被称为“强制类型转换”。JavaScript 中的强制类型转换总是返回标量基本类型，如字符串、数字和布尔值，不会返回对象和函数。类型转换发生在静态类型语言的编译阶段，而强制类型转换则发生在动态类型语言的运行时。<br>不安全的 JSON 值：undefined、function、symbol 和包含循环引用(对象之间互相引用，形成一个无限循环)的对象。<br>如果要对含有非法 JSON 值的对象做字符串化，或者对象中的某些值无法被序列化时，就需要定义 toJSON()方法，来返回一个安全的 JSON 值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  b<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span>  c<span class="token punctuation">:</span> o<span class="token punctuation">,</span>  d<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>o<span class="token punctuation">.</span>e <span class="token operator">=</span> a<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//在a中创建一个循环引用</span><span class="token comment" spellcheck="true">//  JSON.stringify( a );    //循环引用会在这里产生错误</span>a<span class="token punctuation">.</span>toJSON <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//自定义的JSON序列化</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>b <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "{ "b" : 42}"</span></code></pre><p>toJSON()并不是返回一个 JSON 字符串化后的值，其实 toJSON()返回的应该是一个适当的值，可以是任何类型，然后由 JSON.stringify() 对其进行字符串化。<br>toJSON()应该返回一个能够被字符串化的安全的 JSON 值，而不是返回一个 JSON 字符串。<br>还可以向 JSON.stringify(..) 传递一个可选参数 replacer，它可以是数组或者函数，用来指定对象序列化过程中哪些属性应该被处理，哪些应该被排除，和 toJSON()很像。</p><pre><code>var a = {    b: 42,    c: &quot;42&quot;;    d: [1,2,3]};JSON.stringify( a, [&quot;b&quot;, &quot;c&quot;] );    // &quot;{ &quot;b&quot;: 42, &quot;c&quot;: &quot;42&quot;}&quot;JSON.stringify( a, function(k,v) {    if( k!== &quot;c&quot;) return v;});     // &quot;{ &quot;b&quot;:42, &quot;d&quot;:[1,2,3]}&quot;</code></pre><p>JSON.string 还有一个可选参数 space，用来指定输出的缩进格式。space 为正整数时是指定每一级缩进的字符数，它还可以是字符串，此时最前面的字符被用于每一级的缩进。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>    b<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span>    c<span class="token punctuation">:</span> <span class="token string">"42"</span><span class="token punctuation">,</span>    d<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">}</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span> a<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">"-----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>输出结果为<span class="token punctuation">{</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token string">"b"</span><span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token string">"c"</span><span class="token punctuation">:</span> <span class="token string">"42"</span><span class="token punctuation">,</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token string">"d"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token number">3</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p><strong>有关 JSON.stringify()两个要点：</strong></p><ol><li>字符串、数字、布尔值和 null 的 JSON.stringify()规则与 toString()基本相同。</li><li>如果传递给 JSON.stringify() 的对象中定义了 toJSON()方法，那么该方法会在字符串化前调用，以便将对象转换为安全的 JSON 值。</li></ol><p><strong>数字 number</strong><br>从 ES5 开始，使用<code>Object.create(null)</code>创建的对象[[Prototype]]属性为 null，并且没有 valueOf()方法和 toString()方法，因此无法进行强制类型转换。</p><pre><code>var a = {    valueOf: function() {        return &quot;42&quot;;    }};var b = {    toString: function() {        return &quot;42&quot;;    }};var c = [4,2];c.toString = function() {    return this.join( &quot;&quot; );};Number( a );    //42Number( b );    //42Number( c );    //42Number( &quot;&quot; );    //0Number( [] );    //0Number( [&quot;abc&quot;] );    //NaN</code></pre><p><strong>布尔值</strong><br>JavaScript 中的值可以分为两类：</p><ul><li>可以被强制类型转换为 false 的值</li><li>其他(被强制类型转换为 true 的值)</li></ul><p>会被转化为假值的有:</p><ul><li>undefined</li><li>null</li><li>false</li><li>+0 、-0 和 NaN</li><li>“”</li></ul><p><code>Boolean( document.all )</code> 结果是 false</p><p><strong>字符串和数字之间的显式转换</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token string">"3.14"</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token operator">+</span>c<span class="token punctuation">;</span></code></pre><p>a.toString() 是显式的，不过其中涉及隐式转换。直接输入 12.toString()会报错，所以 JavaScript 引擎会自动为 12 创建一个封装对象，然后对该对象调用 toString(),这里显式转换中含有隐式转换。<code>+c</code>操作是 + 运算符的一元形式(即只有一个操作数)。+运算符显式的将 c 转换为数字，而非数字加法运算。</p><p><strong>获得时间戳的方法</strong></p><pre><code>var a = +new Date();var a = Date.now();var a = (new Date()).getTime();</code></pre><p><strong>~操作符</strong><br>~相当于补码，<code>~x = -(x+1)</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"Hello World"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"lo"</span><span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//true</span>  <span class="token comment" spellcheck="true">//找到匹配</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"lo"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//true</span>  <span class="token comment" spellcheck="true">//找到匹配</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"ol"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//true</span>  <span class="token comment" spellcheck="true">//没有找到匹配</span><span class="token punctuation">}</span></code></pre><p><code>&gt;=0</code> 和<code>==-1</code>这样的写法不是很好，成为“抽象渗漏”，意思是在代码中暴露了底层的实现细节，这里是指用-1 作为失败时的返回值，这些细节应该被屏蔽掉。使用~就可以和 indexOf()一起，将结果强制类型转换为真/假值。如果 indexOf() 返回-1，~将其转换为假值 0，其他情况一律转换为真值。<br><code>~~</code>操作符可以截取数字值的小数部分。~~中的第一个<code>~</code>执行 ToInt32 并翻转字位，然后第二个<code>~</code>再进行一次字位翻转，即将所有字位翻转回原值，最后得到的仍然是 ToInt32 的结果。对负数的小数处理会将小数点后的去掉。</p><h4 id="显式解析数字字符串"><a href="#显式解析数字字符串" class="headerlink" title="显式解析数字字符串"></a>显式解析数字字符串</h4><pre><code>var a = &quot;42&quot;;var b = &quot;42px&quot;;Number( a );    //42parseInt( a );  //42Number( b );    //NaNparseInt( b );  //42</code></pre><p>解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。解析允许字符串中含有非数字字符，解析按照从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN。</p><h4 id="显式转换为布尔值"><a href="#显式转换为布尔值" class="headerlink" title="显式转换为布尔值"></a>显式转换为布尔值</h4><p>一元运算符<code>!</code>显式的将值强制类型转换为布尔值，但是值会翻转。所以最常用的显式强制类型转换为布尔值最的方法是<code>!!</code>，第二个！会将结果翻转为原值。</p><h4 id="隐式强制类型转化"><a href="#隐式强制类型转化" class="headerlink" title="隐式强制类型转化"></a>隐式强制类型转化</h4><pre><code>var a = [1, 2];var b = [3, 4];a + b;      //&quot;1,23,4&quot;</code></pre><p>a 和 b 都不是字符串，但是它们都被强制转换为字符串然后进行拼接。</p><pre><code>var a = {    valueOf: function() { return 42; },    toString: function() { return 4; }};a + &quot;&quot;;     //&quot;42&quot;String( a );    //&quot;4&quot;</code></pre><p>a+””会对 a 调用 valueOf 方法，然后通过 toString()抽象操作将返回值转换为字符串。而 String(a) 则是直接调用 toString()方法。</p><p><strong>字符串强制转换为数字的情况</strong></p><pre><code>var a = &quot;3.14&quot;;var b = a - 0;b;  //3.14</code></pre><p><code>-</code>是减法运算符，因此 a-0 会将 a 强制类型转换为数字。也可以使用 a * 1 和 a / 1 ，因为这两个运算符也只适用于数字。</p><pre><code>var a = [3];var b = [1];a - b;  //2</code></pre><p>为了执行减法运算，a 和 b 都需要被转换为数字，它们首先被转换为字符串(通过 toString()),然后再转换为数字。</p><p><strong>布尔值到数字的转换</strong></p><pre><code>//显式类型转换function onlyOne() {    var sum = 0;    for(var i=0; i&lt;arguments.length; i++) {        sum += Number( !!arguments[i] );    }    return sum === 1;}//隐式类型转换function onlyOne() {    var sum = 0;    for(var i=0; i&lt;arguments.length; i++) {        if( arguments[i] ) {            sum += arguments[i];        }    }    return sum === 1;}</code></pre><p><code>!!arguments[i]</code>首先将参数转换为 true 或者 false，转换为布尔值之后，再通过 Number(..)显式强制类型转换为 0 或 1。无论是显式还是隐式，想要实现<code>onlyTwo()</code>、或者<code>onlyFour()</code>,只需要把判断条件改为<code>sum===2</code>、或者 <code>sum === 4</code>即可。</p><p><strong>逻辑运算的 || 和 &amp;&amp;</strong><br>将它们称为“逻辑运算符”不太准确，称他们为“选择器运算符”或者“操作数选择器运算符”更恰当些。和其他语言不同，在 JavaScript 中它们返回的并不是布尔值，而是两个操作数中的一个。</p><pre><code>var a = 42;var b = &quot;abc&quot;;var c = null;a||b;       //42a&amp;&amp;b;       //&quot;abc&quot;c||b;       //&quot;abc&quot;c&amp;&amp;b;       //null</code></pre><p>在 C 和 PHP 中，上例的结果是 true 或者是 false，在 JavaScript(以及 Python 和 Ruby)中却是某个操作数的值。<br>||和&amp;&amp;首先会对第一个操作数进行判断，如果不是布尔值，就先进行 toBoolean 强制类型转换，然后再执行条件判断。<br><strong>对于||来说</strong>：如果条件判断结果为 true，就返回第一个操作数的值，如果为 false，就返回第二个操作数的值。<br><strong>对于&amp;&amp;来说</strong>：如果第一个判断结果为 true，则返回第二个操作数。如果第一个判断结果为 false，就直接返回第一个操作数的值。<br>从另一个角度看：</p><p><code>a || b;</code> //大概就相当于<br><code>a ? a : b</code></p><p><code>a &amp;&amp; b;</code> //大概就相当于<br><code>a ? b : a</code></p><p><strong>守护运算符</strong>：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//等价于</span>a <span class="token operator">&amp;&amp;</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>foo()只有在条件判断 a 通过时才会被调用。如果条件判断未通过， a &amp;&amp; foo()就会悄然终止，也叫做（短路）。</p><p><strong>宽松相等和严格相等</strong><br>常见的误区是”<code>==</code>检查值是否相等，<code>===</code>检查值和类型是否相等”，听起来蛮有道理，然而不够准确。正确的解释应该是”<code>==</code>允许在相等中进行强制类型转换，而<code>===</code>不允许”。<br>==<code>==</code>和<code>===</code>都会检查操作数的类型，区别在于操作数类型不同时，它们的处理方式不同。==</p><p><strong>字符串和数字之间的相等比较</strong>：<br>是数字转化为字符串还是字符串转化为数字?ES5 的规范这样定义：<br>(1)如果 Type(x)是数字，Type(y)是字符串，则返回 x==ToNumber(y) 的结果。<br>(2)如果 Type(x)是字符串，Type(y)是数字，则返回 ToNumber(x)==y 的结果。</p><p><strong>其他类型和布尔类型之间的相等比较</strong>：</p><pre><code>var a = &quot;42&quot;;var b = true;a == b; //falsea == false; //false  这个字符串既不==true 也不==falsea = &quot;1&quot;;a == b; //true</code></pre><p>ES5 中的规范：<br>(1)如果 Type(x) 是布尔类型，则返回 ToNumber(x) == y 的结果。<br>(2)如果 Type(y) 是布尔类型，则返回 x == ToNumber(y) 的结果。<br>引擎会把布尔类型的变量强制转换为数字值，即转换为 0 或 1，然后再与另一个变量进行比较。<br>尽量避免使用 ==true 和 ==false</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"42"</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这样用条件不成立</span>  <span class="token comment" spellcheck="true">//..</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//这样用条件也不成立</span>  <span class="token comment" spellcheck="true">//..</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//这样的显式用法没问题</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token operator">!</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//这样的显式用法更好</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">Boolean</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//这样的显式用法也很好</span></code></pre><p><strong>null 和 undefined 的比较</strong>：<br>(1)如果 x 为 null，y 为 undefined，则结果为 true。<br>(2)如果 x 为 undefined，y 为 null，则结果为 true。</p><pre><code>var a = null;var b;a == b;     //truea == null;  //trueb == null;  //truea == false; //falseb == false; //falsea == &quot;&quot;;    //falseb == &quot;&quot;;    //falsea == 0;      //falseb == 0;     //false</code></pre><p><strong>对象和非对象之间的相等比较</strong>：<br>关于对象(对象、函数、数组)和标量基本类型(字符串、数字、布尔值)之间的相等比较，ES5 有如下规范：<br>(1)如果 Type(x)是字符串或数字，Type(y)是对象，则返回 x == ToPrimitive(y)的结果。<br>(2)如果 Type(x) 是对象，Type(y)是字符串或数字，则返回 ToPromitive(x) == y 的结果。</p><pre><code>var a = 42;var b = [42];a==b;   //true</code></pre><p>[42]首先调用 ToPromitive 抽象操作，返回”42”,变成<code>&quot;42&quot;==42</code>，<code>然后又变成42==42</code>，最后二者相等。</p><p><strong>少见的情况</strong>：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>Number<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>valueOf <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> i<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Number</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//无论初初始值给的多少，返回的都一样</span><span class="token comment" spellcheck="true">//这种情况可能发生吗？？</span><span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> a <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"还真发生了！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>极端情况</strong></p><pre><code>[] == ![];  //true</code></pre><p>根据 ToBoolean 规则，它会进行布尔值的显式强制转换(同时反转奇偶校验位)。所以<code>[]==![]</code>变成了<code>[]==false</code>。</p><p>一些奇怪的地方</p><pre><code>&quot;0&quot; == false;   //truefalse == 0;     //truefalse == &quot;&quot;;    //truefalse == [];    //true&quot;&quot; == 0;        //true&quot;&quot; == [];       //true0 == [];        //true</code></pre><p><strong>安全运用隐式强制类型转换</strong></p><ul><li>如果两边的值中有 true 或者 false，千万不要用 false</li><li>如果两边的值有[]、””、或者 0，尽量不要使用==。</li></ul><p>这时最好用===来避免不经意的强制类型转换。这两个原则可以让我们避开几乎所有强制类型转换的坑。这种情况下强制类型转换越显式越好。所以选择<code>==</code>还是<code>===</code>取决于是否允许在相等比较中发生强制类型转换。</p><p><strong>抽象关系比较</strong>：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//fasle</span>a <span class="token operator">==</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>a <span class="token operator">></span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span>a <span class="token operator">&lt;=</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span>a <span class="token operator">>=</span> b<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>看了上面的代码是不是觉得 R 了狗了。。a==b 进行比较，因为两个都是对象，需要引用同一个对象才会判断为 true。判断 a&lt;b 时，因为此时调用方法将两边转换为字符串，a 结果是[object Object],b 也是[object Object],所以按照字母顺序 a&lt;b 并不成立。但是 a&lt;=b 和 a&gt;=b 怎么就成立了？<strong>因为根据规范，a&lt;=b 被处理为 b&lt;a ，然后将结果翻转。因为 b&lt;a 的结果是 false，所以 a&lt;=b 的结果是 true</strong>，我们可能认为&lt;=是“小于或者等于” 的意思，实际上 JavaScript 中&lt;=是“不大于”的意思。</p><h3 id="第五章-语法"><a href="#第五章-语法" class="headerlink" title="第五章 语法"></a>第五章 语法</h3><p><code>++a++</code>会产生 ReferenceError 错误，因为运算符需要将产生的副作用赋值给一个变量。它首先执行 a++(根据运算符优先级)，返回 42，然后执行<code>++42</code>，这时会产生 ReferenceError 错误，因为<code>++</code>无法直接在 42 这样的值上产生副作用。</p><p>组合赋值运算符，如<code>a = b += 2</code>首先执行<code>b+=2</code>,然后结果再被赋值给 a。</p><p>JavaScript 通过标签跳转能够实现 goto 的部分功能，continue 和 break 语句都可以带一个标签，因此能够像 goto 那样进行跳转。</p><pre class=" language-js"><code class="language-js">foo<span class="token punctuation">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">continue</span> foo<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>j <span class="token operator">*</span> i<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">continue</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>continue foo 并不是指“跳转到标签 foo 所在位置继续执行”而是“执行 foo 循环的下一轮循环”。所以这里的 foo 并非 goto</p><hr><p><strong>代码块</strong> ：<br>有一个坑，涉及强制类型转换。</p><pre><code>[] + {};    //&quot;[object Object]&quot;{} + [];    // 0</code></pre><p>表面上看，+运算符根据第一个操作数([]或{})的不同会产生不同的结果，实际则不是。<br>第一行代码中，{}出现在+运算符表达式中，因此它被当做一个值(空对象)来处理。[]会被强制转换为””,而{}会被强制转换为 “[object Object]”.<br>第二行代码中，{}被当做一个独立的空代码块(不执行任何操作)。代码块结尾不需要分号。最后 +[]将 []显式强制类型转换为 0。</p><hr><p><strong>对象解构</strong></p><pre><code>function getDate() {    return {        a: 42,        b: &quot;foo&quot;    };}var { a, b} = getDate();console.log( a , b);</code></pre><p>{ a, b} = getDate()就是 ES6 中的解构赋值。相当于如下代码：</p><pre><code>var res = getDate();var a = res.a;var b = res.b;</code></pre><p>此外，{..}还可以用作函数命名参数的对象解构，方便隐式地运用对象属性赋值:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//之前可能是传进来一个对象obj</span>  <span class="token comment" spellcheck="true">//然后 var a = obj.a; var b = obj.b; var c = obj.c;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  c<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>  a<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token string">"foo"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 42 "foo" [1,2,3]</span></code></pre><hr><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>用<code>,</code>连接一系列语句的时候，它的优先级最低，其他操作数的优先级都比它高。<br><code>if(str &amp;&amp; (matches = str.match( /[aeiou]/g) ) ){ .. }</code>，这里对赋值语句加上括号是十分必要的，因为&amp;&amp;运算符的优先级高于=，如果没有()对其中的表达式进行绑定的话，就会执行为 <code>(str &amp;&amp; matches)=str.match..</code>这样就会报错，因为(str &amp;&amp; matches)的结果不是一个变量，而是一个 undefined 的值，出现在=左边会出错！</p><p><strong>&amp;&amp;的优先级比||高</strong><br>(a &amp;&amp; b || c)执行的是 (a &amp;&amp; b) || c 还是 a &amp;&amp; (b || c)?</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//false</span><span class="token punctuation">(</span><span class="token boolean">false</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//true</span></code></pre><p>顺序不同结果还是有区别的，结果表示&amp;&amp;的优先级比||的优先级要高。</p><p><strong>短路</strong><br>对于&amp;&amp;和||来说，如果从左边的操作数得到结果，就可以忽略右边的操作数。我们将这种现象称为“短路”。(即执行最短路径)<br>“短路很方便也很常用”，如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts <span class="token operator">&amp;&amp;</span> opts<span class="token punctuation">.</span>cool<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//..</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>opts &amp;&amp; opts.cool 中的 opts 条件判断如同一道安全保护，因为如果 opts 未赋值，(或者不是一个对象)，表达式 opts.cool 就会出错。通过使用短路特性，opts 条件判断未通过时，opts.cool 就不会执行，就不会产生错误！~</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span>opts<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opts<span class="token punctuation">.</span>cache <span class="token operator">||</span> <span class="token function">primeCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//..</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这里首先判断 opts.cache 是否存在，如果存在就不需要在调用 primeCache() 函数，这样可以避免执行不必要的代码。</p><p><strong>&amp;&amp;和||和?:的优先级</strong>:<br>a &amp;&amp; b || c ? c || b ? a : c &amp;&amp; b : a<br>其中的 ?: 运算符的优先级比&amp;&amp;和||的高还是低呢？<br>结果应该是这样: <code>(a &amp;&amp; b || c) ? (c || b) ? a : (c &amp;&amp; b) : a</code></p><hr><p><strong>右关联</strong><br>a ? b : c ? d : e; 因为<code>?:</code>是右关联，所以它的组合顺序是 <code>a ? b : (c ? d : e)</code>,有些情况下可能返回结果是相同的，但是过程却有着微妙的变化。<br>另一个右关联的组合是<code>=</code>运算符。下面是一个超级叼的表达式:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token string">"foo"</span><span class="token punctuation">;</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">)</span> <span class="token operator">||</span> c <span class="token operator">?</span> <span class="token punctuation">(</span>c <span class="token operator">||</span> b <span class="token operator">?</span> a <span class="token punctuation">:</span> c <span class="token operator">&amp;&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">:</span> a<span class="token punctuation">;</span>d<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//42</span></code></pre><p>来分析一下，&amp;&amp;的优先级最高，然后是||的优先级，最后是?:,所以上面的表达式可以分为这样<code>((a &amp;&amp; b) || c) ? ((c || b) ? a :(c &amp;&amp; b)) : a</code>,这样结果就很清晰了。慢慢推导，结果是 42.</p><p><strong>函数参数</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">,</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>arguments<span class="token punctuation">.</span>length<span class="token punctuation">,</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arguments<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//0 42 43 undefined undefined</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 10 11 10 undefined</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> undefined<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2 10 11 10 undefined</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//2 10 null 10 null</span></code></pre><h4 id="try…finally"><a href="#try…finally" class="headerlink" title="try…finally"></a>try…finally</h4><p>finally 中的代码总是会在 try 之后执行，如果有 catch 的话，则在 catch 之后执行。也可以将 finally 中的代码看做一个回调函数，即无论出现什么情况最后一定会被调用。<br>如果 finally 中抛出了异常(无论是有意还是无意)，函数就会在此终止。如果此前 try 中已经有 return 设置了返回值，则该值会被丢弃：</p><pre><code>function foo() {    try {        return 32;    }    finally {        throws &quot;stop!&quot;;    }    console.log(&quot;永远执行不到这里&quot;);}console.log( foo() );// Uncaught Exception: stop!</code></pre><p>此外，finally 中的 return 会覆盖 try 和 catch 中 return 中的返回值：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//没有返回语句，不会覆盖</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">42</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//会覆盖掉try中return的值</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//42</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//"hello"</span></code></pre><h4 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h4><pre><code>switch (a) {    case 2:        //dosomething();        break;    case 3:        //dosomething2();        break;    default:        //默认执行代码        break;}</code></pre><p>switch,刚开始确实觉得没什么好做比较的，但是看到两个小点，记一下。一个是 switch 的那个表达式，上式是 a，和 case 中每一项比较，都是<code>===</code>来进行比较，严格相等的，不能进行隐式强制转换的。还有一个看到一个可以用到强制转换的写法，感觉挺厉害的。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">"42"</span><span class="token punctuation">;</span><span class="token keyword">switch</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">case</span> a <span class="token operator">==</span> <span class="token number">10</span><span class="token punctuation">:</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"是10还是'10'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">case</span> a <span class="token operator">==</span> <span class="token number">42</span><span class="token punctuation">:</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"是42还是'42'"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">break</span><span class="token punctuation">;</span>  <span class="token keyword">default</span><span class="token punctuation">:</span>    <span class="token keyword">break</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//"是42还是'42'"</span></code></pre><p>赶脚用这种方式还挺巧妙的，能用到隐式转换。</p><p>{ }在不同情况下的意思不尽相同，可以是语句块、对象常量、解构赋值(ES6)或者命名函数参数(ES6).</p><p>JavaScript 语言本身有一个统一的标准，在所有浏览器/引擎中的实现也是可靠的。但是 JavaScript 很少独立运行。通常运行环境中还有第三方代码，有时代码甚至会运行在浏览器之外的引擎环境中。</p>]]></content>
      
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
